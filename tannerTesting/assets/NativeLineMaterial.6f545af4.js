import{l1 as yt,a as A,hk as jt,iW as aa,t as N,hi as se,h4 as Ot,ai as Gr,p as H,lP as Fn,hc as re,hn as ir,h5 as k,n as $,a0 as To,gb as rt,G as Co,H as bo,at as cr,lQ as oa,lR as zn,$ as jn,h as We,f as St,a5 as g,a6 as L,a8 as Ls,iS as _r,x as Ns,iR as ke,ha as ne,hH as Un,hO as Vn,hN as Qi,hF as ei,lS as Hn,hm as Gn,hh as dr,kh as Ao,aq as Tr,lT as Wn,lU as na,lV as la,h6 as ct,lW as ca,lX as Bn,ah as kn,iV as sr,ac as Z,lY as Nt,jm as Tt,ab as nt,h9 as it,hb as de,h8 as qn,s as Zr,lZ as Ro,a7 as Fi,lg as Le,T as da,l_ as Fs,hd as Wr,b3 as ae,_ as Cr,L as zt,l$ as zi,ie as zs,hl as yi,am as K,kZ as ha,kd as Xn,h7 as Zn,Y as Ut,ak as Rt,jY as tr,k6 as $r,kS as ua,jp as rr,jV as ye,m0 as Yn,jo as pa,hp as Jn,m1 as Qn,it as Kn,r as ji,m2 as el,m3 as tl,m4 as rl,lE as fa,m5 as ot,m6 as il,j as sl,J as Ki,eg as ma,eh as al,jM as ol,g5 as nl,m7 as es,gK as ll,m8 as As,m9 as cl,l0 as dl,hf as Eo,ma as hl,mb as ul,jR as js,bc as pl,lj as fl,mc as ml,ka as gl,md as vl,lO as _l,ly as yl,me as Sl,cM as wl,mf as xl,mg as Ol,mh as Tl,hj as Cl,eu as bl,k as Al,i1 as Rl,mi as El,lr as Pl,hA as ga,fq as Dl,ln as $l,mj as Il,mk as Ml}from"./index.3255d2a5.js";import{r as le,n as te,t as va}from"./vec3f32.4d8dc001.js";import{l as Rs,p as dt,j as gt,V as ce,Y as Si,_ as Ll,x as Nl}from"./plane.a0a08b54.js";import{R as Fl,C as zl,d as mt,b as jl,h as Ul,a as Es,p as Vl}from"./sphere.67ec4acb.js";import{s as j}from"./Attribute.98e6fe67.js";import{V as Po,e as br,W as _a,X as ya,Y as Sa,w as O,k as Do,j as x,H as Ar,o as B,b as ar,Z as pi,_ as jr,$ as $o,a0 as Us,u as Vs,a1 as wi,a2 as Io,a3 as Hl,m as Pe,G as Gl,d as Yr,a4 as Wl,a5 as Mo,a6 as Hs,B as Jr,g as yr,c as wt,a7 as Lo,a8 as Bl,D as Gs,y as vt,z as Ui,F as Ue,h as Rr,i as Er,O as xi,Q as Oi,R as Ws,p as W,t as Pr,a9 as wa,aa as kl,ab as ql,ac as Xl,ad as No,I as Vi,s as xt,K as Hi,ae as Zl,v as Ne,a as Bs,f as Vt,af as ts,ag as Yl,ah as Jl,ai as xa,aj as Ql,J as Kl,ak as ec,al as tc,am as rs,an as Fo,ao as zo,ap as rc,x as ks,aq as ic,ar as Gi,as as sc,at as ac,au as jo,av as oc,E as Qr,T as qs,L as Xs,r as nc,aw as lc,ax as cc,ay as dc,az as hc,aA as uc,q as pc,aB as Uo,aC as fc,C as mc,aD as Vo,aE as gc,aF as vc,aG as _c,N as Oa,aH as yc,aI as Sc,aJ as Ta,aK as wc,U as xc,aL as Oc,M as Tc,aM as Cc,aN as bc,aO as Ca,aP as ba,aQ as Ac,aR as Ho,aS as Rc,S as Ec}from"./VertexColor.glsl.e3d82815.js";import{n as Zs,f as Ti,l as Go,a as Aa}from"./triangulationUtils.2ec0b7a6.js";import{o as Pc}from"./Indices.27b9c798.js";import{s as Oe,l as Wo,a as Dc,c as kt,f as ti,h as $c}from"./Util.3efb1a6b.js";import{O as u}from"./VertexAttribute.34e3daf1.js";import{e as Y,o as Bo}from"./mat4f64.9070f685.js";import{m as Ic,M as Mc,f as Lc}from"./hydratedFeatures.b4cbc12d.js";import{e as Ys}from"./mat3f64.9180efcb.js";import{x as Nc,i as Fc,u as zc}from"./BufferView.32a50625.js";import{T as bt}from"./InterleavedLayout.a42ad5fa.js";import{b as ie,o as m,n as jc,W as et,c as Ur,A as Wi,l as Js,d as Sr,E as ko,_ as lt,e as Uc,f as qo,S as Xo,g as Zo,a as Vc,h as Hc}from"./OrderIndependentTransparency.43c6e481.js";import{Y as Yo,V as Jo,M as Vr,P as wr,G as Br,D as xr,L as Ci,E as Ht,_ as bi,F as Qo,A as Gc,C as Wc,R as tt,I as Bc}from"./enums.3c1fa5b5.js";import{t as Ra,i as Ea,N as kc,n as Qs}from"./basicInterfaces.f8f3b23b.js";import{x as Ko,u as qc,E as en,n as Xc}from"./VertexArrayObject.ad007c8f.js";import{t as Ks}from"./NestedMap.2ac03b78.js";import{V as Zc,H as Yc,u as Jc,s as Qc,U as _t}from"./Octree.449e609a.js";import{v as Bi,M as tn,b as hr,k as rn}from"./lineSegment.1a0fd96e.js";import{o as sn}from"./floatRGBA.7b501bd7.js";import{E as or}from"./Texture.d66dc1cb.js";import"./boundedPlane.91a64206.js";import{o as Kc}from"./glUtil.9de5d1d0.js";var Hr,Ai,Ps;(function(t){t[t.RasterImage=0]="RasterImage",t[t.Features=1]="Features"})(Hr||(Hr={})),function(t){t[t.MapLayer=0]="MapLayer",t[t.ViewLayer=1]="ViewLayer",t[t.Outline=2]="Outline",t[t.SnappingHint=3]="SnappingHint"}(Ai||(Ai={})),function(t){t[t.WithRasterImage=0]="WithRasterImage",t[t.WithoutRasterImage=1]="WithoutRasterImage"}(Ps||(Ps={}));var Ri,Ke;(function(t){t[t.ADD=0]="ADD",t[t.UPDATE=1]="UPDATE",t[t.REMOVE=2]="REMOVE"})(Ri||(Ri={})),function(t){t[t.NONE=0]="NONE",t[t.VISIBILITY=1]="VISIBILITY",t[t.GEOMETRY=2]="GEOMETRY",t[t.TRANSFORMATION=4]="TRANSFORMATION",t[t.HIGHLIGHT=8]="HIGHLIGHT",t[t.OCCLUDEE=16]="OCCLUDEE"}(Ke||(Ke={}));var kr;(function(t){t[t.ASYNC=0]="ASYNC",t[t.SYNC=1]="SYNC"})(kr||(kr={}));class ed extends Po{get geometries(){return this._geometries}get transformation(){return this._transformation}set transformation(e){yt(this._transformation,e),this._invalidateBoundingVolume(),this._emit("objectTransformation",this)}constructor(e={}){super(),this.type=br.Object,this._geometries=new Array,this._transformation=Y(),this._bvObjectSpace=new Pa,this._bvWorldSpace=new Pa,this._bvDirty=!0,this._hasVolatileTransformation=!1,this._visible=!0,this.castShadow=e.castShadow==null||e.castShadow,this.metadata=e.metadata,this.metadata&&this.metadata.isElevationSource&&(this.metadata.lastValidElevationBB=new an);const r=e.geometries;A(r)&&(this._geometries=Array.from(r))}dispose(){this._geometries.length=0}get parentLayer(){return this._parentLayer}set parentLayer(e){Oe(this._parentLayer==null||e==null,"Object3D can only be added to a single Layer"),this._parentLayer=e}addGeometry(e){e.visible=this._visible,this._geometries.push(e),this._hasVolatileTransformation=this._hasVolatileTransformation||e.hasVolatileTransformation,this._emit("objectGeometryAdded",{object:this,geometry:e}),this._invalidateBoundingVolume()}removeGeometry(e){const r=this._geometries.splice(e,1)[0];r&&(this._emit("objectGeometryRemoved",{object:this,geometry:r}),this._invalidateBoundingVolume())}removeAllGeometries(){for(;this._geometries.length>0;)this.removeGeometry(0)}geometryVertexAttrsUpdated(e){this._emit("objectGeometryUpdated",{object:this,geometry:e}),this._invalidateBoundingVolume()}get visible(){return this._visible}set visible(e){if(this._visible!==e){this._visible=e;for(const r of this._geometries)r.visible=this._visible;this._emit("visibilityChanged",this)}}maskOccludee(){const e=new _a(Ra.MaskOccludee);for(const r of this._geometries)r.occludees=ya(r.occludees,e);return this._emit("occlusionChanged",this),e}removeOcclude(e){for(const r of this._geometries)r.occludees=Sa(r.occludees,e);this._emit("occlusionChanged",this)}highlight(){const e=new _a(Ra.Highlight);for(const r of this._geometries)r.highlights=ya(r.highlights,e);return this._emit("highlightChanged",this),e}removeHighlight(e){for(const r of this._geometries)r.highlights=Sa(r.highlights,e);this._emit("highlightChanged",this)}getCombinedStaticTransformation(e,r){return jt(r,this.transformation,e.transformation)}_getCombinedShaderTransformation(e){return jt(Y(),this.transformation,e.shaderTransformation)}hasVolativeTransformation(){return this._hasVolatileTransformation}get boundingVolumeWorldSpace(){return this._validateBoundingVolume(),this._bvWorldSpace}get boundingVolumeObjectSpace(){return this._validateBoundingVolume(),this._bvObjectSpace}_validateBoundingVolume(){if(!this._bvDirty&&!this._hasVolatileTransformation)return;this._bvObjectSpace.init(),this._bvWorldSpace.init();for(const s of this._geometries){const a=s.boundingInfo;A(a)&&(Da(a,this._bvObjectSpace,s.shaderTransformation),Da(a,this._bvWorldSpace,this._getCombinedShaderTransformation(s)))}aa(this._bvObjectSpace.bounds,this._bvObjectSpace.min,this._bvObjectSpace.max,.5),aa(this._bvWorldSpace.bounds,this._bvWorldSpace.min,this._bvWorldSpace.max,.5);const e=$(),r=$(),i=Rs(this.transformation);for(const s of this._geometries){const a=s.boundingInfo;if(N(a))continue;const o=s.shaderTransformation,n=Rs(o);se(e,a.center,o);const l=Ot(e,this._bvObjectSpace.bounds),c=a.radius*n;this._bvObjectSpace.bounds[3]=Math.max(this._bvObjectSpace.bounds[3],l+c),se(r,e,this.transformation);const d=Ot(r,this._bvWorldSpace.bounds),f=c*i;this._bvWorldSpace.bounds[3]=Math.max(this._bvWorldSpace.bounds[3],d+f)}this._bvDirty=!1}_invalidateBoundingVolume(){this._bvDirty=!0,A(this._parentLayer)&&this._parentLayer.notifyObjectBBChanged(this,this._bvWorldSpace.bounds)}_emit(e,r){A(this._parentLayer)&&this._parentLayer.events.emit(e,r)}get test(){const e=this;return{hasGeometry:r=>e._geometries.includes(r),getGeometryIndex:r=>e._geometries.indexOf(r)}}}class an{constructor(){this.min=Gr(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this.max=Gr(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE)}isEmpty(){return this.max[0]<this.min[0]&&this.max[1]<this.min[1]&&this.max[2]<this.min[2]}}class Pa extends an{constructor(){super(...arguments),this.bounds=Fl()}init(){H(this.min,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),H(this.max,-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),zl(this.bounds)}}function Da(t,e,r){const i=t.bbMin,s=t.bbMax;if(Fn(r)){const a=H(td,r[12],r[13],r[14]);re(De,i,a),re(Ge,s,a);for(let o=0;o<3;++o)e.min[o]=Math.min(e.min[o],De[o]),e.max[o]=Math.max(e.max[o],Ge[o])}else if(se(De,i,r),ir(i,s))for(let a=0;a<3;++a)e.min[a]=Math.min(e.min[a],De[a]),e.max[a]=Math.max(e.max[a],De[a]);else{se(Ge,s,r);for(let a=0;a<3;++a)e.min[a]=Math.min(e.min[a],De[a],Ge[a]),e.max[a]=Math.max(e.max[a],De[a],Ge[a]);for(let a=0;a<3;++a){k(De,i),k(Ge,s),De[a]=s[a],Ge[a]=i[a],se(De,De,r),se(Ge,Ge,r);for(let o=0;o<3;++o)e.min[o]=Math.min(e.min[o],De[o],Ge[o]),e.max[o]=Math.max(e.max[o],De[o],Ge[o])}}}const td=$(),De=$(),Ge=$(),rd=["layerObjectAdded","layerObjectRemoved","layerObjectsAdded","layerObjectsRemoved","shaderTransformationChanged","objectTransformation","visibilityChanged","occlusionChanged","highlightChanged","objectGeometryAdded","objectGeometryRemoved","objectGeometryUpdated"];class id extends Po{get objects(){return this._objects}constructor(e,r=""){var i,s,a,o;super(),this.apiLayerUid=r,this.type=br.Layer,this.events=new To,this.sliceable=!1,this._objects=new rt,this._objectsAdded=new rt,this._stageHandles=new Co,this.apiLayerUid=r,this.visible=(i=e==null?void 0:e.visible)!=null?i:!0,this.pickable=(s=e==null?void 0:e.pickable)!=null?s:!0,this.updatePolicy=(a=e==null?void 0:e.updatePolicy)!=null?a:kr.ASYNC,this._disableOctree=(o=e==null?void 0:e.disableOctree)!=null?o:!1}destroy(){this.detachStage(),this._stage=null}attachStage(e){this.detachStage(),this._stage=e;for(const r of rd)this._stageHandles.add(this.events.on(r,i=>e.handleEvent(r,i)))}detachStage(){this._stageHandles.removeAll(),this.invalidateSpatialQueryAccelerator()}add(e){this._objects.push(e),e.parentLayer=this,this.events.emit("layerObjectAdded",{layer:this,object:e}),A(this._octree)&&this._objectsAdded.push(e)}remove(e){this._objects.removeUnordered(e)&&(e.parentLayer=null,this.events.emit("layerObjectRemoved",{layer:this,object:e}),A(this._octree)&&(this._objectsAdded.removeUnordered(e)||this._octree.remove([e])))}addMany(e){this._objects.pushArray(e);for(const r of e)r.parentLayer=this;this.events.emit("layerObjectsAdded",{layer:this,objects:e}),A(this._octree)&&this._objectsAdded.pushArray(e)}removeMany(e){const r=new Array;if(this._objects.removeUnorderedMany(e,e.length,r),r.length!==0){for(const i of r)i.parentLayer=null;if(this.events.emit("layerObjectsRemoved",{layer:this,objects:r}),A(this._octree)){for(let i=0;i<r.length;)this._objectsAdded.removeUnordered(r[i])?(r[i]=r[r.length-1],r.length-=1):++i;this._octree.remove(r)}}}sync(){A(this._stage)&&this.updatePolicy!==kr.SYNC&&this._stage.syncLayer(this.id)}notifyObjectBBChanged(e,r){A(this._octree)&&!this._objectsAdded.includes(e)&&this._octree.update(e,r)}getSpatialQueryAccelerator(){return N(this._octree)&&this._objects.length>50&&!this._disableOctree?(this._octree=new Zc(e=>e.boundingVolumeWorldSpace.bounds),this._octree.add(this._objects.data,this._objects.length)):A(this._octree)&&this._objectsAdded.length>0&&(this._octree.add(this._objectsAdded.data,this._objectsAdded.length),this._objectsAdded.clear()),this._octree}shaderTransformationChanged(){this.invalidateSpatialQueryAccelerator(),this.events.emit("shaderTransformationChanged",this)}invalidateSpatialQueryAccelerator(){this._octree=bo(this._octree),this._objectsAdded.clear()}}var ur,$a,Ia,Ma,ee,La,Na;(function(t){t[t.INNER=0]="INNER",t[t.OUTER=1]="OUTER"})(ur||(ur={})),function(t){t[t.REGULAR=0]="REGULAR",t[t.HAS_NORTH_POLE=1]="HAS_NORTH_POLE",t[t.HAS_SOUTH_POLE=2]="HAS_SOUTH_POLE",t[t.HAS_BOTH_POLES=3]="HAS_BOTH_POLES"}($a||($a={})),function(t){t[t.NORTH=0]="NORTH",t[t.NORTH_EAST=1]="NORTH_EAST",t[t.EAST=2]="EAST",t[t.SOUTH_EAST=3]="SOUTH_EAST",t[t.SOUTH=4]="SOUTH",t[t.SOUTH_WEST=5]="SOUTH_WEST",t[t.WEST=6]="WEST",t[t.NORTH_WEST=7]="NORTH_WEST"}(Ia||(Ia={})),function(t){t[t.OFF=0]="OFF",t[t.ON=1]="ON"}(Ma||(Ma={})),function(t){t[t.Color=0]="Color",t[t.ColorNoRasterImage=1]="ColorNoRasterImage",t[t.Highlight=2]="Highlight",t[t.Water=3]="Water",t[t.Occluded=4]="Occluded",t[t.ObjectAndLayerIdColor=5]="ObjectAndLayerIdColor"}(ee||(ee={})),function(t){t[t.FADING=0]="FADING",t[t.IMMEDIATE=1]="IMMEDIATE",t[t.UNFADED=2]="UNFADED"}(La||(La={})),function(t){t[t.INSIDE=0]="INSIDE",t[t.INTERSECTS=1]="INTERSECTS",t[t.OUTSIDE=2]="OUTSIDE"}(Na||(Na={}));class sd{constructor(e,r){this.vec3=e,this.id=r}}function fi(t,e,r,i){return new sd(Gr(t,e,r),i)}var nr;(function(t){t[t.None=0]="None",t[t.ColorAndWater=1]="ColorAndWater",t[t.Highlight=2]="Highlight",t[t.Occluded=3]="Occluded",t[t.ObjectAndLayerIdColor=4]="ObjectAndLayerIdColor"})(nr||(nr={}));class Fa{get extent(){return this._extent}constructor(e,r){this.index=e,this.renderTargets=r,this._extent=cr(),this.resolution=0,this.renderLocalOrigin=fi(0,0,0,"O"),this.pixelRatio=1,this.mapUnitsPerPixel=1,this.canvasGeometries=new ad,this.hasDrapedFeatureSource=!1,this.hasDrapedRasterSource=!1,this.hasTargetWithoutRasterImage=!1,this.index=e,this.validTargets=new Array(r.renderTargets.length).fill(!1)}getValidTexture(e){return this.validTargets[e]?this.renderTargets.getTarget(e).getTexture():null}get _needsColorWithoutRasterImage(){return this.hasDrapedRasterSource&&this.hasDrapedFeatureSource&&this.hasTargetWithoutRasterImage}getColorTexture(e){const r=e===nr.ColorAndWater?this.renderTargets.getTarget(ee.Color):e===nr.Highlight?this.renderTargets.getTarget(ee.Highlight):e===nr.ObjectAndLayerIdColor?this.renderTargets.getTarget(ee.ObjectAndLayerIdColor):this.renderTargets.getTarget(ee.Occluded);return r?r.getTexture():null}getColorTextureNoRasterImage(){return this._needsColorWithoutRasterImage?this.getValidTexture(ee.ColorNoRasterImage):this.hasDrapedFeatureSource?this.getValidTexture(ee.Color):null}getNormalTexture(e){const r=e===nr.ColorAndWater?this.renderTargets.getTarget(ee.Water):null;return r?r.getTexture():null}draw(e,r){const i=this.computeRenderTargetValidityBitfield();for(const s of this.renderTargets.renderTargets)s.type!==ee.ColorNoRasterImage||this._needsColorWithoutRasterImage?this.validTargets[s.type]=e.drawTarget(this,s,r):this.validTargets[s.type]=!1;return i^this.computeRenderTargetValidityBitfield()?Ea.CHANGED:Ea.UNCHANGED}computeRenderTargetValidityBitfield(){const e=this.validTargets;return+e[ee.Color]|+e[ee.ColorNoRasterImage]<<1|+e[ee.Highlight]<<2|+e[ee.Water]<<3|+e[ee.Occluded]<<4}setupGeometryViewsCyclical(e){this.setupGeometryViewsDirect();const r=.001*e.range;if(this._extent[0]-r<=e.min){const i=this.canvasGeometries.extents[this.canvasGeometries.numViews++];oa(this._extent,e.range,0,i)}if(this._extent[2]+r>=e.max){const i=this.canvasGeometries.extents[this.canvasGeometries.numViews++];oa(this._extent,-e.range,0,i)}}setupGeometryViewsDirect(){this.canvasGeometries.numViews=1,zn(this.canvasGeometries.extents[0],this._extent)}hasSomeSizedView(){for(let e=0;e<this.canvasGeometries.numViews;e++){const r=this.canvasGeometries.extents[e];if(r[0]!==r[2]&&r[1]!==r[3])return!0}return!1}applyViewport(e){e.setViewport(this.index===ur.INNER?0:this.resolution,0,this.resolution,this.resolution)}}class ad{constructor(){this.extents=[cr(),cr(),cr()],this.numViews=0}}class on{constructor(e,r){this._size=jn(),this._fbo=null,this._fbo=new Ko(e,{colorTarget:Yo.TEXTURE,depthStencilTarget:Jo.NONE},{target:Vr.TEXTURE_2D,pixelFormat:wr.RGBA,dataType:Br.UNSIGNED_BYTE,wrapMode:xr.CLAMP_TO_EDGE,samplingMode:Ci.LINEAR_MIPMAP_LINEAR,hasMipmap:r,maxAnisotropy:8,width:0,height:0})}dispose(){this._fbo=We(this._fbo)}getTexture(){return this._fbo?this._fbo.colorTexture:null}isValid(){return this._fbo!==null}resize(e,r){this._size[0]=e,this._size[1]=r,this._fbo.resize(this._size[0],this._size[1])}bind(e){e.bindFramebuffer(this._fbo)}generateMipMap(){const e=this._fbo.colorTexture;e.descriptor.hasMipmap&&e.generateMipmap()}disposeRenderTargetMemory(){var e;(e=this._fbo)==null||e.resize(0,0)}get gpuMemoryUsage(){var e,r;return(r=(e=this._fbo)==null?void 0:e.gpuMemoryUsage)!=null?r:0}}class qt{constructor(e,r,i,s=!0){this.output=r,this.type=i,this.valid=!1,this.lastUsed=1/0,this.fbo=new on(e,s)}}class od{constructor(e){this.renderTargets=[new qt(e,O.Color,ee.Color),new qt(e,O.Color,ee.ColorNoRasterImage),new qt(e,O.Highlight,ee.Highlight,!1),new qt(e,O.Normal,ee.Water),new qt(e,O.Color,ee.Occluded)],St("enable-feature:objectAndLayerId-rendering")&&this.renderTargets.push(new qt(e,O.ObjectAndLayerIdColor,ee.ObjectAndLayerIdColor))}getTarget(e){return this.renderTargets[e].fbo}dispose(){for(const e of this.renderTargets)e.fbo.dispose()}disposeRenderTargetMemory(){for(const e of this.renderTargets)e.fbo.disposeRenderTargetMemory()}validateUsageForTarget(e,r,i){if(e)r.lastUsed=i;else if(i-r.lastUsed>nd)r.fbo.disposeRenderTargetMemory(),r.lastUsed=1/0;else if(r.lastUsed<1/0)return!0;return!1}get gpuMemoryUsage(){return this.renderTargets.reduce((e,r)=>e+r.fbo.gpuMemoryUsage,0)}}const nd=1e3;class ld{constructor(e){this._context=e,this._perConstructorInstances=new Ks,this._frameCounter=0,this._keepAliveFrameCount=za}get viewingMode(){return this._context.viewingMode}get constructionContext(){return this._context}destroy(){this._perConstructorInstances.forEach(e=>e.forEach(r=>r.technique.destroy())),this._perConstructorInstances.clear()}acquire(e,r=dd){const i=r.key;let s=this._perConstructorInstances.get(e,i);if(N(s)){const a=new e(this._context,r,()=>this.release(a));s=new cd(a),this._perConstructorInstances.set(e,i,s)}return++s.refCount,s.technique}releaseAndAcquire(e,r,i){if(A(i)){if(r.key===i.key)return i;this.release(i)}return this.acquire(e,r)}release(e){if(N(e)||this._perConstructorInstances.empty)return;const r=this._perConstructorInstances.get(e.constructor,e.key);N(r)||(--r.refCount,r.refCount===0&&(r.refZeroFrame=this._frameCounter))}frameUpdate(){this._frameCounter++,this._keepAliveFrameCount!==za&&this._perConstructorInstances.forEach((e,r)=>{e.forEach((i,s)=>{i.refCount===0&&i.refZeroFrame+this._keepAliveFrameCount<this._frameCounter&&(i.technique.destroy(),this._perConstructorInstances.delete(r,s))})})}async reloadAll(){const e=new Array;this._perConstructorInstances.forEach((r,i)=>{const s=async(a,o)=>{const n=o.shader;n&&(await n.reload(),a.forEach(l=>l.technique.reload(this._context)))};e.push(s(r,i))}),await Promise.all(e)}}class cd{constructor(e){this.technique=e,this.refCount=0,this.refZeroFrame=0}}const za=-1,dd=new Do;function hd(t,e,r){return 2*Math.atan(Math.sqrt(e*e+r*r)*Math.tan(.5*t)/e)}function ud(t,e,r){return 2*Math.atan(Math.sqrt(e*e+r*r)*Math.tan(.5*t)/r)}function pd(t,e,r){return 2*Math.atan(e*Math.tan(.5*t)/Math.sqrt(e*e+r*r))}function fd(t,e,r){return 2*Math.atan(r*Math.tan(.5*t)/Math.sqrt(e*e+r*r))}var Ds;let V=Ds=class extends Ls{constructor(t={}){super(t),this._center=$(),this._up=$(),this._viewUp=$(),this._viewForward=$(),this._viewRight=$(),this._ray=mt(),this._viewport=_r(0,0,1,1),this._padding=_r(0,0,0,0),this._fov=55/180*Math.PI,this._nearFar=Ns(1,1e3),this._viewDirty=!0,this._viewMatrix=Y(),this._viewProjectionDirty=!0,this._viewProjectionMatrix=Y(),this._viewInverseTransposeMatrixDirty=!0,this._viewInverseTransposeMatrix=Y(),this._frustumDirty=!0,this._frustum=Yc(),this._fullViewport=ke(),this._pixelRatio=1,this.relativeElevation=0}get pixelRatio(){return this._pixelRatio}set pixelRatio(t){this._pixelRatio=t>0?t:1}get eye(){return this._ray.origin}set eye(t){this._compareAndSetView(t,this._ray.origin)}get center(){return this._center}set center(t){this._compareAndSetView(t,this._center,"_center")}get ray(){return ne(this._ray.direction,this.center,this.eye),this._ray}get up(){return this._up}set up(t){this._compareAndSetView(t,this._up,"_up")}get viewMatrix(){return this._ensureViewClean(),this._viewMatrix}set viewMatrix(t){yt(this._viewMatrix,t),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0}get viewForward(){return this._ensureViewClean(),this._viewForward}get viewUp(){return this._ensureViewClean(),this._viewUp}get viewRight(){return this._ensureViewClean(),this._viewRight}get nearFar(){return this._nearFar}get near(){return this._nearFar[0]}set near(t){this._nearFar[0]!==t&&(this._nearFar[0]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_nearFar"))}get far(){return this._nearFar[1]}set far(t){this._nearFar[1]!==t&&(this._nearFar[1]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_nearFar"))}get viewport(){return this._viewport}set viewport(t){this.x=t[0],this.y=t[1],this.width=t[2],this.height=t[3]}get screenViewport(){if(this.pixelRatio===1)return this._viewport;const t=Un(ke(),this._viewport,1/this.pixelRatio),e=this._get("screenViewport");return e&&Vn(t,e)?e:t}get x(){return this._viewport[0]}set x(t){t+=this._padding[G.LEFT],this._viewport[0]!==t&&(this._viewport[0]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get y(){return this._viewport[1]}set y(t){t+=this._padding[G.BOTTOM],this._viewport[1]!==t&&(this._viewport[1]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get width(){return this._viewport[2]}set width(t){this._viewport[2]!==t&&(this._viewport[2]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get height(){return this._viewport[3]}set height(t){this._viewport[3]!==t&&(this._viewport[3]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get fullWidth(){return this._viewport[2]+this._padding[G.RIGHT]+this._padding[G.LEFT]}set fullWidth(t){this.width=t-(this._padding[G.RIGHT]+this._padding[G.LEFT])}get fullHeight(){return this._viewport[3]+this._padding[G.TOP]+this._padding[G.BOTTOM]}set fullHeight(t){this.height=t-(this._padding[G.TOP]+this._padding[G.BOTTOM])}get fullViewport(){return this._fullViewport[0]=this._viewport[0]-this._padding[G.LEFT],this._fullViewport[1]=this._viewport[1]-this._padding[G.BOTTOM],this._fullViewport[2]=this.fullWidth,this._fullViewport[3]=this.fullHeight,this._fullViewport}get _aspect(){return this.width/this.height}get padding(){return this._padding}set padding(t){Qi(this._padding,t)||(this._viewport[0]+=t[G.LEFT]-this._padding[G.LEFT],this._viewport[1]+=t[G.BOTTOM]-this._padding[G.BOTTOM],this._viewport[2]-=t[G.RIGHT]+t[G.LEFT]-(this._padding[G.RIGHT]+this._padding[G.LEFT]),this._viewport[3]-=t[G.TOP]+t[G.BOTTOM]-(this._padding[G.TOP]+this._padding[G.BOTTOM]),ei(this._padding,t),this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_padding"),this.notifyChange("_viewport"))}get viewProjectionMatrix(){return this._viewProjectionDirty&&(jt(this._viewProjectionMatrix,this.projectionMatrix,this.viewMatrix),this._viewProjectionDirty=!1),this._viewProjectionMatrix}get projectionMatrix(){const t=this.width,e=this.height,r=this.near*Math.tan(this.fovY/2),i=r*this._aspect,s=Hn(Y(),-i*(1+2*this._padding[G.LEFT]/t),i*(1+2*this._padding[G.RIGHT]/t),-r*(1+2*this._padding[G.BOTTOM]/e),r*(1+2*this._padding[G.TOP]/e),this.near,this.far),a=this._get("projectionMatrix");return a&&Gn(a,s)?a:s}get inverseProjectionMatrix(){return dr(Y(),this.projectionMatrix)||this._get("inverseProjectionMatrix")||Y()}get fov(){return this._fov}set fov(t){this._fov=t,this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovX(){return pd(this._fov,this.width,this.height)}set fovX(t){this._fov=hd(t,this.width,this.height),this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovY(){return fd(this._fov,this.width,this.height)}set fovY(t){this._fov=ud(t,this.width,this.height),this._viewProjectionDirty=!0,this._frustumDirty=!0}get distance(){return Ot(this.center,this.eye)}get frustum(){return this._recomputeFrustum(),this._frustum}get viewInverseTransposeMatrix(){return(this._viewInverseTransposeMatrixDirty||this._viewDirty)&&(dr(this._viewInverseTransposeMatrix,this.viewMatrix),Ao(this._viewInverseTransposeMatrix,this._viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),this._viewInverseTransposeMatrix}depthNDCToWorld(t){const e=2*t-1;return 2*this.near*this.far/(this.far+this.near-e*(this.far-this.near))}get perRenderPixelRatio(){return Math.tan(this.fovX/2)/(this.width/2)}get perScreenPixelRatio(){return this.perRenderPixelRatio*this.pixelRatio}get aboveGround(){return this.relativeElevation!=null&&this.relativeElevation>=0}copyFrom(t){k(this._ray.origin,t.eye),this.center=t.center,this.up=t.up,ei(this._viewport,t.viewport),this.notifyChange("_viewport"),ei(this._padding,t.padding),this.notifyChange("_padding"),Tr(this._nearFar,t.nearFar),this.notifyChange("_nearFar"),this._fov=t.fov,this.relativeElevation=t.relativeElevation;const e=t;return this._viewDirty=e._viewDirty,this._viewDirty||(yt(this._viewMatrix,t.viewMatrix),k(this._viewRight,t.viewRight),k(this._viewUp,t.viewUp),k(this._viewForward,t.viewForward)),this._viewProjectionDirty=!0,this._frustumDirty=e._frustumDirty,this._frustumDirty||(Jc(this._frustum,t.frustum),this._frustumDirty=!1),e._viewInverseTransposeMatrixDirty?this._viewInverseTransposeMatrixDirty=!0:(yt(this._viewInverseTransposeMatrix,t.viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),ei(this._fullViewport,t.fullViewport),this.pixelRatio=t.pixelRatio,this}copyViewFrom(t){this.eye=t.eye,this.center=t.center,this.up=t.up}clone(){return new Ds().copyFrom(this)}equals(t){return ir(this.eye,t.eye)&&ir(this.center,t.center)&&ir(this.up,t.up)&&Qi(this._viewport,t.viewport)&&Qi(this._padding,t.padding)&&Wn(this.nearFar,t.nearFar)&&this._fov===t.fov&&this.pixelRatio===t.pixelRatio&&this.relativeElevation===t.relativeElevation}almostEquals(t){if(Math.abs(t.fov-this._fov)>=.001||na(t.padding,this._padding)>=.5||na(this.screenViewport,t.screenViewport)>=.5)return!1;la(ge,t.eye,t.center),la(is,this.eye,this.center);const e=ct(ge,is),r=ca(ge),i=ca(is),s=5e-4;return e*e>=(1-1e-10)*r*i&&Bn(t.eye,this.eye)<Math.max(r,i)*s*s}computeRenderPixelSizeAt(t){return this.computeRenderPixelSizeAtDist(this._viewDirectionDistance(t))}computeRenderPixelSizeAtDist(t){return t*this.perRenderPixelRatio}computeScreenPixelSizeAt(t){return this.computeScreenPixelSizeAtDist(this._viewDirectionDistance(t))}_viewDirectionDistance(t){return Math.abs(jl(this.viewForward,ne(ge,t,this.eye)))}computeScreenPixelSizeAtDist(t){return t*this.perScreenPixelRatio}computeDistanceFromRadius(t,e){return t/Math.tan(Math.min(this.fovX,this.fovY)/(2*(e||1)))}getScreenCenter(t=kn()){return t[0]=(this.padding[G.LEFT]+this.width/2)/this.pixelRatio,t[1]=(this.padding[G.TOP]+this.height/2)/this.pixelRatio,t}getRenderCenter(t,e=.5,r=.5){return t[0]=this.padding[G.LEFT]+this.width*e,t[1]=this.padding[G.BOTTOM]+this.height*r,t[2]=.5,t}setGLViewport(t){const e=this.viewport,r=this.padding;t.setViewport(e[0]-r[3],e[1]-r[2],e[2]+r[1]+r[3],e[3]+r[0]+r[2])}applyProjection(t,e){t!==M&&k(M,t),M[3]=1,sr(M,M,this.projectionMatrix);const r=Math.abs(M[3]);Z(M,M,1/r);const i=this.fullViewport;e[0]=Nt(0,i[0]+i[2],.5+.5*M[0]),e[1]=Nt(0,i[1]+i[3],.5+.5*M[1]),e[2]=.5*(M[2]+1),e[3]=r}unapplyProjection(t,e){const r=this.fullViewport;M[0]=(t[0]/(r[0]+r[2])*2-1)*t[3],M[1]=(t[1]/(r[1]+r[3])*2-1)*t[3],M[2]=(2*t[2]-1)*t[3],M[3]=t[3],this.inverseProjectionMatrix!=null&&(sr(M,M,this.inverseProjectionMatrix),e[0]=M[0],e[1]=M[1],e[2]=M[2])}projectToScreen(t,e){return this.projectToRenderScreen(t,ss),this.renderToScreen(ss,e),e}projectToRenderScreen(t,e){if(M[0]=t[0],M[1]=t[1],M[2]=t[2],M[3]=1,sr(M,M,this.viewProjectionMatrix),M[3]===0)return null;Z(M,M,1/Math.abs(M[3]));const r=this.fullViewport;return"x"in e?(e.x=Nt(0,r[0]+r[2],.5+.5*M[0]),e.y=Nt(0,r[1]+r[3],.5+.5*M[1])):(e[0]=Nt(0,r[0]+r[2],.5+.5*M[0]),e[1]=Nt(0,r[1]+r[3],.5+.5*M[1]),e.length>2&&(e[2]=.5*(M[2]+1))),e}unprojectFromScreen(t,e){return this.unprojectFromRenderScreen(this.screenToRender(t,ss),e)}unprojectFromRenderScreen(t,e){if(jt(ri,this.projectionMatrix,this.viewMatrix),!dr(ri,ri))return null;const r=this.fullViewport;return M[0]=2*(t[0]-r[0])/r[2]-1,M[1]=2*(t[1]-r[1])/r[3]-1,M[2]=2*t[2]-1,M[3]=1,sr(M,M,ri),M[3]===0?null:(e[0]=M[0]/M[3],e[1]=M[1]/M[3],e[2]=M[2]/M[3],e)}constrainWindowSize(t,e,r,i){const s=t*this.pixelRatio,a=e*this.pixelRatio,o=Math.max(s-r/2,0),n=Math.max(this.fullHeight-a-i/2,0),l=-Math.min(s-r/2,0),c=-Math.min(this.fullHeight-a-i/2,0);return[o,n,r-l- -Math.min(this.fullWidth-s-r/2,0),i-c- -Math.min(a-i/2,0)]}computeUp(t){t===Tt.Global?this._computeUpGlobal():this._computeUpLocal()}screenToRender(t,e){const r=t[0]*this.pixelRatio,i=this.fullHeight-t[1]*this.pixelRatio;return e[0]=r,e[1]=i,e}renderToScreen(t,e){const r=t[0]/this.pixelRatio,i=(this.fullHeight-t[1])/this.pixelRatio;e[0]=r,e[1]=i}_computeUpGlobal(){ne(ge,this.center,this.eye);const t=nt(this.center);t<1?(H(this._up,0,0,1),this._markViewDirty(),this.notifyChange("_up")):Math.abs(ct(ge,this.center))>.9999*nt(ge)*t||(it(this._up,ge,this.center),it(this._up,this._up,ge),de(this._up,this._up),this.notifyChange("_up"),this._markViewDirty())}_computeUpLocal(){qn(ge,this.eye,this.center),Math.abs(ge[2])<=.9999&&(Z(ge,ge,ge[2]),H(this._up,-ge[0],-ge[1],1-ge[2]),de(this._up,this._up),this.notifyChange("_up"),this._markViewDirty())}_compareAndSetView(t,e,r=""){typeof t[0]=="number"&&isFinite(t[0])&&typeof t[1]=="number"&&isFinite(t[1])&&typeof t[2]=="number"&&isFinite(t[2])?ir(t,e)||(k(e,t),this._markViewDirty(),r.length&&this.notifyChange(r)):Zr.getLogger("esri.views.3d.webgl-engine.lib.Camera").warn("Camera vector contains invalid number, ignoring value")}_markViewDirty(){this._viewDirty=!0,this._frustumDirty=!0,this._viewProjectionDirty=!0}_recomputeFrustum(){this._frustumDirty&&(Qc(this.viewMatrix,this.projectionMatrix,this._frustum),this._frustumDirty=!1)}_ensureViewClean(){this._viewDirty&&(Ro(this._viewMatrix,this.eye,this.center,this.up),H(this._viewForward,-this._viewMatrix[2],-this._viewMatrix[6],-this._viewMatrix[10]),H(this._viewUp,this._viewMatrix[1],this._viewMatrix[5],this._viewMatrix[9]),H(this._viewRight,this._viewMatrix[0],this._viewMatrix[4],this._viewMatrix[8]),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0)}};g([L()],V.prototype,"_center",void 0),g([L()],V.prototype,"_up",void 0),g([L()],V.prototype,"_viewport",void 0),g([L()],V.prototype,"_padding",void 0),g([L()],V.prototype,"_fov",void 0),g([L()],V.prototype,"_nearFar",void 0),g([L()],V.prototype,"_pixelRatio",void 0),g([L()],V.prototype,"pixelRatio",null),g([L()],V.prototype,"eye",null),g([L()],V.prototype,"center",null),g([L()],V.prototype,"up",null),g([L({readOnly:!0})],V.prototype,"nearFar",null),g([L()],V.prototype,"near",null),g([L()],V.prototype,"far",null),g([L()],V.prototype,"viewport",null),g([L({readOnly:!0})],V.prototype,"screenViewport",null),g([L()],V.prototype,"x",null),g([L()],V.prototype,"y",null),g([L()],V.prototype,"width",null),g([L()],V.prototype,"height",null),g([L()],V.prototype,"fullWidth",null),g([L()],V.prototype,"fullHeight",null),g([L({readOnly:!0})],V.prototype,"_aspect",null),g([L()],V.prototype,"padding",null),g([L({readOnly:!0})],V.prototype,"projectionMatrix",null),g([L({readOnly:!0})],V.prototype,"inverseProjectionMatrix",null),g([L()],V.prototype,"fov",null),g([L()],V.prototype,"fovX",null),g([L()],V.prototype,"fovY",null),V=Ds=g([Fi("esri.views.3d.webgl-engine.lib.Camera")],V);const M=ke(),ri=Y(),ge=$(),is=$(),ss=Le();var G;(function(t){t[t.TOP=0]="TOP",t[t.RIGHT=1]="RIGHT",t[t.BOTTOM=2]="BOTTOM",t[t.LEFT=3]="LEFT"})(G||(G={}));class md{constructor(e,r,i,s){this._textureRepository=e,this._techniqueRepository=r,this.materialChanged=i,this.requestRender=s,this._id2glMaterialRef=new Ks}dispose(){this._textureRepository.destroy()}acquire(e,r,i){if(this._ownMaterial(e),!e.requiresSlot(r,i))return null;let s=this._id2glMaterialRef.get(i,e.id);if(N(s)){const a=e.createGLMaterial({material:e,techniqueRep:this._techniqueRepository,textureRep:this._textureRepository,output:i});s=new gd(a),this._id2glMaterialRef.set(i,e.id,s)}return s.ref(),s.glMaterial}release(e,r){const i=this._id2glMaterialRef.get(r,e.id);A(i)&&(i.unref(),i.referenced||(We(i.glMaterial),this._id2glMaterialRef.delete(r,e.id)))}_ownMaterial(e){A(e.repository)&&e.repository!==this&&Zr.getLogger("esri.views.3d.webgl-engine.lib.GLMaterialRepository").error("Material is already owned by a different material repository"),e.repository=this}}class gd{constructor(e){this.glMaterial=e,this._refCnt=0}ref(){++this._refCnt}unref(){--this._refCnt,Oe(this._refCnt>=0)}get referenced(){return this._refCnt>0}}const vd={rootOrigin:null};class _d{constructor(){this.enabled=!0,this._time=da(0)}get time(){return this._time}advance({deltaTime:e,fixedTime:r}){return A(r)?this._time!==r&&(this._time=r,!0):(this._time=da(this._time+e),e!==0)}}var Or,qr;(function(t){t[t.Draped=0]="Draped",t[t.Screen=1]="Screen",t[t.World=2]="World",t[t.COUNT=3]="COUNT"})(Or||(Or={})),function(t){t[t.Center=0]="Center",t[t.Tip=1]="Tip",t[t.COUNT=2]="COUNT"}(qr||(qr={}));class fe extends Ar{constructor(){super(...arguments),this.output=O.Color,this.transparencyPassType=ie.NONE,this.occluder=!1,this.hasSlicePlane=!1,this.writeDepth=!1,this.space=Or.Screen,this.hideOnShortSegments=!1,this.hasCap=!1,this.anchor=qr.Center,this.hasTip=!1,this.vvSize=!1,this.vvColor=!1,this.vvOpacity=!1,this.hasOccludees=!1,this.hasMultipassTerrain=!1,this.cullAboveGround=!1}}g([x({count:O.COUNT})],fe.prototype,"output",void 0),g([x({count:ie.COUNT})],fe.prototype,"transparencyPassType",void 0),g([x()],fe.prototype,"occluder",void 0),g([x()],fe.prototype,"hasSlicePlane",void 0),g([x()],fe.prototype,"writeDepth",void 0),g([x({count:Or.COUNT})],fe.prototype,"space",void 0),g([x()],fe.prototype,"hideOnShortSegments",void 0),g([x()],fe.prototype,"hasCap",void 0),g([x({count:qr.COUNT})],fe.prototype,"anchor",void 0),g([x()],fe.prototype,"hasTip",void 0),g([x()],fe.prototype,"vvSize",void 0),g([x()],fe.prototype,"vvColor",void 0),g([x()],fe.prototype,"vvOpacity",void 0),g([x()],fe.prototype,"hasOccludees",void 0),g([x()],fe.prototype,"hasMultipassTerrain",void 0),g([x()],fe.prototype,"cullAboveGround",void 0),g([x({constValue:!0})],fe.prototype,"hasVvInstancing",void 0),g([x({constValue:!0})],fe.prototype,"hasSliceTranslatedView",void 0);const ja=8;function yd(t,e){const r=t.vertex;r.uniforms.add(new B("intrinsicWidth",i=>i.width)),e.vvSize?(t.attributes.add(u.SIZEFEATUREATTRIBUTE,"float"),r.uniforms.add(new ar("vvSizeMinSize",i=>i.vvSizeMinSize)),r.uniforms.add(new ar("vvSizeMaxSize",i=>i.vvSizeMaxSize)),r.uniforms.add(new ar("vvSizeOffset",i=>i.vvSizeOffset)),r.uniforms.add(new ar("vvSizeFactor",i=>i.vvSizeFactor)),r.code.add(m`float getSize() {
return intrinsicWidth * clamp(vvSizeOffset + sizeFeatureAttribute * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).x;
}`)):(t.attributes.add(u.SIZE,"float"),r.code.add(m`float getSize(){
return intrinsicWidth * size;
}`)),e.vvOpacity?(t.attributes.add(u.OPACITYFEATUREATTRIBUTE,"float"),r.constants.add("vvOpacityNumber","int",8),r.uniforms.add([new pi("vvOpacityValues",i=>i.vvOpacityValues,ja),new pi("vvOpacityOpacities",i=>i.vvOpacityOpacities,ja)]),r.code.add(m`float interpolateOpacity( float value ){
if (value <= vvOpacityValues[0]) {
return vvOpacityOpacities[0];
}
for (int i = 1; i < vvOpacityNumber; ++i) {
if (vvOpacityValues[i] >= value) {
float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);
return mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f);
}
}
return vvOpacityOpacities[vvOpacityNumber - 1];
}
vec4 applyOpacity( vec4 color ){
return vec4(color.xyz, interpolateOpacity(opacityFeatureAttribute));
}`)):r.code.add(m`vec4 applyOpacity( vec4 color ){
return color;
}`),e.vvColor?(t.attributes.add(u.COLORFEATUREATTRIBUTE,"float"),r.constants.add("vvColorNumber","int",jr),r.uniforms.add(new pi("vvColorValues",i=>i.vvColorValues,jr)),r.uniforms.add(new $o("vvColorColors",i=>i.vvColorColors,jr)),r.code.add(m`vec4 interpolateColor( float value ) {
if (value <= vvColorValues[0]) {
return vvColorColors[0];
}
for (int i = 1; i < vvColorNumber; ++i) {
if (vvColorValues[i] >= value) {
float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);
return mix(vvColorColors[i-1], vvColorColors[i], f);
}
}
return vvColorColors[vvColorNumber - 1];
}
vec4 getColor(){
return applyOpacity(interpolateColor(colorFeatureAttribute));
}`)):(t.attributes.add(u.COLOR,"vec4"),r.code.add(m`vec4 getColor(){
return applyOpacity(color);
}`))}class Sd{constructor(e){this._rctx=e,this._cache=new Map}destroy(){this._cache.forEach(e=>We(e.stippleTexture)),this._cache.clear()}_acquire(e){if(N(e))return null;const r=this._patternId(e),i=this._cache.get(r);if(i)return i.refCount++,i;const{encodedData:s,paddedPixels:a}=xd(e),o=new wd(new or(this._rctx,{width:a,height:1,internalFormat:wr.RGBA,pixelFormat:wr.RGBA,dataType:Br.UNSIGNED_BYTE,wrapMode:xr.CLAMP_TO_EDGE},s));return this._cache.set(r,o),o}release(e){if(N(e))return;const r=this._patternId(e),i=this._cache.get(r);i&&(i.refCount--,i.refCount===0&&(A(i.stippleTexture)&&i.stippleTexture.dispose(),this._cache.delete(r)))}swap(e,r){const i=this._acquire(r);return this.release(e),i}_patternId(e){return`${e.pattern.join(",")}-r${e.pixelRatio}`}}class wd extends jc{constructor(e){super(),this.stippleTexture=e,this.refCount=1}}function xd(t){const e=ea(t),r=1/t.pixelRatio,i=nn(t),s=ln(t),a=(Math.floor(.5*(s-1))+.5)*r,o=[];let n=1;for(const h of e){for(let v=0;v<h;v++){const _=n*(Math.min(v,h-1-v)+.5)*r/a*.5+.5;o.push(_)}n=-n}const l=Math.round(e[0]/2),c=[...o.slice(l),...o.slice(0,l)],d=i+cn,f=new Uint8Array(4*d);let p=4;for(const h of c)sn(h,f,p),p+=4;return f.copyWithin(0,p-4,p),f.copyWithin(p,4,8),{encodedData:f,paddedPixels:d}}function ea(t){return t.pattern.map(e=>Math.round(e*t.pixelRatio))}function nn(t){if(N(t))return 1;const e=ea(t);return Math.floor(e.reduce((r,i)=>r+i))}function ln(t){return ea(t).reduce((e,r)=>Math.max(e,r))}const cn=2;function Od(t){return N(t)?Fs:t.length===4?t:Wr(Td,t[0],t[1],t[2],1)}const Td=ke();function dn(t,e){t.constants.add("stippleAlphaColorDiscard","float",.001),t.constants.add("stippleAlphaHighlightDiscard","float",.5),e.stippleEnabled?Cd(t,e):bd(t)}function Cd(t,e){const r=!(e.draped&&e.stipplePreferContinuous),{vertex:i,fragment:s}=t;s.include(Us),e.draped||(Vs(i,e),i.uniforms.add(new B("worldToScreenPerDistanceRatio",(o,n)=>1/n.camera.perScreenPixelRatio)),i.code.add(m`float computeWorldToScreenRatio(vec3 segmentCenter) {
float segmentDistanceToCamera = length(segmentCenter - cameraPosition);
return worldToScreenPerDistanceRatio / segmentDistanceToCamera;
}`)),t.varyings.add("vStippleDistance","float"),e.stippleRequiresClamp&&t.varyings.add("vStippleDistanceLimits","vec2"),e.stippleRequiresStretchMeasure&&t.varyings.add("vStipplePatternStretch","float"),i.code.add(m`
    float discretizeWorldToScreenRatio(float worldToScreenRatio) {
      float step = ${Rd};

      float discreteWorldToScreenRatio = log(worldToScreenRatio);
      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;
      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);
      return discreteWorldToScreenRatio;
    }
  `),i.code.add(m`vec2 computeStippleDistanceLimits(float startPseudoScreen, float segmentLengthPseudoScreen, float segmentLengthScreen, float patternLength) {`),i.code.add(m`
    if (segmentLengthPseudoScreen >= ${r?"patternLength":"1e4"}) {
  `),i.uniforms.add(new B("pixelRatio",(o,n)=>n.camera.pixelRatio)),i.code.add(m`
        // Round the screen length to get an integer number of pattern repetitions (minimum 1).
        float repetitions = segmentLengthScreen / (patternLength * pixelRatio);
        float flooredRepetitions = max(1.0, floor(repetitions + 0.5));
        float segmentLengthScreenRounded = flooredRepetitions * patternLength;

        ${e.stippleRequiresStretchMeasure?m`
              float stretch = repetitions / flooredRepetitions;

              // We need to impose a lower bound on the stretch factor to prevent the dots from merging together when there is only 1 repetition.
              // 0.75 is the lowest possible stretch value for flooredRepetitions > 1, so it makes sense as lower bound.
              vStipplePatternStretch = max(0.75, stretch);`:""}

        return vec2(0.0, segmentLengthScreenRounded);
      }
      return vec2(startPseudoScreen, startPseudoScreen + segmentLengthPseudoScreen);
    }
  `),s.constants.add("stippleTexturePadding","float",cn);const a=e.hasWebGL2Context?wi.None:wi.Size;s.uniforms.add(Io("stipplePatternTexture",o=>o.stippleTexture,a)),s.uniforms.add([new B("stipplePatternSDFNormalizer",o=>Ad(o.stipplePattern)),new B("stipplePatternPixelSizeInv",o=>1/ta(o))]),s.code.add(m`
    float padStippleTexture(float u) {
      float paddedTextureSize = ${Hl(e,"stipplePatternTexture")}.x;
      float unpaddedTextureSize = paddedTextureSize - stippleTexturePadding;

      return (u * unpaddedTextureSize + stippleTexturePadding * 0.5) / paddedTextureSize;
    }
  `),s.code.add(m`
    float getStippleSDF(out bool isClamped) {
      ${e.stippleRequiresClamp?m`
          float stippleDistanceClamped = clamp(vStippleDistance, vStippleDistanceLimits.x, vStippleDistanceLimits.y);
          vec2 aaCorrectedLimits = vStippleDistanceLimits + vec2(1.0, -1.0) / gl_FragCoord.w;
          isClamped = vStippleDistance < aaCorrectedLimits.x || vStippleDistance > aaCorrectedLimits.y;`:m`
          float stippleDistanceClamped = vStippleDistance;
          isClamped = false;`}

      float u = stippleDistanceClamped * gl_FragCoord.w * stipplePatternPixelSizeInv;
      ${e.stippleScaleWithLineWidth?m`u *= vLineSizeInv;`:""}
      u = padStippleTexture(fract(u));

      float encodedSDF = rgba2float(texture2D(stipplePatternTexture, vec2(u, 0.5)));
      float sdf = (encodedSDF * 2.0 - 1.0) * stipplePatternSDFNormalizer;

      ${e.stippleRequiresStretchMeasure?m`return (sdf - 0.5) * vStipplePatternStretch + 0.5;`:m`return sdf;`}
    }

    float getStippleSDF() {
      bool ignored;
      return getStippleSDF(ignored);
    }

    float getStippleAlpha() {
      bool isClamped;
      float stippleSDF = getStippleSDF(isClamped);

      float antiAliasedResult = ${e.stippleScaleWithLineWidth?m`clamp(stippleSDF * vLineWidth + 0.5, 0.0, 1.0);`:m`clamp(stippleSDF + 0.5, 0.0, 1.0);`}

      return isClamped ? floor(antiAliasedResult + 0.5) : antiAliasedResult;
    }
  `),e.stippleOffColorEnabled?(s.uniforms.add(new Pe("stippleOffColor",o=>Od(o.stippleOffColor))),s.code.add(m`#define discardByStippleAlpha(stippleAlpha, threshold) {}
#define blendStipple(color, stippleAlpha) mix(color, stippleOffColor, stippleAlpha)`)):s.code.add(m`#define discardByStippleAlpha(stippleAlpha, threshold) if (stippleAlpha < threshold) { discard; }
#define blendStipple(color, stippleAlpha) vec4(color.rgb, color.a * stippleAlpha)`)}function bd(t){t.fragment.code.add(m`float getStippleAlpha() { return 1.0; }
#define discardByStippleAlpha(_stippleAlpha_, _threshold_) {}
#define blendStipple(color, _stippleAlpha_) color`)}function Ad(t){return A(t)?(Math.floor(.5*(ln(t)-1))+.5)/t.pixelRatio:1}function ta(t){const e=t.stipplePattern;return A(e)?nn(t.stipplePattern)/e.pixelRatio:1}const Rd=m.float(.4),ra=128,hn=.5;function Ed(t,e=ra,r=e*hn,i=0){const s=Pd(t,e,r,i);return new Gl(s,{mipmap:!1,wrap:{s:xr.CLAMP_TO_EDGE,t:xr.CLAMP_TO_EDGE},width:e,height:e,components:4,noUnpackFlip:!0})}function Pd(t,e=ra,r=e*hn,i=0){switch(t){case"circle":default:return Dd(e,r);case"square":return $d(e,r);case"cross":return Md(e,r,i);case"x":return Ld(e,r,i);case"kite":return Id(e,r);case"triangle":return Nd(e,r);case"arrow":return Fd(e,r)}}function Dd(t,e){const r=t/2-.5;return Kr(t,fn(r,r,e/2))}function $d(t,e){return un(t,e,!1)}function Id(t,e){return un(t,e,!0)}function Md(t,e,r=0){return pn(t,e,!1,r)}function Ld(t,e,r=0){return pn(t,e,!0,r)}function Nd(t,e){return Kr(t,mn(t/2,e,e/2))}function Fd(t,e){const r=e,i=e/2,s=t/2,a=.8*r,o=fn(s,(t-e)/2-a,Math.sqrt(a*a+i*i)),n=mn(s,r,i);return Kr(t,(l,c)=>Math.max(n(l,c),-o(l,c)))}function un(t,e,r){return r&&(e/=Math.SQRT2),Kr(t,(i,s)=>{let a=i-.5*t+.25,o=.5*t-s-.75;if(r){const n=(a+o)/Math.SQRT2;o=(o-a)/Math.SQRT2,a=n}return Math.max(Math.abs(a),Math.abs(o))-.5*e})}function pn(t,e,r,i=0){e-=i,r&&(e*=Math.SQRT2);const s=.5*e;return Kr(t,(a,o)=>{let n,l=a-.5*t,c=.5*t-o-1;if(r){const d=(l+c)/Math.SQRT2;c=(c-l)/Math.SQRT2,l=d}return l=Math.abs(l),c=Math.abs(c),n=l>c?l>s?Math.sqrt((l-s)*(l-s)+c*c):c:c>s?Math.sqrt(l*l+(c-s)*(c-s)):l,n-=i/2,n})}function fn(t,e,r){return(i,s)=>{const a=i-t,o=s-e;return Math.sqrt(a*a+o*o)-r}}function mn(t,e,r){const i=Math.sqrt(e*e+r*r);return(s,a)=>{const o=Math.abs(s-t)-r,n=a-t+e/2+.75,l=(e*o+r*n)/i,c=-n;return Math.max(l,c)}}function Kr(t,e){const r=new Uint8Array(4*t*t);for(let i=0;i<t;i++)for(let s=0;s<t;s++){const a=s+t*i;let o=e(s,i);o=o/t+.5,sn(o,r,4*a)}return r}const ia=64,gn=ia/2,vn=gn/5,zd=ia/vn,lf=.25;function cf(t,e){return t.fromData(`${e}-marker`,()=>Ed(e,ia,gn,vn))}function jd(t,e){const r=t.vertex;t.constants.add("markerSizePerLineWidth","float",zd),r.uniforms.add(new B("pixelRatio",(i,s)=>s.camera.pixelRatio)),N(r.uniforms.get("markerScale"))&&r.constants.add("markerScale","float",1),r.code.add(m`float getLineWidth() {
return max(getSize(), 1.0) * pixelRatio;
}
float getScreenMarkerSize() {
return markerSizePerLineWidth * markerScale * getLineWidth();
}`),e.space===Or.World&&(r.constants.add("maxSegmentLengthFraction","float",.45),r.uniforms.add(new B("perRenderPixelRatio",(i,s)=>s.camera.perRenderPixelRatio)),r.code.add(m`float getWorldMarkerSize(vec4 pos) {
float distanceToCamera = length(pos.xyz);
float screenToWorldRatio = perRenderPixelRatio * distanceToCamera * 0.5;
return getScreenMarkerSize() * screenToWorldRatio;
}
bool areWorldMarkersHidden(vec4 pos, vec4 other) {
vec3 midPoint = mix(pos.xyz, other.xyz, 0.5);
float distanceToCamera = length(midPoint);
float screenToWorldRatio = perRenderPixelRatio * distanceToCamera * 0.5;
float worldMarkerSize = getScreenMarkerSize() * screenToWorldRatio;
float segmentLen = length(pos.xyz - other.xyz);
return worldMarkerSize > maxSegmentLengthFraction * segmentLen;
}`))}var Gt;(function(t){t[t.BUTT=0]="BUTT",t[t.SQUARE=1]="SQUARE",t[t.ROUND=2]="ROUND",t[t.COUNT=3]="COUNT"})(Gt||(Gt={}));class q extends Ar{constructor(){super(...arguments),this.output=O.Color,this.capType=Gt.BUTT,this.transparencyPassType=ie.NONE,this.occluder=!1,this.hasSlicePlane=!1,this.hasPolygonOffset=!1,this.writeDepth=!1,this.draped=!1,this.stippleEnabled=!1,this.stippleOffColorEnabled=!1,this.stippleScaleWithLineWidth=!1,this.stipplePreferContinuous=!0,this.roundJoins=!1,this.applyMarkerOffset=!1,this.vvSize=!1,this.vvColor=!1,this.vvOpacity=!1,this.falloffEnabled=!1,this.innerColorEnabled=!1,this.hasOccludees=!1,this.hasMultipassTerrain=!1,this.cullAboveGround=!1,this.wireframe=!1,this.objectAndLayerIdColorInstanced=!1}}g([x({count:O.COUNT})],q.prototype,"output",void 0),g([x({count:Gt.COUNT})],q.prototype,"capType",void 0),g([x({count:ie.COUNT})],q.prototype,"transparencyPassType",void 0),g([x()],q.prototype,"occluder",void 0),g([x()],q.prototype,"hasSlicePlane",void 0),g([x()],q.prototype,"hasPolygonOffset",void 0),g([x()],q.prototype,"writeDepth",void 0),g([x()],q.prototype,"draped",void 0),g([x()],q.prototype,"stippleEnabled",void 0),g([x()],q.prototype,"stippleOffColorEnabled",void 0),g([x()],q.prototype,"stippleScaleWithLineWidth",void 0),g([x()],q.prototype,"stipplePreferContinuous",void 0),g([x()],q.prototype,"roundJoins",void 0),g([x()],q.prototype,"applyMarkerOffset",void 0),g([x()],q.prototype,"vvSize",void 0),g([x()],q.prototype,"vvColor",void 0),g([x()],q.prototype,"vvOpacity",void 0),g([x()],q.prototype,"falloffEnabled",void 0),g([x()],q.prototype,"innerColorEnabled",void 0),g([x()],q.prototype,"hasOccludees",void 0),g([x()],q.prototype,"hasMultipassTerrain",void 0),g([x()],q.prototype,"cullAboveGround",void 0),g([x()],q.prototype,"wireframe",void 0),g([x({constValue:!0})],q.prototype,"stippleRequiresClamp",void 0),g([x({constValue:!0})],q.prototype,"stippleRequiresStretchMeasure",void 0),g([x({constValue:!0})],q.prototype,"hasVvInstancing",void 0),g([x({constValue:!0})],q.prototype,"hasSliceTranslatedView",void 0),g([x()],q.prototype,"objectAndLayerIdColorInstanced",void 0);const Ei=1;function Ud(t){const e=new Yr,{vertex:r,fragment:i}=e,s=t.hasMultipassTerrain&&(t.output===O.Color||t.output===O.Alpha);e.include(Wl),e.include(yd,t),e.include(dn,t);const a=t.applyMarkerOffset&&!t.draped;a&&(r.uniforms.add(new B("markerScale",h=>h.markerScale)),e.include(jd,{space:Or.World})),t.output===O.Depth&&e.include(Mo,t),e.include(Hs,t),Jr(r,t),r.uniforms.add([new yr("inverseProjectionMatrix",(h,v)=>v.camera.inverseProjectionMatrix),new wt("nearFar",(h,v)=>v.camera.nearFar),new B("miterLimit",h=>h.join!=="miter"?0:h.miterLimit),new Pe("viewport",(h,v)=>v.camera.fullViewport)]),r.constants.add("LARGE_HALF_FLOAT","float",65500),e.attributes.add(u.POSITION,"vec3"),e.attributes.add(u.SUBDIVISIONFACTOR,"float"),e.attributes.add(u.UV0,"vec2"),e.attributes.add(u.AUXPOS1,"vec3"),e.attributes.add(u.AUXPOS2,"vec3"),e.varyings.add("vColor","vec4"),e.varyings.add("vpos","vec3"),Lo(e),s&&e.varyings.add("depth","float");const o=t.capType===Gt.ROUND,n=t.stippleEnabled&&t.stippleScaleWithLineWidth||o;n&&e.varyings.add("vLineWidth","float");const l=t.stippleEnabled&&t.stippleScaleWithLineWidth;l&&e.varyings.add("vLineSizeInv","float");const c=t.innerColorEnabled||o;c&&e.varyings.add("vLineDistance","float");const d=t.stippleEnabled&&o,f=t.falloffEnabled||d;f&&e.varyings.add("vLineDistanceNorm","float"),o&&(e.varyings.add("vSegmentSDF","float"),e.varyings.add("vReverseSegmentSDF","float")),r.code.add(m`#define PERPENDICULAR(v) vec2(v.y, -v.x);
float interp(float ncp, vec4 a, vec4 b) {
return (-ncp - a.z) / (b.z - a.z);
}
vec2 rotate(vec2 v, float a) {
float s = sin(a);
float c = cos(a);
mat2 m = mat2(c, -s, s, c);
return m * v;
}`),r.code.add(m`vec4 projectAndScale(vec4 pos) {
vec4 posNdc = proj * pos;
posNdc.xy *= viewport.zw / posNdc.w;
return posNdc;
}`),Bl(e),r.code.add(m`
    void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {
      float vnp = nearFar[0] * 0.99;

      if(pos.z > -nearFar[0]) {
        //current pos behind ncp --> we need to clip
        if (!isStartVertex) {
          if(prev.z < -nearFar[0]) {
            //previous in front of ncp
            pos = mix(prev, pos, interp(vnp, prev, pos));
            next = pos;
          } else {
            pos = vec4(0.0, 0.0, 0.0, 1.0);
          }
        } else {
          if(next.z < -nearFar[0]) {
            //next in front of ncp
            pos = mix(pos, next, interp(vnp, pos, next));
            prev = pos;
          } else {
            pos = vec4(0.0, 0.0, 0.0, 1.0);
          }
        }
      } else {
        //current position visible
        if (prev.z > -nearFar[0]) {
          //previous behind ncp
          prev = mix(pos, prev, interp(vnp, pos, prev));
        }
        if (next.z > -nearFar[0]) {
          //next behind ncp
          next = mix(next, pos, interp(vnp, next, pos));
        }
      }

      ${s?"depth = pos.z;":""}
      linearDepth = calculateLinearDepth(nearFar,pos.z);

      pos = projectAndScale(pos);
      next = projectAndScale(next);
      prev = projectAndScale(prev);
    }
  `),r.uniforms.add(new B("pixelRatio",(h,v)=>v.camera.pixelRatio)),r.code.add(m`
  void main(void) {
    // unpack values from uv0.y
    bool isStartVertex = abs(abs(uv0.y)-3.0) == 1.0;

    float coverage = 1.0;

    // Check for special value of uv0.y which is used by the Renderer when graphics
    // are removed before the VBO is recompacted. If this is the case, then we just
    // project outside of clip space.
    if (uv0.y == 0.0) {
      // Project out of clip space
      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
    }
    else {
      bool isJoin = abs(uv0.y) < 3.0;

      float lineSize = getSize();
      float lineWidth = lineSize * pixelRatio;

      ${n?m`vLineWidth = lineWidth;`:""}
      ${l?m`vLineSizeInv = 1.0 / lineSize;`:""}

      // convert sub-pixel coverage to alpha
      if (lineWidth < 1.0) {
        coverage = lineWidth;
        lineWidth = 1.0;
      }else{
        // Ribbon lines cannot properly render non-integer sizes. Round width to integer size if
        // larger than one for better quality. Note that we do render < 1 pixels more or less correctly
        // so we only really care to round anything larger than 1.
        lineWidth = floor(lineWidth + 0.5);
      }

      vec4 pos  = view * vec4(position.xyz, 1.0);
      vec4 prev = view * vec4(auxpos1.xyz, 1.0);
      vec4 next = view * vec4(auxpos2.xyz, 1.0);
  `),a&&r.code.add(m`vec4 other = isStartVertex ? next : prev;
bool markersHidden = areWorldMarkersHidden(pos, other);
if(!isJoin && !markersHidden) {
pos.xyz += normalize(other.xyz - pos.xyz) * getWorldMarkerSize(pos) * 0.5;
}`),r.code.add(m`clipAndTransform(pos, prev, next, isStartVertex);
vec2 left = (pos.xy - prev.xy);
vec2 right = (next.xy - pos.xy);
float leftLen = length(left);
float rightLen = length(right);`),(t.stippleEnabled||o)&&r.code.add(m`
      float isEndVertex = float(!isStartVertex);
      vec2 segmentOrigin = mix(pos.xy, prev.xy, isEndVertex);
      vec2 segment = mix(right, left, isEndVertex);
      ${o?m`vec2 segmentEnd = mix(next.xy, pos.xy, isEndVertex);`:""}
    `),r.code.add(m`left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);
right = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);
vec2 capDisplacementDir = vec2(0, 0);
vec2 joinDisplacementDir = vec2(0, 0);
float displacementLen = lineWidth;
if (isJoin) {
bool isOutside = (left.x * right.y - left.y * right.x) * uv0.y > 0.0;
joinDisplacementDir = normalize(left + right);
joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);
if (leftLen > 0.001 && rightLen > 0.001) {
float nDotSeg = dot(joinDisplacementDir, left);
displacementLen /= length(nDotSeg * left - joinDisplacementDir);
if (!isOutside) {
displacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));
}
}
if (isOutside && (displacementLen > miterLimit * lineWidth)) {`),t.roundJoins?r.code.add(m`
        vec2 startDir = leftLen < 0.001 ? right : left;
        startDir = PERPENDICULAR(startDir);

        vec2 endDir = rightLen < 0.001 ? left : right;
        endDir = PERPENDICULAR(endDir);

        float factor = ${t.stippleEnabled?m`min(1.0, subdivisionFactor * ${m.float((Ei+2)/(Ei+1))})`:m`subdivisionFactor`};

        float rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));
        joinDisplacementDir = rotate(startDir, -sign(uv0.y) * factor * rotationAngle);
      `):r.code.add(m`if (leftLen < 0.001) {
joinDisplacementDir = right;
}
else if (rightLen < 0.001) {
joinDisplacementDir = left;
}
else {
joinDisplacementDir = (isStartVertex || subdivisionFactor > 0.0) ? right : left;
}
joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);`);const p=t.capType!==Gt.BUTT;return r.code.add(m`
        displacementLen = lineWidth;
      }
    } else {
      // CAP handling ---------------------------------------------------
      joinDisplacementDir = isStartVertex ? right : left;
      joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);

      ${p?m`capDisplacementDir = isStartVertex ? -right : left;`:""}
    }
  `),r.code.add(m`
    // Displacement (in pixels) caused by join/or cap
    vec2 dpos = joinDisplacementDir * sign(uv0.y) * displacementLen + capDisplacementDir * displacementLen;

    ${f||c?m`float lineDistNorm = sign(uv0.y) * pos.w;`:""}

    ${c?m`vLineDistance = lineWidth * lineDistNorm;`:""}
    ${f?m`vLineDistanceNorm = lineDistNorm;`:""}

    pos.xy += dpos;
  `),o&&r.code.add(m`vec2 segmentDir = normalize(segment);
vSegmentSDF = (isJoin && isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentOrigin, segmentDir) * pos.w) ;
vReverseSegmentSDF = (isJoin && !isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentEnd, -segmentDir) * pos.w);`),t.stippleEnabled&&(t.draped?r.uniforms.add(new B("worldToScreenRatio",(h,v)=>1/v.screenToPCSRatio)):r.code.add(m`vec3 segmentCenter = mix((auxpos2 + position) * 0.5, (position + auxpos1) * 0.5, isEndVertex);
float worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`),r.code.add(m`float segmentLengthScreenDouble = length(segment);
float segmentLengthScreen = segmentLengthScreenDouble * 0.5;
float discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);
float segmentLengthRender = length(mix(auxpos2 - position, position - auxpos1, isEndVertex));
vStipplePatternStretch = worldToScreenRatio / discreteWorldToScreenRatio;`),t.draped?r.code.add(m`float segmentLengthPseudoScreen = segmentLengthScreen / pixelRatio * discreteWorldToScreenRatio / worldToScreenRatio;
float startPseudoScreen = uv0.x * discreteWorldToScreenRatio - mix(0.0, segmentLengthPseudoScreen, isEndVertex);`):r.code.add(m`float startPseudoScreen = mix(uv0.x, uv0.x - segmentLengthRender, isEndVertex) * discreteWorldToScreenRatio;
float segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`),r.uniforms.add(new B("stipplePatternPixelSize",h=>ta(h))),r.code.add(m`
      float patternLength = ${t.stippleScaleWithLineWidth?"lineSize * ":""} stipplePatternPixelSize;

      // Compute the coordinates at both start and end of the line segment, because we need both to clamp to in the fragment shader
      vStippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, segmentLengthScreen, patternLength);

      vStippleDistance = mix(vStippleDistanceLimits.x, vStippleDistanceLimits.y, isEndVertex);

      // Adjust the coordinate to the displaced position (the pattern is shortened/overextended on the in/outside of joins)
      if (segmentLengthScreenDouble >= 0.001) {
        // Project the actual vertex position onto the line segment. Note that the resulting factor is within [0..1] at the
        // original vertex positions, and slightly outside of that range at the displaced positions
        vec2 stippleDisplacement = pos.xy - segmentOrigin;
        float stippleDisplacementFactor = dot(segment, stippleDisplacement) / (segmentLengthScreenDouble * segmentLengthScreenDouble);

        // Apply this offset to the actual vertex coordinate (can be screen or pseudo-screen space)
        vStippleDistance += (stippleDisplacementFactor - isEndVertex) * (vStippleDistanceLimits.y - vStippleDistanceLimits.x);
      }

      // Cancel out perspective correct interpolation because we want this length the really represent the screen distance
      vStippleDistanceLimits *= pos.w;
      vStippleDistance *= pos.w;

      // Disable stipple distance limits on caps
      vStippleDistanceLimits = isJoin ?
                                 vStippleDistanceLimits :
                                 isStartVertex ?
                                  vec2(-1e038, vStippleDistanceLimits.y) :
                                  vec2(vStippleDistanceLimits.x, 1e038);
    `)),r.code.add(m`
      // Convert back into NDC
      pos.xy = (pos.xy / viewport.zw) * pos.w;

      vColor = getColor();
      vColor.a *= coverage;

      ${t.wireframe&&!t.draped?"pos.z -= 0.001 * pos.w;":""}

      // transform final position to camera space for slicing
      vpos = (inverseProjectionMatrix * pos).xyz;
      gl_Position = pos;
      forwardObjectAndLayerIdColor();
    }
  }
  `),s&&e.include(Gs,t),e.include(vt,t),i.include(Ui),i.code.add(m`
  void main() {
    discardBySlice(vpos);
    ${s?"terrainDepthTest(gl_FragCoord, depth);":""}
  `),t.wireframe?i.code.add(m`vec4 finalColor = vec4(1.0, 0.0, 1.0, 1.0);`):(o&&i.code.add(m`
      float sdf = min(vSegmentSDF, vReverseSegmentSDF);
      vec2 fragmentPosition = vec2(
        min(sdf, 0.0),
        vLineDistance
      ) * gl_FragCoord.w;

      float fragmentRadius = length(fragmentPosition);
      float fragmentCapSDF = (fragmentRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale
      float capCoverage = clamp(0.5 - fragmentCapSDF, 0.0, 1.0);

      if (capCoverage < ${m.float(Ue)}) {
        discard;
      }
    `),d?i.code.add(m`
      vec2 stipplePosition = vec2(
        min(getStippleSDF() * 2.0 - 1.0, 0.0),
        vLineDistanceNorm * gl_FragCoord.w
      );
      float stippleRadius = length(stipplePosition * vLineWidth);
      float stippleCapSDF = (stippleRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale
      float stippleCoverage = clamp(0.5 - stippleCapSDF, 0.0, 1.0);
      float stippleAlpha = step(${m.float(Ue)}, stippleCoverage);
      `):i.code.add(m`float stippleAlpha = getStippleAlpha();`),i.uniforms.add(new Pe("intrinsicColor",h=>h.color)),t.output!==O.ObjectAndLayerIdColor&&i.code.add(m`discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);`),i.code.add(m`vec4 color = intrinsicColor * vColor;`),t.innerColorEnabled&&(i.uniforms.add(new Pe("innerColor",h=>ae(h.innerColor,h.color))),i.uniforms.add(new B("innerWidth",(h,v)=>h.innerWidth*v.camera.pixelRatio)),i.code.add(m`float distToInner = abs(vLineDistance * gl_FragCoord.w) - innerWidth;
float innerAA = clamp(0.5 - distToInner, 0.0, 1.0);
float innerAlpha = innerColor.a + color.a * (1.0 - innerColor.a);
color = mix(color, vec4(innerColor.rgb, innerAlpha), innerAA);`)),i.code.add(m`vec4 finalColor = blendStipple(color, stippleAlpha);`),t.falloffEnabled&&(i.uniforms.add(new B("falloff",h=>h.falloff)),i.code.add(m`finalColor.a *= pow(max(0.0, 1.0 - abs(vLineDistanceNorm * gl_FragCoord.w)), falloff);`))),i.code.add(m`
    ${t.output===O.ObjectAndLayerIdColor?m`finalColor.a = 1.0;`:""}

    if (finalColor.a < ${m.float(Ue)}) {
      discard;
    }

    ${t.output===O.Alpha?m`gl_FragColor = vec4(finalColor.a);`:""}
    ${t.output===O.Color?m`gl_FragColor = highlightSlice(finalColor, vpos);`:""}
    ${t.output===O.Color&&t.transparencyPassType===ie.Color?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}
    ${t.output===O.Highlight?m`gl_FragColor = vec4(1.0);`:""}
    ${t.output===O.Depth?m`outputDepth(linearDepth);`:""}
    ${t.output===O.ObjectAndLayerIdColor?m`outputObjectAndLayerIdColor();`:""}
  }
  `),e}const Vd=Object.freeze(Object.defineProperty({__proto__:null,RIBBONLINE_NUM_ROUND_JOIN_SUBDIVISIONS:Ei,build:Ud},Symbol.toStringTag,{value:"Module"})),_n=new Map([[u.POSITION,0],[u.SUBDIVISIONFACTOR,1],[u.UV0,2],[u.AUXPOS1,3],[u.AUXPOS2,4],[u.COLOR,5],[u.COLORFEATUREATTRIBUTE,5],[u.SIZE,6],[u.SIZEFEATUREATTRIBUTE,6],[u.OPACITYFEATUREATTRIBUTE,7],[u.OBJECTANDLAYERIDCOLOR,8]]);class ki extends Rr{initializeProgram(e){return new Er(e.rctx,ki.shader.get().build(this.configuration),_n)}_makePipelineState(e,r){const i=this.configuration,s=e===ie.NONE,a=e===ie.FrontFace;return et({blending:i.output===O.Color||i.output===O.Alpha?s?Ur:Wi(e):null,depthTest:{func:Js(e)},depthWrite:s?i.writeDepth?Sr:null:ko(e),colorWrite:lt,stencilWrite:i.hasOccludees?xi:null,stencilTest:i.hasOccludees?r?Oi:Ws:null,polygonOffset:s||a?i.hasPolygonOffset?Ua:null:Uc})}initializePipeline(){const e=this.configuration;if(e.occluder){const r=e.hasPolygonOffset?Ua:null;this._occluderPipelineTransparent=et({blending:Ur,polygonOffset:r,depthTest:wa,depthWrite:null,colorWrite:lt,stencilWrite:null,stencilTest:kl}),this._occluderPipelineOpaque=et({blending:Ur,polygonOffset:r,depthTest:wa,depthWrite:null,colorWrite:lt,stencilWrite:ql,stencilTest:Xl}),this._occluderPipelineMaskWrite=et({blending:null,polygonOffset:r,depthTest:No,depthWrite:null,colorWrite:null,stencilWrite:xi,stencilTest:Oi})}return this._occludeePipelineState=this._makePipelineState(this.configuration.transparencyPassType,!0),this._makePipelineState(this.configuration.transparencyPassType,!1)}get primitiveType(){return this.configuration.wireframe?Ht.LINES:Ht.TRIANGLE_STRIP}getPipelineState(e,r){return r?this._occludeePipelineState:this.configuration.occluder?e===W.TRANSPARENT_OCCLUDER_MATERIAL?this._occluderPipelineTransparent:e===W.OCCLUDER_MATERIAL?this._occluderPipelineOpaque:this._occluderPipelineMaskWrite:super.getPipelineState(e,r)}}ki.shader=new Pr(Vd,()=>Cr(()=>import("./RibbonLine.glsl.a61dc304.js"),["assets/RibbonLine.glsl.a61dc304.js","assets/VertexColor.glsl.e3d82815.js","assets/index.3255d2a5.js","assets/index.e51050de.css","assets/requestImageUtils.828b299e.js","assets/OrderIndependentTransparency.43c6e481.js","assets/enums.3c1fa5b5.js","assets/basicInterfaces.f8f3b23b.js","assets/Texture.d66dc1cb.js","assets/VertexArrayObject.ad007c8f.js","assets/Util.3efb1a6b.js","assets/mat4f64.9070f685.js","assets/triangle.1c8f4155.js","assets/sphere.67ec4acb.js","assets/mat3f64.9180efcb.js","assets/quatf64.1dc83f1c.js","assets/lineSegment.1a0fd96e.js","assets/Indices.27b9c798.js","assets/VertexAttribute.34e3daf1.js","assets/doublePrecisionUtils.d6c628ce.js","assets/quat.eb7bbc3a.js","assets/vec3f32.4d8dc001.js","assets/BufferView.32a50625.js","assets/VertexElementDescriptor.5da9dfe9.js","assets/floatRGBA.7b501bd7.js","assets/plane.a0a08b54.js","assets/Attribute.98e6fe67.js","assets/triangulationUtils.2ec0b7a6.js","assets/earcut.a219bf29.js","assets/deduplicate.97d7ef01.js","assets/hydratedFeatures.b4cbc12d.js","assets/InterleavedLayout.a42ad5fa.js","assets/types.bf551170.js","assets/NestedMap.2ac03b78.js","assets/Octree.449e609a.js","assets/boundedPlane.91a64206.js","assets/glUtil.9de5d1d0.js"]));const Ua={factor:0,units:-4};var Ee;(function(t){t[t.LEFT_JOIN_START=-2]="LEFT_JOIN_START",t[t.LEFT_JOIN_END=-1]="LEFT_JOIN_END",t[t.LEFT_CAP_START=-4]="LEFT_CAP_START",t[t.LEFT_CAP_END=-5]="LEFT_CAP_END",t[t.RIGHT_JOIN_START=2]="RIGHT_JOIN_START",t[t.RIGHT_JOIN_END=1]="RIGHT_JOIN_END",t[t.RIGHT_CAP_START=4]="RIGHT_CAP_START",t[t.RIGHT_CAP_END=5]="RIGHT_CAP_END"})(Ee||(Ee={}));class Hd extends Vi{constructor(e){super(e,new Wd),this._configuration=new q,this._vertexAttributeLocations=_n,this._layout=this.createLayout()}isClosed(e,r){return Sn(this.parameters,e,r)}getConfiguration(e,r){this._configuration.output=e,this._configuration.draped=r.slot===W.DRAPED_MATERIAL;const i=A(this.parameters.stipplePattern)&&e!==O.Highlight;return this._configuration.stippleEnabled=i,this._configuration.stippleOffColorEnabled=i&&A(this.parameters.stippleOffColor),this._configuration.stippleScaleWithLineWidth=i&&this.parameters.stippleScaleWithLineWidth,this._configuration.stipplePreferContinuous=i&&this.parameters.stipplePreferContinuous,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration.roundJoins=this.parameters.join==="round",this._configuration.capType=this.parameters.cap,this._configuration.applyMarkerOffset=!!A(this.parameters.markerParameters)&&kd(this.parameters.markerParameters),this._configuration.hasPolygonOffset=this.parameters.hasPolygonOffset,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.vvColor=this.parameters.vvColorEnabled,this._configuration.vvOpacity=this.parameters.vvOpacityEnabled,this._configuration.vvSize=this.parameters.vvSizeEnabled,this._configuration.innerColorEnabled=this.parameters.innerWidth>0&&A(this.parameters.innerColor),this._configuration.falloffEnabled=this.parameters.falloff>0,this._configuration.occluder=this.parameters.renderOccluded===xt.OccludeAndTransparentStencil,this._configuration.transparencyPassType=r.transparencyPassType,this._configuration.hasMultipassTerrain=r.multipassTerrain.enabled,this._configuration.cullAboveGround=r.multipassTerrain.cullAboveGround,this._configuration.wireframe=this.parameters.wireframe,this._configuration}intersectDraped(e,r,i,s,a,o){if(!i.options.selectionMode)return;const n=e.vertexAttributes.get(u.POSITION).data,l=e.vertexAttributes.get(u.SIZE);let c=this.parameters.width;if(this.parameters.vvSizeEnabled){const _=e.vertexAttributes.get(u.SIZEFEATUREATTRIBUTE).data[0];c*=zt(this.parameters.vvSizeOffset[0]+_*this.parameters.vvSizeFactor[0],this.parameters.vvSizeMinSize[0],this.parameters.vvSizeMaxSize[0])}else l&&(c*=l.data[0]);const d=s[0],f=s[1],p=(c/2+4)*e.screenToWorldRatio;let h=Number.MAX_VALUE,v=0;for(let _=0;_<n.length-5;_+=3){const S=n[_],T=n[_+1],w=d-S,y=f-T,R=n[_+3]-S,C=n[_+4]-T,b=zt((R*w+C*y)/(R*R+C*C),0,1),F=R*b-w,E=C*b-y,U=F*F+E*E;U<h&&(h=U,v=_/3)}h<p*p&&a(o.dist,o.normal,v,!1)}intersect(e,r,i,s,a,o){if(!i.options.selectionMode||!e.visible)return;if(!Wo(r))return void Zr.getLogger("esri.views.3d.webgl-engine.materials.RibbonLineMaterial").error("intersection assumes a translation-only matrix");const n=e.vertexAttributes,l=n.get(u.POSITION).data;let c=this.parameters.width;if(this.parameters.vvSizeEnabled){const w=n.get(u.SIZEFEATUREATTRIBUTE).data[0];c*=zt(this.parameters.vvSizeOffset[0]+w*this.parameters.vvSizeFactor[0],this.parameters.vvSizeMinSize[0],this.parameters.vvSizeMaxSize[0])}else n.has(u.SIZE)&&(c*=n.get(u.SIZE).data[0]);const d=i.camera,f=qd;Tr(f,i.point);const p=c*d.pixelRatio/2+4*d.pixelRatio;H(Ir[0],f[0]-p,f[1]+p,0),H(Ir[1],f[0]+p,f[1]+p,0),H(Ir[2],f[0]+p,f[1]-p,0),H(Ir[3],f[0]-p,f[1]-p,0);for(let w=0;w<4;w++)if(!d.unprojectFromRenderScreen(Ir[w],st[w]))return;gt(d.eye,st[0],st[1],os),gt(d.eye,st[1],st[2],ns),gt(d.eye,st[2],st[3],ls),gt(d.eye,st[3],st[0],cs);let h=Number.MAX_VALUE,v=0;const _=yn(this.parameters,n,e.indices)?l.length-2:l.length-5;for(let w=0;w<_;w+=3){Te[0]=l[w]+r[12],Te[1]=l[w+1]+r[13],Te[2]=l[w+2]+r[14];const y=(w+3)%l.length;if(Ce[0]=l[y]+r[12],Ce[1]=l[y+1]+r[13],Ce[2]=l[y+2]+r[14],ce(os,Te)<0&&ce(os,Ce)<0||ce(ns,Te)<0&&ce(ns,Ce)<0||ce(ls,Te)<0&&ce(ls,Ce)<0||ce(cs,Te)<0&&ce(cs,Ce)<0)continue;if(d.projectToRenderScreen(Te,Pt),d.projectToRenderScreen(Ce,Dt),Pt[2]<0&&Dt[2]>0){ne(Ze,Te,Ce);const C=d.frustum,b=-ce(C[_t.NEAR],Te)/ct(Ze,Si(C[_t.NEAR]));Z(Ze,Ze,b),re(Te,Te,Ze),d.projectToRenderScreen(Te,Pt)}else if(Pt[2]>0&&Dt[2]<0){ne(Ze,Ce,Te);const C=d.frustum,b=-ce(C[_t.NEAR],Ce)/ct(Ze,Si(C[_t.NEAR]));Z(Ze,Ze,b),re(Ce,Ce,Ze),d.projectToRenderScreen(Ce,Dt)}else if(Pt[2]<0&&Dt[2]<0)continue;Pt[2]=0,Dt[2]=0;const R=tn(hr(Pt,Dt,Ga),f);R<h&&(h=R,k(Va,Te),k(Ha,Ce),v=w/3)}const S=i.rayBegin,T=i.rayEnd;if(h<p*p){let w=Number.MAX_VALUE;if(rn(hr(Va,Ha,Ga),hr(S,T,Xd),Et)){ne(Et,Et,S);const y=nt(Et);Z(Et,Et,1/y),w=y/Ot(S,T)}o(w,Et,v,!1)}}createLayout(){const e=bt().vec3f(u.POSITION).f32(u.SUBDIVISIONFACTOR).vec2f(u.UV0).vec3f(u.AUXPOS1).vec3f(u.AUXPOS2);return this.parameters.vvSizeEnabled?e.f32(u.SIZEFEATUREATTRIBUTE):e.f32(u.SIZE),this.parameters.vvColorEnabled?e.f32(u.COLORFEATUREATTRIBUTE):e.vec4f(u.COLOR),this.parameters.vvOpacityEnabled&&e.f32(u.OPACITYFEATUREATTRIBUTE),St("enable-feature:objectAndLayerId-rendering")&&e.vec4u8(u.OBJECTANDLAYERIDCOLOR),e}createBufferWriter(){return new Bd(this._layout,this.parameters)}requiresSlot(e,r){return r===O.Color||r===O.Alpha||r===O.Highlight||r===O.Depth||r===O.ObjectAndLayerIdColor?e===W.DRAPED_MATERIAL?!0:this.parameters.renderOccluded===xt.OccludeAndTransparentStencil?e===W.OPAQUE_MATERIAL||e===W.OCCLUDER_MATERIAL||e===W.TRANSPARENT_OCCLUDER_MATERIAL:r===O.Color||r===O.Alpha?e===(this.parameters.writeDepth?W.TRANSPARENT_MATERIAL:W.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL):e===W.OPAQUE_MATERIAL:!1}createGLMaterial(e){return new Gd(e)}validateParameters(e){e.join!=="miter"&&(e.miterLimit=0),A(e.markerParameters)&&(e.markerScale=e.markerParameters.width/e.width)}}class Gd extends Hi{constructor(){super(...arguments),this._stipplePattern=null}dispose(){super.dispose(),this._stippleTextureRepository.release(this._stipplePattern),this._stipplePattern=null}_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:e.hasOccludees})}beginSlot(e){this._output!==O.Color&&this._output!==O.Alpha||this._updateOccludeeState(e);const r=this._material.parameters.stipplePattern;return this._stipplePattern!==r&&(this._material.setParameters(this._stippleTextureRepository.swap(this._stipplePattern,r)),this._stipplePattern=r),this.ensureTechnique(ki,e)}}class Wd extends Zl{constructor(){super(...arguments),this.width=0,this.color=zi,this.join="miter",this.cap=Gt.BUTT,this.miterLimit=5,this.writeDepth=!0,this.hasPolygonOffset=!1,this.stippleTexture=null,this.stippleScaleWithLineWidth=!1,this.stipplePreferContinuous=!0,this.markerParameters=null,this.markerScale=1,this.hasSlicePlane=!1,this.vvFastUpdate=!1,this.isClosed=!1,this.falloff=0,this.innerWidth=0,this.hasOccludees=!1,this.wireframe=!1}}class Bd{constructor(e,r){this._parameters=r,this.numJoinSubdivisions=0,this.vertexBufferLayout=e;const i=r.stipplePattern?1:0;switch(this._parameters.join){case"miter":case"bevel":this.numJoinSubdivisions=i;break;case"round":this.numJoinSubdivisions=Ei+i}}_isClosed(e){return yn(this._parameters,e.vertexAttributes,e.indices)}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){const i=e.indices.get(u.POSITION).length/2+1,s=this._isClosed(e);let a=s?2:2*2;return a+=((s?i:i-1)-(s?0:1))*(2*this.numJoinSubdivisions+4),a+=2,this._parameters.wireframe&&(a=2+4*(a-2)),a}write(e,r,i,s,a){var Bt;const o=Zd,n=Yd,l=Jd,c=i.vertexAttributes.get(u.POSITION).data,d=i.indices&&i.indices.get(u.POSITION),f=(Bt=i.vertexAttributes.get(u.DISTANCETOSTART))==null?void 0:Bt.data;d&&d.length!==2*(c.length/3-1)&&console.warn("RibbonLineMaterial does not support indices");let p=1,h=0;this._parameters.vvSizeEnabled?h=i.vertexAttributes.get(u.SIZEFEATUREATTRIBUTE).data[0]:i.vertexAttributes.has(u.SIZE)&&(p=i.vertexAttributes.get(u.SIZE).data[0]);let v=[1,1,1,1],_=0;this._parameters.vvColorEnabled?_=i.vertexAttributes.get(u.COLORFEATUREATTRIBUTE).data[0]:i.vertexAttributes.has(u.COLOR)&&(v=i.vertexAttributes.get(u.COLOR).data);const S=St("enable-feature:objectAndLayerId-rendering")?i.objectAndLayerIdColor:null;let T=0;this._parameters.vvOpacityEnabled&&(T=i.vertexAttributes.get(u.OPACITYFEATUREATTRIBUTE).data[0]);const w=c.length/3,y=new Float32Array(s.buffer),R=St("enable-feature:objectAndLayerId-rendering")?new Uint8Array(s.buffer):null,C=this.vertexBufferLayout.stride/4;let b=a*C;const F=b;let E=0;const U=f?(J,Fe,He)=>E=f[He]:(J,Fe,He)=>E+=Ot(J,Fe),pe=St("enable-feature:objectAndLayerId-rendering"),D=(J,Fe,He,I,At,Xe,Dr)=>{if(y[b++]=Fe[0],y[b++]=Fe[1],y[b++]=Fe[2],y[b++]=I,y[b++]=Dr,y[b++]=At,y[b++]=J[0],y[b++]=J[1],y[b++]=J[2],y[b++]=He[0],y[b++]=He[1],y[b++]=He[2],this._parameters.vvSizeEnabled?y[b++]=h:y[b++]=p,this._parameters.vvColorEnabled)y[b++]=_;else{const ht=Math.min(4*Xe,v.length-4);y[b++]=v[ht],y[b++]=v[ht+1],y[b++]=v[ht+2],y[b++]=v[ht+3]}this._parameters.vvOpacityEnabled&&(y[b++]=T),pe&&(A(S)&&(R[4*b]=S[0],R[4*b+1]=S[1],R[4*b+2]=S[2],R[4*b+3]=S[3]),b++)};b+=C,H(n,c[0],c[1],c[2]),e&&se(n,n,e);const X=this._isClosed(i);if(X){const J=c.length-3;H(o,c[J],c[J+1],c[J+2]),e&&se(o,o,e)}else H(l,c[3],c[4],c[5]),e&&se(l,l,e),D(n,n,l,1,Ee.LEFT_CAP_START,0,0),D(n,n,l,1,Ee.RIGHT_CAP_START,0,0),k(o,n),k(n,l);const me=X?0:1,qe=X?w:w-1;for(let J=me;J<qe;J++){const Fe=(J+1)%w*3;H(l,c[Fe],c[Fe+1],c[Fe+2]),e&&se(l,l,e),U(o,n,J),D(o,n,l,0,Ee.LEFT_JOIN_END,J,E),D(o,n,l,0,Ee.RIGHT_JOIN_END,J,E);const He=this.numJoinSubdivisions;for(let I=0;I<He;++I){const At=(I+1)/(He+1);D(o,n,l,At,Ee.LEFT_JOIN_END,J,E),D(o,n,l,At,Ee.RIGHT_JOIN_END,J,E)}D(o,n,l,1,Ee.LEFT_JOIN_START,J,E),D(o,n,l,1,Ee.RIGHT_JOIN_START,J,E),k(o,n),k(n,l)}X?(H(l,c[3],c[4],c[5]),e&&se(l,l,e),E=U(o,n,qe),D(o,n,l,0,Ee.LEFT_JOIN_END,me,E),D(o,n,l,0,Ee.RIGHT_JOIN_END,me,E)):(E=U(o,n,qe),D(o,n,n,0,Ee.LEFT_CAP_END,qe,E),D(o,n,n,0,Ee.RIGHT_CAP_END,qe,E)),as(y,F+C,y,F,C),b=as(y,b-C,y,b,C),this._parameters.wireframe&&this._addWireframeVertices(s,F,b,C)}_addWireframeVertices(e,r,i,s){const a=new Float32Array(e.buffer,i*Float32Array.BYTES_PER_ELEMENT),o=new Float32Array(e.buffer,r*Float32Array.BYTES_PER_ELEMENT,i-r);let n=0;const l=c=>n=as(o,c,a,n,s);for(let c=0;c<o.length-1;c+=2*s)l(c),l(c+2*s),l(c+1*s),l(c+2*s),l(c+1*s),l(c+3*s)}}function as(t,e,r,i,s){for(let a=0;a<s;a++)r[i++]=t[e++];return i}function yn(t,e,r){return Sn(t,e.get(u.POSITION).data,r?r.get(u.POSITION):null)}function Sn(t,e,r){return!!t.isClosed&&(r?r.length>2:e.length>6)}function kd(t){return t.anchor===qr.Tip&&t.hideOnShortSegments&&t.placement==="begin-end"&&t.worldSpace}const Te=$(),Ce=$(),Ze=$(),Et=$(),qd=$(),Pt=Le(),Dt=Le(),Va=$(),Ha=$(),Ga=Bi(),Xd=Bi(),Zd=$(),Yd=$(),Jd=$(),Ir=[Le(),Le(),Le(),Le()],st=[$(),$(),$(),$()],os=dt(),ns=dt(),ls=dt(),cs=dt();class Qd{constructor(e){this._originSR=e,this._origins=new Map,this._objects=new Map,this._gridSize=5e5,this._rootOriginId="root/"+zs()}getOrigin(e){const r=this._origins.get(this._rootOriginId);if(r==null){const d=vd.rootOrigin;if(A(d))return this._origins.set(this._rootOriginId,fi(d[0],d[1],d[2],this._rootOriginId)),this.getOrigin(e);const f=fi(e[0]+Math.random()-.5,e[1]+Math.random()-.5,e[2]+Math.random()-.5,this._rootOriginId);return this._origins.set(this._rootOriginId,f),f}const i=this._gridSize,s=Math.round(e[0]/i),a=Math.round(e[1]/i),o=Math.round(e[2]/i),n=`${s}/${a}/${o}`;let l=this._origins.get(n);const c=.5*i;if(ne(he,e,r.vec3),he[0]=Math.abs(he[0]),he[1]=Math.abs(he[1]),he[2]=Math.abs(he[2]),he[0]<c&&he[1]<c&&he[2]<c){if(l){const d=Math.max(...he);if(ne(he,e,l.vec3),he[0]=Math.abs(he[0]),he[1]=Math.abs(he[1]),he[2]=Math.abs(he[2]),Math.max(...he)<d)return l}return r}return l||(l=fi(s*i,a*i,o*i,n),this._origins.set(n,l)),l}_drawOriginBox(e,r=_r(1,1,0,1)){const i=window.view,s=i._stage,a=r.toString();if(!this._objects.has(a)){this._material=new Hd({width:2,color:r}),s.add(this._material);const h=new id({pickable:!1}),v=new ed({castShadow:!1});s.add(v),h.add(v),s.add(h),this._objects.set(a,v)}const o=this._objects.get(a),n=[0,1,5,4,0,2,1,7,6,2,0,1,3,7,5,4,6,2,0],l=n.length,c=new Array(3*l),d=new Array,f=.5*this._gridSize;for(let h=0;h<l;h++)c[3*h+0]=e[0]+(1&n[h]?f:-f),c[3*h+1]=e[1]+(2&n[h]?f:-f),c[3*h+2]=e[2]+(4&n[h]?f:-f),h>0&&d.push(h-1,h);yi(c,this._originSR,0,c,i.renderSpatialReference,0,l);const p=new Ne(this._material,[[u.POSITION,new j(c,3,!0)]],[[u.POSITION,d]],null,br.Line);s.add(p),o.addGeometry(p)}get test(){const e=this;return{set gridSize(r){e._gridSize=r}}}}const he=$();var Xr,Pi;(function(t){t[t.RENDERING=0]="RENDERING",t[t.FINISHED_RENDERING=1]="FINISHED_RENDERING",t[t.FADING_TEXTURE_CHANNELS=2]="FADING_TEXTURE_CHANNELS",t[t.SWITCH_CHANNELS=3]="SWITCH_CHANNELS",t[t.FINISHED=4]="FINISHED"})(Xr||(Xr={})),function(t){t[t.RG=0]="RG",t[t.BA=1]="BA"}(Pi||(Pi={}));class Kd{constructor(){this.readChannels=Pi.RG,this.renderingStage=Xr.FINISHED,this.startTime=0,this.startTimeHeightFade=0,this.cameraPositionLastFrame=$(),this.isCameraPositionFinal=!0,this.parallax=new Wa,this.parallaxNew=new Wa,this.crossFade={enabled:!1,factor:1,distanceThresholdFactor:.3},this.fadeInOut={stage:pr.FINISHED,factor:1,distanceThresholdFactor:.6},this.fadeIn={stage:Di.FINISHED,factor:1,distanceThresholdFactor:2},this.fadeInOutHeight={stage:$i.FINISHED,factor:-1}}get isFading(){return this.fadeInOut.stage===pr.FADE_OUT||this.fadeInOut.stage===pr.FADE_IN||this.fadeIn.stage===Di.FADE_IN||this.fadeInOutHeight.stage!==$i.FINISHED||this.renderingStage===Xr.FADING_TEXTURE_CHANNELS}}var Di,pr,$i;(function(t){t[t.FINISHED=0]="FINISHED",t[t.CHANGE_ANCHOR=1]="CHANGE_ANCHOR",t[t.FADE_IN=2]="FADE_IN"})(Di||(Di={})),function(t){t[t.FINISHED=0]="FINISHED",t[t.FADE_OUT=1]="FADE_OUT",t[t.SWITCH=2]="SWITCH",t[t.FADE_IN=3]="FADE_IN"}(pr||(pr={})),function(t){t[t.FINISHED=0]="FINISHED",t[t.HEIGHT_FADE=1]="HEIGHT_FADE"}($i||($i={}));class Wa{constructor(){this.anchorPointClouds=$(),this.cloudsHeight=1e5,this.radiusCurvatureCorrectionFactor=0,this.transform=Y()}}function eh(t){t.include(Bs),t.uniforms.add([new Vt("geometryDepthTexture",(e,r)=>r.multipassGeometry.linearDepthTexture),new wt("nearFar",(e,r)=>r.camera.nearFar)]),t.code.add(m`bool geometryDepthTest(vec2 pos, float elementDepth) {
float geometryDepth = linearDepthFromTexture(geometryDepthTexture, pos, nearFar);
return (elementDepth < (geometryDepth - 1.0));
}`)}class th{constructor(){this.enabled=!1}}function rh(t,e){const r=t.fragment;r.include(Bs),r.uniforms.add(new wt("nearFar",(i,s)=>s.camera.nearFar)),r.uniforms.add(new Vt("depthMap",(i,s)=>s.linearDepthTexture)),r.uniforms.add(new yr("proj",(i,s)=>s.ssr.camera.projectionMatrix)),r.uniforms.add(new B("invResolutionHeight",(i,s)=>1/s.ssr.camera.height)),r.uniforms.add(new yr("reprojectionMatrix",(i,s)=>s.ssr.reprojectionMatrix)),r.code.add(m`
  vec2 reprojectionCoordinate(vec3 projectionCoordinate)
  {
    vec4 zw = proj * vec4(0.0, 0.0, -projectionCoordinate.z, 1.0);
    vec4 reprojectedCoord = reprojectionMatrix * vec4(zw.w * (projectionCoordinate.xy * 2.0 - 1.0), zw.z, zw.w);
    reprojectedCoord.xy /= reprojectedCoord.w;
    return reprojectedCoord.xy * 0.5 + 0.5;
  }

  const int maxSteps = ${e.highStepCount?"150":"75"};

  vec4 applyProjectionMat(mat4 projectionMat, vec3 x)
  {
    vec4 projectedCoord =  projectionMat * vec4(x, 1.0);
    projectedCoord.xy /= projectedCoord.w;
    projectedCoord.xy = projectedCoord.xy*0.5 + 0.5;
    return projectedCoord;
  }

  vec3 screenSpaceIntersection(vec3 dir, vec3 startPosition, vec3 viewDir, vec3 normal)
  {
    vec3 viewPos = startPosition;
    vec3 viewPosEnd = startPosition;

    // Project the start position to the screen
    vec4 projectedCoordStart = applyProjectionMat(proj, viewPos);
    vec3  Q0 = viewPos / projectedCoordStart.w; // homogeneous camera space
    float k0 = 1.0/ projectedCoordStart.w;

    // advance the position in the direction of the reflection
    viewPos += dir;

    vec4 projectedCoordVanishingPoint = applyProjectionMat(proj, dir);

    // Project the advanced position to the screen
    vec4 projectedCoordEnd = applyProjectionMat(proj, viewPos);
    vec3  Q1 = viewPos / projectedCoordEnd.w; // homogeneous camera space
    float k1 = 1.0/ projectedCoordEnd.w;

    // calculate the reflection direction in the screen space
    vec2 projectedCoordDir = (projectedCoordEnd.xy - projectedCoordStart.xy);
    vec2 projectedCoordDistVanishingPoint = (projectedCoordVanishingPoint.xy - projectedCoordStart.xy);

    float yMod = min(abs(projectedCoordDistVanishingPoint.y), 1.0);

    float projectedCoordDirLength = length(projectedCoordDir);
    float maxSt = float(maxSteps);

    // normalize the projection direction depending on maximum steps
    // this determines how blocky the reflection looks
    vec2 dP = yMod * (projectedCoordDir)/(maxSt * projectedCoordDirLength);

    // Normalize the homogeneous camera space coordinates
    vec3  dQ = yMod * (Q1 - Q0)/(maxSt * projectedCoordDirLength);
    float dk = yMod * (k1 - k0)/(maxSt * projectedCoordDirLength);

    // initialize the variables for ray marching
    vec2 P = projectedCoordStart.xy;
    vec3 Q = Q0;
    float k = k0;
    float rayStartZ = -startPosition.z; // estimated ray start depth value
    float rayEndZ = -startPosition.z;   // estimated ray end depth value
    float prevEstimateZ = -startPosition.z;
    float rayDiffZ = 0.0;
    float dDepth;
    float depth;
    float rayDiffZOld = 0.0;

    // early outs
    if (dot(normal, dir) < 0.0 || dot(-viewDir, normal) < 0.0)
      return vec3(P, 0.0);

    for(int i = 0; i < maxSteps-1; i++)
    {
      depth = -linearDepthFromTexture(depthMap, P, nearFar); // get linear depth from the depth buffer

      // estimate depth of the marching ray
      rayStartZ = prevEstimateZ;
      dDepth = -rayStartZ - depth;
      rayEndZ = (dQ.z * 0.5 + Q.z)/ ((dk * 0.5 + k));
      rayDiffZ = rayEndZ- rayStartZ;
      prevEstimateZ = rayEndZ;

      if(-rayEndZ > nearFar[1] || -rayEndZ < nearFar[0] || P.y < 0.0  || P.y > 1.0 )
      {
        return vec3(P, 0.);
      }

      // If we detect a hit - return the intersection point, two conditions:
      //  - dDepth > 0.0 - sampled point depth is in front of estimated depth
      //  - if difference between dDepth and rayDiffZOld is not too large
      //  - if difference between dDepth and 0.025/abs(k) is not too large
      //  - if the sampled depth is not behind far plane or in front of near plane

      if((dDepth) < 0.025/abs(k) + abs(rayDiffZ) && dDepth > 0.0 && depth > nearFar[0] && depth < nearFar[1] && abs(P.y - projectedCoordStart.y) > invResolutionHeight)
      {
        return vec3(P, depth);
      }

      // continue with ray marching
      P += dP;
      Q.z += dQ.z;
      k += dk;
      rayDiffZOld = rayDiffZ;
    }
    return vec3(P, 0.0);
  }
  `)}class ih{constructor(){this.enabled=!1,this.fadeFactor=1,this.reprojectionMatrix=Y()}}class sh{constructor(e,r,i){this.shadowMap=e,this.ssaoHelper=r,this.slicePlane=i,this.slot=W.OPAQUE_MATERIAL,this.hasOccludees=!1,this.enableFillLights=!0,this.transparencyPassType=ie.NONE,this._camera=new V,this._inverseViewport=K(),this.oldLighting=new ts,this.newLighting=new ts,this._fadedLighting=new ts,this._lighting=this.newLighting,this.ssr=new ih,this.multipassTerrain=new Yl,this.multipassGeometry=new th,this.overlays=[],this.cloudsFade=new Kd}get camera(){return this._camera}set camera(e){this._camera=this.ssr.camera=e,this._inverseViewport[0]=1/e.fullViewport[2],this._inverseViewport[1]=1/e.fullViewport[3]}get inverseViewport(){return this._inverseViewport}get lighting(){return this._lighting}get weatherFading(){return this._lighting===this._fadedLighting}fadeLighting(e){const{oldLighting:r,newLighting:i}=this;e>=1?this._lighting=i:(this._fadedLighting.lerpLighting(r,i,e),this._lighting=this._fadedLighting)}}class ah{constructor(e,r,i,s=null){this.rctx=e,this.sliceHelper=s,this.lastFrameCamera=new V,this.output=O.Color,this.renderOccludedMask=Ba,this.bindParameters=new sh(r,i,A(s)?s.plane:null)}resetRenderOccludedMask(){this.renderOccludedMask=Ba}}const Ba=xt.Occlude|xt.OccludeAndTransparent|xt.OccludeAndTransparentStencil;let zr=class extends V{constructor(){super(...arguments),this._projectionMatrix=Y()}get projectionMatrix(){return this._projectionMatrix}};g([L()],zr.prototype,"_projectionMatrix",void 0),g([L({readOnly:!0})],zr.prototype,"projectionMatrix",null),zr=g([Fi("esri.views.3d.webgl-engine.lib.CascadeCamera")],zr);var ka;(function(t){t[t.Highlight=0]="Highlight",t[t.Default=1]="Default"})(ka||(ka={}));class ii{constructor(){this.camera=new zr,this.lightMat=Y()}}class oh{get depthTexture(){return this._depthTexture}get textureSize(){return this._textureSize}get numCascades(){return this._numCascades}get cascadeDistances(){return Wr(this._usedCascadeDistances,this._cascadeDistances[0],this._numCascades>1?this._cascadeDistances[1]:1/0,this._numCascades>2?this._cascadeDistances[2]:1/0,this._numCascades>3?this._cascadeDistances[3]:1/0)}constructor(e,r){this._rctx=e,this._viewingMode=r,this._enabled=!1,this._snapshots=new Array,this._textureSize=0,this._numCascades=1,this._maxNumCascades=4,this._projectionView=Y(),this._projectionViewInverse=Y(),this._modelViewLight=Y(),this._splitSchemeLambda=0,this._cascadeDistances=[0,0,0,0,0],this._usedCascadeDistances=ke(),this._cascades=[new ii,new ii,new ii,new ii],this._lastOrigin=null,this._maxTextureSize=Math.min(St("esri-mobile")?2048:8192,this._rctx.parameters.maxTextureSize)}dispose(){this.enabled=!1,this.disposeOffscreenBuffers()}disposeOffscreenBuffers(){this._discardDepthTexture(),this._discardAllSnapshots()}set maxCascades(e){this._maxNumCascades=zt(Math.floor(e),1,4)}get maxCascades(){return this._maxNumCascades}set enabled(e){this._enabled=e,e||(this._discardDepthTexture(),this._discardAllSnapshots())}get enabled(){return this._enabled}get ready(){return this._enabled&&A(this._depthTexture)}getSnapshot(e){return this.enabled?this._snapshots[e]:null}get cascades(){for(let e=0;e<this._numCascades;++e)hs[e]=this._cascades[e];return hs.length=this._numCascades,hs}start(e,r,i){Oe(this.enabled),this._textureSize=this._computeTextureSize(e.fullWidth,e.fullHeight),this._ensureDepthTexture();const{near:s,far:a}=this._clampNearFar(i);this._computeCascadeDistances(a,s),this._setupMatrices(e,r);const{viewMatrix:o,projectionMatrix:n}=e;for(let l=0;l<this._numCascades;++l)this._constructCascade(l,n,o,r);this._lastOrigin=null,this.clear()}finish(e){Oe(this.enabled),this._rctx.bindFramebuffer(e)}getShadowMapMatrices(e){if(!this._lastOrigin||!ir(e,this._lastOrigin)){this._lastOrigin=this._lastOrigin||$(),k(this._lastOrigin,e);for(let r=0;r<this._numCascades;++r){ha(Qa,this._cascades[r].lightMat,e);for(let i=0;i<16;++i)Ka[16*r+i]=Qa[i]}}return Ka}takeCascadeSnapshotTo(e,r){Oe(this.enabled);const i=this._ensureSnapshot(r);this._bindFbo();const s=this._rctx,a=s.bindTexture(i,or.TEXTURE_UNIT_FOR_UPDATES);s.gl.copyTexSubImage2D(Vr.TEXTURE_2D,0,e.camera.viewport[0],e.camera.viewport[1],e.camera.viewport[0],e.camera.viewport[1],e.camera.viewport[2],e.camera.viewport[3]),s.bindTexture(a,or.TEXTURE_UNIT_FOR_UPDATES)}clear(){const e=this._rctx;this._bindFbo(),e.setClearColor(1,1,1,1),e.clearSafe(bi.COLOR_BUFFER_BIT|bi.DEPTH_BUFFER_BIT)}_computeTextureSize(e,r){const i=.5*Math.log(e*e+r*r)*Math.LOG2E,s=.35,a=2**Math.round(i+s);return Math.min(this._maxTextureSize,2*a)}_ensureDepthTexture(){if(A(this._depthTexture)&&this._depthTexture.descriptor.width===this._textureSize)return;this._discardDepthTexture();const e={target:Vr.TEXTURE_2D,pixelFormat:wr.RGBA,dataType:Br.UNSIGNED_BYTE,wrapMode:xr.CLAMP_TO_EDGE,samplingMode:Ci.NEAREST,flipped:!0,width:this._textureSize,height:this._textureSize};this._depthTexture=new or(this._rctx,e),this._fbo=new Ko(this._rctx,{colorTarget:Yo.TEXTURE,depthStencilTarget:Jo.DEPTH_RENDER_BUFFER,width:this._textureSize,height:this._textureSize},this._depthTexture)}_ensureSnapshot(e){let r=this._snapshots[e];if(A(r)&&r.descriptor.width===this._textureSize)return r;this._discardSnapshot(e);const i={target:Vr.TEXTURE_2D,pixelFormat:wr.RGBA,dataType:Br.UNSIGNED_BYTE,wrapMode:xr.CLAMP_TO_EDGE,samplingMode:Ci.NEAREST,flipped:!0,width:this._textureSize,height:this._textureSize};return r=new or(this._rctx,i),this._snapshots[e]=r,r}_discardDepthTexture(){this._fbo=We(this._fbo),this._depthTexture=We(this._depthTexture)}_discardSnapshot(e){this._snapshots[e]=We(this._snapshots[e])}_discardAllSnapshots(){for(let e=0;e<this._snapshots.length;++e)this._discardSnapshot(e);this._snapshots.length=0}_bindFbo(){const e=this._rctx;e.unbindTexture(this._depthTexture),e.bindFramebuffer(this._fbo)}_constructCascade(e,r,i,s){const a=this._cascades[e],o=-this._cascadeDistances[e],n=-this._cascadeDistances[e+1],l=(r[10]*o+r[14])/Math.abs(r[11]*o+r[15]),c=(r[10]*n+r[14])/Math.abs(r[11]*n+r[15]);Oe(l<c);for(let h=0;h<8;++h){Wr(qa,h%4==0||h%4==3?-1:1,h%4==0||h%4==1?-1:1,h<4?l:c,1);const v=je[h];sr(v,qa,this._projectionViewInverse),v[0]/=v[3],v[1]/=v[3],v[2]/=v[3]}Xn(ds,je[0]),a.camera.viewMatrix=ha(nh,this._modelViewLight,ds);for(let h=0;h<8;++h)se(je[h],je[h],a.camera.viewMatrix);let d=je[0][2],f=je[0][2];for(let h=1;h<8;++h)d=Math.min(d,je[h][2]),f=Math.max(f,je[h][2]);d-=200,f+=200,a.camera.near=-f,a.camera.far=-d,hh(i,s,d,f,a.camera),jt(a.lightMat,a.camera.projectionMatrix,a.camera.viewMatrix);const p=this._textureSize/2;a.camera.viewport=[e%2==0?0:p,Math.floor(e/2)===0?0:p,p,p]}_setupMatrices(e,r){jt(this._projectionView,e.projectionMatrix,e.viewMatrix),dr(this._projectionViewInverse,this._projectionView);const i=this._viewingMode===Tt.Global?e.eye:H(ds,0,0,1);Ro(this._modelViewLight,[0,0,0],[-r[0],-r[1],-r[2]],i)}_clampNearFar(e){let{near:r,far:i}=e;return r<2&&(r=2),i<2&&(i=2),r>=i&&(r=2,i=4),{near:r,far:i}}_computeCascadeDistances(e,r){this._numCascades=Math.min(1+Math.floor(Dc(e/r,4)),this._maxNumCascades);const i=(e-r)/this._numCascades,s=(e/r)**(1/this._numCascades);let a=r,o=r;for(let n=0;n<this._numCascades+1;++n)this._cascadeDistances[n]=Nt(a,o,this._splitSchemeLambda),a*=s,o+=i}get gpuMemoryUsage(){var e,r;return this._snapshots.reduce((i,s)=>i+qc(s),(r=(e=this._fbo)==null?void 0:e.gpuMemoryUsage)!=null?r:0)}get test(){const e=this;return{maxNumCascades:this._maxNumCascades,cascades:this._cascades,textureSize:this._textureSize,set splitSchemeLambda(r){e._splitSchemeLambda=r},get splitSchemeLambda(){return e._splitSchemeLambda}}}}const nh=Y(),qa=ke(),je=[];for(let t=0;t<8;++t)je.push(ke());const Xa=K(),Za=K(),lh=K(),Ya=K(),Ja=K(),ds=$(),hs=[],Qa=Y(),Ka=new Float32Array(64),$e=K(),Xt=K(),$t=[K(),K(),K(),K()],oe=K(),us=K(),ut=K(),Mr=K(),Zt=K(),Yt=K(),si=K();function ch(t,e,r,i,s,a,o,n){Ut($e,0,0);for(let C=0;C<4;++C)Rt($e,$e,t[C]);tr($e,$e,.25),Ut(Xt,0,0);for(let C=4;C<8;++C)Rt(Xt,Xt,t[C]);tr(Xt,Xt,.25),$r($t[0],t[4],t[5],.5),$r($t[1],t[5],t[6],.5),$r($t[2],t[6],t[7],.5),$r($t[3],t[7],t[4],.5);let l=0,c=ua($t[0],$e);for(let C=1;C<4;++C){const b=ua($t[C],$e);b<c&&(c=b,l=C)}rr(oe,$t[l],t[l+4]);const d=oe[0];let f,p;oe[0]=-oe[1],oe[1]=d,rr(us,Xt,$e),ye(us,oe)<0&&Yn(oe,oe),$r(oe,oe,us,r),pa(oe,oe),f=p=ye(rr(ut,t[0],$e),oe);for(let C=1;C<8;++C){const b=ye(rr(ut,t[C],$e),oe);b<f?f=b:b>p&&(p=b)}Tr(i,$e),tr(ut,oe,f-e),Rt(i,i,ut);let h=-1,v=1,_=0,S=0;for(let C=0;C<8;++C){rr(Mr,t[C],i),pa(Mr,Mr);const b=oe[0]*Mr[1]-oe[1]*Mr[0];b>0?b>h&&(h=b,_=C):b<v&&(v=b,S=C)}kt(h>0,"leftArea"),kt(v<0,"rightArea"),tr(Zt,oe,f),Rt(Zt,Zt,$e),tr(Yt,oe,p),Rt(Yt,Yt,$e),si[0]=-oe[1],si[1]=oe[0];const T=ti(i,t[S],Yt,Rt(ut,Yt,si),1,s),w=ti(i,t[_],Yt,ut,1,a),y=ti(i,t[_],Zt,Rt(ut,Zt,si),1,o),R=ti(i,t[S],Zt,ut,1,n);kt(T,"rayRay"),kt(w,"rayRay"),kt(y,"rayRay"),kt(R,"rayRay")}function z(t,e){return 3*e+t}const eo=K();function Ae(t,e){return Ut(eo,t[e],t[e+3]),eo}const be=K(),P=Ys();function dh(t,e,r,i,s){rr(be,r,i),tr(be,be,.5),P[0]=be[0],P[1]=be[1],P[2]=0,P[3]=be[1],P[4]=-be[0],P[5]=0,P[6]=be[0]*be[0]+be[1]*be[1],P[7]=be[0]*be[1]-be[1]*be[0],P[8]=1,P[z(0,2)]=-ye(Ae(P,0),t),P[z(1,2)]=-ye(Ae(P,1),t);let a=ye(Ae(P,0),r)+P[z(0,2)],o=ye(Ae(P,1),r)+P[z(1,2)],n=ye(Ae(P,0),i)+P[z(0,2)],l=ye(Ae(P,1),i)+P[z(1,2)];a=-(a+n)/(o+l),P[z(0,0)]+=P[z(1,0)]*a,P[z(0,1)]+=P[z(1,1)]*a,P[z(0,2)]+=P[z(1,2)]*a,a=1/(ye(Ae(P,0),r)+P[z(0,2)]),o=1/(ye(Ae(P,1),r)+P[z(1,2)]),P[z(0,0)]*=a,P[z(0,1)]*=a,P[z(0,2)]*=a,P[z(1,0)]*=o,P[z(1,1)]*=o,P[z(1,2)]*=o,P[z(2,0)]=P[z(1,0)],P[z(2,1)]=P[z(1,1)],P[z(2,2)]=P[z(1,2)],P[z(1,2)]+=1,a=ye(Ae(P,1),e)+P[z(1,2)],o=ye(Ae(P,2),e)+P[z(2,2)],n=ye(Ae(P,1),r)+P[z(1,2)],l=ye(Ae(P,2),r)+P[z(2,2)],a=-.5*(a/o+n/l),P[z(1,0)]+=P[z(2,0)]*a,P[z(1,1)]+=P[z(2,1)]*a,P[z(1,2)]+=P[z(2,2)]*a,a=ye(Ae(P,1),e)+P[z(1,2)],o=ye(Ae(P,2),e)+P[z(2,2)],n=-o/a,P[z(1,0)]*=n,P[z(1,1)]*=n,P[z(1,2)]*=n,s[0]=P[0],s[1]=P[1],s[2]=0,s[3]=P[2],s[4]=P[3],s[5]=P[4],s[6]=0,s[7]=P[5],s[8]=0,s[9]=0,s[10]=1,s[11]=0,s[12]=P[6],s[13]=P[7],s[14]=0,s[15]=P[8]}function hh(t,e,r,i,s){const a=1/je[0][3],o=1/je[4][3];Oe(a<o);let n=a+Math.sqrt(a*o);const l=Math.sin(Zn(t[2]*e[0]+t[6]*e[1]+t[10]*e[2]));n/=l,ch(je,n,l,Xa,Za,lh,Ya,Ja),dh(Xa,Za,Ya,Ja,s.projectionMatrix),s.projectionMatrix[10]=2/(r-i),s.projectionMatrix[14]=-(r+i)/(r-i)}var Ct,Wt;(function(t){t[t.OBJECT=0]="OBJECT",t[t.HUD=1]="HUD",t[t.TERRAIN=2]="TERRAIN",t[t.OVERLAY=3]="OVERLAY",t[t.I3S=4]="I3S",t[t.PCL=5]="PCL",t[t.LOD=6]="LOD",t[t.VOXEL=7]="VOXEL"})(Ct||(Ct={}));class uh{constructor(){this.verticalOffset=0,this.selectionMode=!1,this.hud=!0,this.selectOpaqueTerrainOnly=!0,this.invisibleTerrain=!1,this.backfacesTerrain=!0,this.isFiltered=!1,this.filteredLayerUids=[],this.store=Wt.ALL}}(function(t){t[t.MIN=0]="MIN",t[t.MINMAX=1]="MINMAX",t[t.ALL=2]="ALL"})(Wt||(Wt={}));class ph{constructor(e,r,i){this.object=e,this.geometryId=r,this.triangleNr=i}}class fh extends ph{constructor(e,r,i,s){super(e,r,i),this.center=A(s)?Jn(s):null}}class mh{constructor(e){this.layerUid=e}}class gh extends mh{constructor(e,r){super(e),this.graphicUid=r}}function vh(t){return A(t)&&A(t.dist)}class _h extends gh{constructor(e,r,i){super(e,r),this.triangleNr=i}}class yh{constructor(){this.adds=new rt,this.removes=new rt,this.updates=new rt({allocator:e=>e||new Sh,deallocator:e=>(e.renderGeometry=null,e)})}clear(){this.adds.clear(),this.removes.clear(),this.updates.clear()}prune(){this.adds.prune(),this.removes.prune(),this.updates.prune()}get empty(){return this.adds.length===0&&this.removes.length===0&&this.updates.length===0}}class Sh{}class wh{constructor(){this.adds=new Array,this.removes=new Array,this.updates=new Array}}const to=1e-5;class xh{constructor(e){this.options=new uh,this._results=new Oh,this.transform=new Jl,this.tolerance=to,this.verticalOffset=null,this._ray=mt(),this._rayEnd=$(),this._rayBeginTransformed=$(),this._rayEndTransformed=$(),this.viewingMode=e!=null?e:Tt.Global}get results(){return this._results}get ray(){return this._ray}get rayBegin(){return this._ray.origin}get rayEnd(){return this._rayEnd}reset(e,r,i){this.resetWithRay(Ul(e,r,this._ray),i)}resetWithRay(e,r){this.camera=r,e!==this._ray&&Es(e,this._ray),this.options.verticalOffset!==0?this.viewingMode===Tt.Local?this._ray.origin[2]-=this.options.verticalOffset:this.verticalOffset=this.options.verticalOffset:this.verticalOffset=null,re(this._rayEnd,this._ray.origin,this._ray.direction),this._results.init(this._ray)}intersect(e=null,r,i,s,a){this.point=r,this.filterPredicate=s,this.tolerance=i!=null?i:to;const o=xa(this.verticalOffset);if(A(e)&&e.length>0){const n=a?l=>{a(l)&&this.intersectObject(l)}:l=>{this.intersectObject(l)};for(const l of e){const c=l.getSpatialQueryAccelerator&&l.getSpatialQueryAccelerator();A(c)?(A(o)?c.forEachAlongRayWithVerticalOffset(this._ray.origin,this._ray.direction,n,o):c.forEachAlongRay(this._ray.origin,this._ray.direction,n),this.options.selectionMode&&this.options.hud&&c.forEachDegenerateObject(n)):l.objects.forAll(d=>n(d))}}this.sortResults()}intersectObject(e){const r=e.geometries;if(!r)return;const i=e.transformation,s=xa(this.verticalOffset);for(const a of r){if(!a.visible)continue;const{material:o,id:n}=a;this.transform.setAndInvalidateLazyTransforms(i,a.shaderTransformation),se(this._rayBeginTransformed,this.rayBegin,this.transform.inverse),se(this._rayEndTransformed,this.rayEnd,this.transform.inverse);const l=this.transform.transform;A(s)&&(s.objectTransform=this.transform),o.intersect(a,this.transform.transform,this,this._rayBeginTransformed,this._rayEndTransformed,(c,d,f,p,h,v)=>{if(c>=0){if(A(this.filterPredicate)&&!this.filterPredicate(this._ray.origin,this._rayEnd,c))return;const _=p?this._results.hud:this._results,S=p?T=>{const w=new fh(e,n,f,v);T.set(Ct.HUD,w,c,d,Bo,h)}:T=>T.set(Ct.OBJECT,{object:e,geometryId:n,triangleNr:f},c,d,l,h);if((_.min.drapedLayerOrder==null||h>=_.min.drapedLayerOrder)&&(_.min.dist==null||c<_.min.dist)&&S(_.min),this.options.store!==Wt.MIN&&(_.max.drapedLayerOrder==null||h<_.max.drapedLayerOrder)&&(_.max.dist==null||c>_.max.dist)&&S(_.max),this.options.store===Wt.ALL)if(p){const T=new $s(this._ray);S(T),this._results.hud.all.push(T)}else{const T=new fr(this._ray);S(T),this._results.all.push(T)}}})}}sortResults(e=this._results.all){e.sort((r,i)=>r.dist!==i.dist?ae(r.dist,0)-ae(i.dist,0):r.drapedLayerOrder!==i.drapedLayerOrder?ae(r.drapedLayerOrder,Number.MAX_VALUE)-ae(i.drapedLayerOrder,Number.MAX_VALUE):ae(i.drapedLayerGraphicOrder,Number.MIN_VALUE)-ae(r.drapedLayerGraphicOrder,Number.MIN_VALUE))}}function df(t){return new xh(t)}class Oh{constructor(){this.min=new fr(mt()),this.max=new fr(mt()),this.hud={min:new $s(mt()),max:new $s(mt()),all:new Array},this.ground=new fr(mt()),this.all=[]}init(e){this.min.init(e),this.max.init(e),this.ground.init(e),this.all.length=0,this.hud.min.init(e),this.hud.max.init(e),this.hud.all.length=0}}class fr{get ray(){return this._ray}get distanceInRenderSpace(){return A(this.dist)?(Z(ai,this.ray.direction,this.dist),nt(ai)):null}getIntersectionPoint(e){return!!vh(this)&&(Z(ai,this.ray.direction,this.dist),re(e,this.ray.origin,ai),!0)}getTransformedNormal(e){return k(Lr,this.normal),Lr[3]=0,sr(Lr,Lr,this.transformation),k(e,Lr),de(e,e)}constructor(e){this.intersector=Ct.OBJECT,this.normal=$(),this.transformation=Y(),this._ray=mt(),this.init(e)}init(e){this.dist=null,this.target=null,this.drapedLayerOrder=null,this.drapedLayerGraphicOrder=null,this.intersector=Ct.OBJECT,Es(e,this._ray)}set(e,r,i,s,a,o,n){this.intersector=e,this.dist=i,k(this.normal,ae(s,Qn)),yt(this.transformation,ae(a,Bo)),this.target=r,this.drapedLayerOrder=o,this.drapedLayerGraphicOrder=n}copy(e){Es(e.ray,this._ray),this.intersector=e.intersector,this.dist=e.dist,this.target=e.target,this.drapedLayerOrder=e.drapedLayerOrder,this.drapedLayerGraphicOrder=e.drapedLayerGraphicOrder,k(this.normal,e.normal),yt(this.transformation,e.transformation)}}class $s extends fr{constructor(){super(...arguments),this.intersector=Ct.HUD}}function Th(t){return new fr(t)}const ai=$(),Lr=ke();function Ch(t){const e=new Map,r=i=>{let s=e.get(i);return s||(s=new wh,e.set(i,s)),s};return t.removes.forAll(i=>{ps(i)&&r(i.material).removes.push(i)}),t.adds.forAll(i=>{ps(i)&&r(i.material).adds.push(i)}),t.updates.forAll(i=>{ps(i.renderGeometry)&&r(i.renderGeometry.material).updates.push(i)}),e}function ps(t){return t.geometry.indexCount>=1}class bh{constructor(e){this._rctx=e,this._indexBuffer=this._createIndexbuffer(),this._program=this._createProgram()}_createProgram(){const e=`
    void main(void) {
      gl_Position = vec4(0.0, 0.0, float(gl_VertexID)-2.0, 1.0);
    }`,r=`
    void main(void) {
      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    }`;return this._rctx.programCache.acquire(e,r,new Map([]))}_createIndexbuffer(){return en.createIndex(this._rctx,Qo.STATIC_DRAW,new Uint32Array([0]))}resetIndicesType(){this._program.compiled&&this._indexBuffer&&(this._rctx.bindVAO(null),this._rctx.useProgram(this._program),this._rctx.bindBuffer(this._indexBuffer,Gc.ELEMENT_ARRAY_BUFFER),this._rctx.drawElements(Ht.POINTS,1,Wc.UNSIGNED_INT,0))}dispose(){this._program.dispose(),this._indexBuffer.dispose()}}class Ah{constructor(e,r){this._material=e,this._repository=r,this._map=new Map}destroy(){this._map.forEach((e,r)=>{A(e)&&this._repository.release(this._material,r)})}load(e,r,i){if(!this._material.requiresSlot(r,i))return null;this._map.has(i)||this._map.set(i,this._repository.acquire(this._material,r,i));const s=this._map.get(i);if(A(s)){if(s.ensureResources(e)===kc.LOADED)return s;this._repository.requestRender()}return null}}class Rh extends Ql{constructor(e=$()){super(),this.origin=e,this.slicePlaneLocalOrigin=this.origin}}const Eh=bt().vec3f(u.POSITION),Ph=bt().vec3f(u.POSITION).vec2f(u.UV0),wn=bt().vec3f(u.POSITION).vec4u8(u.COLOR);bt().vec3f(u.POSITION).vec4u8(u.OBJECTANDLAYERIDCOLOR);bt().vec3f(u.POSITION).vec2f(u.UV0).vec4u8(u.OBJECTANDLAYERIDCOLOR);const Dh=bt().vec3f(u.POSITION).vec4u8(u.COLOR).vec4u8(u.OBJECTANDLAYERIDCOLOR);class xn extends Vi{intersect(e,r,i,s,a,o){return Kl(e,i,s,a,void 0,o)}}function $h(t){t.fragment.code.add(m`float normals2FoamIntensity(vec3 n, float waveStrength){
float normalizationFactor =  max(0.015, waveStrength);
return max((n.x + n.y)*0.3303545/normalizationFactor + 0.3303545, 0.0);
}`)}function Ih(t){t.fragment.code.add(m`vec3 foamIntensity2FoamColor(float foamIntensityExternal, float foamPixelIntensity, vec3 skyZenitColor, float dayMod){
return foamIntensityExternal * (0.075 * skyZenitColor * pow(foamPixelIntensity, 4.) +  50.* pow(foamPixelIntensity, 23.0)) * dayMod;
}`)}function ro(t){t.fragment.uniforms.add(new Vt("texWaveNormal",e=>e.waveNormal)),t.fragment.uniforms.add(new Vt("texWavePerturbation",e=>e.wavePertubation)),t.fragment.uniforms.add([new Pe("waveParams",e=>Wr(Mh,e.waveStrength,e.waveTextureRepeat,e.flowStrength,e.flowOffset)),new wt("waveDirection",e=>Ut(Lh,e.waveDirection[0]*e.waveVelocity,e.waveDirection[1]*e.waveVelocity))]),t.include($h),t.fragment.code.add(m`const vec2  FLOW_JUMP = vec2(6.0/25.0, 5.0/24.0);
vec2 textureDenormalized2D(sampler2D _tex, vec2 _uv) {
return 2.0 * texture2D(_tex, _uv).rg - 1.0;
}
float sampleNoiseTexture(vec2 _uv) {
return texture2D(texWavePerturbation, _uv).b;
}
vec3 textureDenormalized3D(sampler2D _tex, vec2 _uv) {
return 2.0 * texture2D(_tex, _uv).rgb - 1.0;
}
float computeProgress(vec2 uv, float time) {
return fract(time);
}
float computeWeight(vec2 uv, float time) {
float progress = computeProgress(uv, time);
return 1.0 - abs(1.0 - 2.0 * progress);
}
vec3 computeUVPerturbedWeigth(sampler2D texFlow, vec2 uv, float time, float phaseOffset) {
float flowStrength = waveParams[2];
float flowOffset = waveParams[3];
vec2 flowVector = textureDenormalized2D(texFlow, uv) * flowStrength;
float progress = computeProgress(uv, time + phaseOffset);
float weight = computeWeight(uv, time + phaseOffset);
vec2 result = uv;
result -= flowVector * (progress + flowOffset);
result += phaseOffset;
result += (time - progress) * FLOW_JUMP;
return vec3(result, weight);
}
const float TIME_NOISE_TEXTURE_REPEAT = 0.3737;
const float TIME_NOISE_STRENGTH = 7.77;
vec3 getWaveLayer(sampler2D _texNormal, sampler2D _dudv, vec2 _uv, vec2 _waveDir, float time) {
float waveStrength = waveParams[0];
vec2 waveMovement = time * -_waveDir;
float timeNoise = sampleNoiseTexture(_uv * TIME_NOISE_TEXTURE_REPEAT) * TIME_NOISE_STRENGTH;
vec3 uv_A = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.0);
vec3 uv_B = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.5);
vec3 normal_A = textureDenormalized3D(_texNormal, uv_A.xy) * uv_A.z;
vec3 normal_B = textureDenormalized3D(_texNormal, uv_B.xy) * uv_B.z;
vec3 mixNormal = normalize(normal_A + normal_B);
mixNormal.xy *= waveStrength;
mixNormal.z = sqrt(1.0 - dot(mixNormal.xy, mixNormal.xy));
return mixNormal;
}
vec4 getSurfaceNormalAndFoam(vec2 _uv, float _time) {
float waveTextureRepeat = waveParams[1];
vec3 normal = getWaveLayer(texWaveNormal, texWavePerturbation, _uv * waveTextureRepeat, waveDirection, _time);
float foam  = normals2FoamIntensity(normal, waveParams[0]);
return vec4(normal, foam);
}`)}const Mh=ke(),Lh=K();function io(t,e){e.spherical?t.vertex.code.add(m`vec3 getLocalUp(in vec3 pos, in vec3 origin) {
return normalize(pos + origin);
}`):t.vertex.code.add(m`vec3 getLocalUp(in vec3 pos, in vec3 origin) {
return vec3(0.0, 0.0, 1.0);
}`),e.spherical?t.vertex.code.add(m`mat3 getTBNMatrix(in vec3 n) {
vec3 t = normalize(cross(vec3(0.0, 0.0, 1.0), n));
vec3 b = normalize(cross(n, t));
return mat3(t, b, n);
}`):t.vertex.code.add(m`mat3 getTBNMatrix(in vec3 n) {
vec3 t = vec3(1.0, 0.0, 0.0);
vec3 b = normalize(cross(n, t));
return mat3(t, b, n);
}`)}function Nh(t){t.fragment.code.add(m`const float GAMMA = 2.2;
const float INV_GAMMA = 0.4545454545;
vec4 delinearizeGamma(vec4 color) {
return vec4(pow(color.rgb, vec3(INV_GAMMA)), color.w);
}
vec3 linearizeGamma(vec3 color) {
return pow(color, vec3(GAMMA));
}`)}class Fh extends ec{constructor(e,r){super(e,"samplerCube",tc.Pass,(i,s,a)=>i.bindTexture(e,r(s,a)))}}function zh(t){const e=t.fragment;e.uniforms.add([new yr("rotationMatrixClouds",(r,i)=>i.cloudsFade.parallax.transform),new yr("rotationMatrixCloudsCrossFade",(r,i)=>i.cloudsFade.parallaxNew.transform),new ar("anchorPosition",(r,i)=>i.cloudsFade.parallax.anchorPointClouds),new ar("anchorPositionCrossFade",(r,i)=>i.cloudsFade.parallaxNew.anchorPointClouds),new B("cloudsHeight",(r,i)=>i.cloudsFade.parallax.cloudsHeight),new B("radiusCurvatureCorrectionFactor",(r,i)=>i.cloudsFade.parallax.radiusCurvatureCorrectionFactor),new B("totalFadeInOut",(r,i)=>i.cloudsFade.fadeInOut.stage===pr.FINISHED?i.cloudsFade.fadeInOutHeight.factor+1-i.cloudsFade.fadeIn.factor:i.cloudsFade.fadeInOutHeight.factor+1-i.cloudsFade.fadeInOut.factor),new B("crossFadeAnchorFactor",(r,i)=>zt(i.cloudsFade.crossFade.factor,0,1)),new Fh("cubeMap",(r,i)=>A(i.cloudsFade.data)&&A(i.cloudsFade.data.cubeMap)?i.cloudsFade.data.cubeMap.colorTexture:null),new rs("crossFade",(r,i)=>i.cloudsFade.crossFade.enabled),new rs("readChannelsRG",(r,i)=>i.cloudsFade.readChannels===Pi.RG),new rs("fadeTextureChannels",(r,i)=>i.cloudsFade.renderingStage===Xr.FADING_TEXTURE_CHANNELS)]),e.constants.add("planetRadius","float",Kn.radius),e.code.add(m`vec3 intersectWithCloudLayer(vec3 dir, vec3 cameraPosition, vec3 spherePos)
{
float radiusClouds = planetRadius + cloudsHeight;
float B = 2.0 * dot(cameraPosition, dir);
float C = dot(cameraPosition, cameraPosition) - radiusClouds * radiusClouds;
float det = B * B - 4.0 * C;
float pointIntDist = max(0.0, 0.5 *(-B + sqrt(det)));
vec3 intersectionPont = cameraPosition + dir * pointIntDist;
intersectionPont =  intersectionPont - spherePos;
return intersectionPont;
}`),e.code.add(m`vec3 correctForPlanetCurvature(vec3 dir)
{
dir.z = dir.z*(1.-radiusCurvatureCorrectionFactor) + radiusCurvatureCorrectionFactor;
return dir;
}`),e.code.add(m`vec3 rotateDirectionToAnchorPoint(mat4 rotMat, vec3 inVec)
{
return (rotMat * vec4(inVec, 0.0)).xyz;
}`),Fo(e),zo(e),e.code.add(m`const float SUNSET_TRANSITION_FACTOR = 0.3;
const vec3 RIM_COLOR = vec3(0.28, 0.175, 0.035);
const float RIM_SCATTERING_FACTOR = 140.0;
const float BACKLIGHT_FACTOR = 0.2;
const float BACKLIGHT_SCATTERING_FACTOR = 10.0;
const float BACKLIGHT_TRANSITION_FACTOR = 0.3;
vec3 calculateCloudColor(vec3 cameraPosition, vec3 worldSpaceRay, vec4 clouds)
{
float upDotLight = dot(normalize(cameraPosition), normalize(mainLightDirection));
float dirDotLight = max(dot(normalize(-worldSpaceRay), normalize(mainLightDirection)), 0.0);
float sunsetTransition = clamp(pow(max(upDotLight, 0.0), SUNSET_TRANSITION_FACTOR), 0.0, 1.0);
vec3 ambientLight = calculateAmbientIrradiance(normalize(cameraPosition),  0.0);
vec3 mainLight = evaluateMainLighting(normalize(cameraPosition),  0.0);
vec3 combinedLight = clamp((mainLightIntensity + ambientLight )/PI, vec3(0.0), vec3(1.0));
vec3 baseCloudColor = pow(combinedLight * pow(clouds.xyz, vec3(GAMMA)), vec3(INV_GAMMA));
float scatteringMod = max(clouds.a < 0.5 ? clouds.a / 0.5 : - clouds.a / 0.5 + 2.0, 0.0);
float rimLightIntensity = 0.5 + 0.5 *pow(max(upDotLight, 0.0), 0.35);
vec3 directSunScattering = RIM_COLOR * rimLightIntensity * (pow(dirDotLight, RIM_SCATTERING_FACTOR)) * scatteringMod;
float additionalLight = BACKLIGHT_FACTOR * pow(dirDotLight, BACKLIGHT_SCATTERING_FACTOR) * (1. - pow(sunsetTransition, BACKLIGHT_TRANSITION_FACTOR)) ;
return vec3(baseCloudColor * (1. + additionalLight) + directSunScattering);
}`),e.code.add(m`vec4 getCloudData(vec3 rayDir, bool readOtherChannel)
{
vec4 cloudData = textureCube(cubeMap, rayDir);
float mu = dot(rayDir, vec3(0, 0, 1));
bool readChannels = readChannelsRG ^^ readOtherChannel;
if (readChannels) {
cloudData = vec4(vec3(cloudData.r), cloudData.g);
} else {
cloudData = vec4(vec3(cloudData.b), cloudData.a);
}
if (length(cloudData) == 0.0) {
return vec4(cloudData.rgb, 1.0);
}
return cloudData;
}`),e.code.add(m`vec4 renderCloudsNoFade(vec3 worldRay, vec3 cameraPosition)
{
vec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);
vec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));
vec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
vec4 cloudData = getCloudData(worldRayRotatedCorrected, false);
float totalTransmittance = clamp(cloudData.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);
if (length(cloudData.rgb) == 0.0) {
totalTransmittance = 1.0;
}
return vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), totalTransmittance);
}`),e.code.add(m`vec4 renderCloudsCrossFade(vec3 worldRay, vec3 cameraPosition)
{
vec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);
vec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));
vec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
vec4 cloudData = getCloudData(worldRayRotatedCorrected, false);
vec4 cloudColor = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);
intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPositionCrossFade);
worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixCloudsCrossFade, normalize(intersectionPoint));
worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
cloudData = getCloudData(worldRayRotatedCorrected, fadeTextureChannels);
vec4 cloudColorCrossFade = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);
cloudColor = mix(cloudColor, cloudColorCrossFade, crossFadeAnchorFactor);
float totalTransmittance = clamp(cloudColor.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);
if (length(cloudColor.rgb) == 0.0) {
totalTransmittance = 1.0;
}
return vec4(cloudColor.rgb, totalTransmittance);
}`),e.code.add(m`vec4 renderClouds(vec3 worldRay, vec3 cameraPosition)
{
return crossFade ? renderCloudsCrossFade(worldRay, cameraPosition) : renderCloudsNoFade(worldRay, cameraPosition);
}`)}function jh(t,e){t.include(rc,e),t.include(Nh),t.include(Ih),e.hasCloudsReflections&&t.include(zh,e),e.hasScreenSpaceReflections&&t.include(rh,e);const r=t.fragment;r.constants.add("fresnelSky","vec3",[.02,1,15]).add("fresnelMaterial","vec2",[.02,.1]).add("roughness","float",.015).add("foamIntensityExternal","float",1.7).add("ssrIntensity","float",.65).add("ssrHeightFadeStart","float",3e5).add("ssrHeightFadeEnd","float",5e5).add("waterDiffusion","float",.92).add("waterSeaColorMod","float",.8).add("correctionViewingPowerFactor","float",.4).add("skyZenitColor","vec3",[.52,.68,.9]).add("skyColor","vec3",[.67,.79,.9]).add("cloudFresnelModifier","vec2",[1.2,.01]),r.code.add(m`PBRShadingWater shadingInfo;
vec3 getSkyGradientColor(in float cosTheta, in vec3 horizon, in vec3 zenit) {
float exponent = pow((1.0 - cosTheta), fresnelSky[2]);
return mix(zenit, horizon, exponent);
}`),r.uniforms.add([new B("lightingSpecularStrength",(i,s)=>s.lighting.mainLight.specularStrength),new B("lightingEnvironmentStrength",(i,s)=>s.lighting.mainLight.environmentStrength)]),r.code.add(m`vec3 getSeaColor(in vec3 n, in vec3 v, in vec3 l, vec3 color, in vec3 lightIntensity, in vec3 localUp, in float shadow, float foamIntensity, vec3 viewPosition, vec3 position) {
float reflectionHit = 0.0;
float reflectionHitDiffused = 0.0;
vec3 seaWaterColor = linearizeGamma(color);
vec3 h = normalize(l + v);
shadingInfo.NdotL = clamp(dot(n, l), 0.0, 1.0);
shadingInfo.NdotV = clamp(dot(n, v), 0.001, 1.0);
shadingInfo.VdotN = clamp(dot(v, n), 0.001, 1.0);
shadingInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);
shadingInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);
shadingInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);
float upDotV = max(dot(localUp,v), 0.0);
vec3 skyHorizon = linearizeGamma(skyColor);
vec3 skyZenit = linearizeGamma(skyZenitColor);
vec3 skyColor = getSkyGradientColor(upDotV, skyHorizon, skyZenit );
float upDotL = max(dot(localUp,l),0.0);
float daytimeMod = 0.1 + upDotL * 0.9;
skyColor *= daytimeMod;
float shadowModifier = clamp(shadow, 0.8, 1.0);
vec3 fresnelModifier = fresnelReflection(shadingInfo.VdotN, vec3(fresnelSky[0]), fresnelSky[1]);
vec3 reflSky = lightingEnvironmentStrength * fresnelModifier * skyColor * shadowModifier;
vec3 reflSea = seaWaterColor * mix(skyColor, upDotL * lightIntensity * LIGHT_NORMALIZATION, 2.0 / 3.0) * shadowModifier;
vec3 specular = vec3(0.0);
if(upDotV > 0.0 && upDotL > 0.0) {
vec3 specularSun = brdfSpecularWater(shadingInfo, roughness, vec3(fresnelMaterial[0]), fresnelMaterial[1]);
vec3 incidentLight = lightIntensity * LIGHT_NORMALIZATION * shadow;
specular = lightingSpecularStrength * shadingInfo.NdotL * incidentLight * specularSun;
}
vec3 foam = vec3(0.0);
if(upDotV > 0.0) {
foam = foamIntensity2FoamColor(foamIntensityExternal, foamIntensity, skyZenitColor, daytimeMod);
}
float correctionViewingFactor = pow(max(dot(v, localUp), 0.0), correctionViewingPowerFactor);
vec3 normalCorrectedClouds = mix(localUp, n, correctionViewingFactor);
vec3 reflectedWorld = normalize(reflect(-v, normalCorrectedClouds));`),e.hasCloudsReflections&&r.code.add(m`vec4 cloudsColor = renderClouds(reflectedWorld, position);
cloudsColor.a = 1.0 - cloudsColor.a;
cloudsColor = pow(cloudsColor, vec4(GAMMA));
cloudsColor *= clamp(fresnelModifier.y*cloudFresnelModifier[0] - cloudFresnelModifier[1], 0.0, 1.0) * clamp((1.0 - totalFadeInOut), 0.0, 1.0);`),e.hasScreenSpaceReflections?(r.uniforms.add([new yr("view",(i,s)=>s.ssr.camera.viewMatrix),new Vt("lastFrameColorTexture",(i,s)=>s.ssr.lastFrameColorTexture),new B("fadeFactor",(i,s)=>s.ssr.fadeFactor)]),r.code.add(m`vec3 viewDir = normalize(viewPosition);
vec4 viewNormalVectorCoordinate = view *vec4(n, 0.0);
vec3 viewNormal = normalize(viewNormalVectorCoordinate.xyz);
vec4 viewUp = view * vec4(localUp, 0.0);
vec3 viewNormalCorrectedSSR = mix(viewUp.xyz, viewNormal, correctionViewingFactor);
vec3 reflected = normalize(reflect(viewDir, viewNormalCorrectedSSR));
vec3 hitCoordinate = screenSpaceIntersection(reflected, viewPosition, viewDir, viewUp.xyz);
vec3 reflectedColor = vec3(0.0);
if (hitCoordinate.z > 0.0)
{
vec2 reprojectedCoordinate = reprojectionCoordinate(hitCoordinate);
vec2 dCoords = smoothstep(0.3, 0.6, abs(vec2(0.5, 0.5) - hitCoordinate.xy));
float heightMod = smoothstep(ssrHeightFadeEnd, ssrHeightFadeStart, -viewPosition.z);
reflectionHit = clamp(1.0 - (1.3 * dCoords.y), 0.0, 1.0) * heightMod * fadeFactor;
reflectionHitDiffused = waterDiffusion * reflectionHit;
reflectedColor = linearizeGamma(texture2D(lastFrameColorTexture, reprojectedCoordinate).xyz) *
reflectionHitDiffused * fresnelModifier.y * ssrIntensity;
}
float seaColorMod =  mix(waterSeaColorMod, waterSeaColorMod * 0.5, reflectionHitDiffused);
vec3 waterRenderedColor = tonemapACES((1.0 - reflectionHitDiffused) * reflSky + reflectedColor +
reflSea * seaColorMod + specular + foam);`)):r.code.add(m`vec3 waterRenderedColor = tonemapACES(reflSky + reflSea * waterSeaColorMod + specular + foam);`),e.hasCloudsReflections?e.hasScreenSpaceReflections?r.code.add(m`return waterRenderedColor * (1.0 - (1.0 - reflectionHit) * cloudsColor.a) + (1.0 - reflectionHit) * cloudsColor.xyz;
}`):r.code.add(m`return waterRenderedColor * (1.0 - cloudsColor.a) + cloudsColor.xyz;
}`):r.code.add(m`return waterRenderedColor;
}`)}function Uh(t){const e=new Yr,{vertex:r,fragment:i}=e;Jr(r,t),e.include(ks,t),e.attributes.add(u.POSITION,"vec3"),e.attributes.add(u.UV0,"vec2");const s=new Pe("waterColor",a=>a.color);if(t.output===O.Color&&t.isDraped)return e.varyings.add("vpos","vec3"),r.uniforms.add(s),r.code.add(m`
        void main(void) {
          if (waterColor.a < ${m.float(Ue)}) {
            // Discard this vertex
            gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
            return;
          }

          vpos = position;
          gl_Position = transformPosition(proj, view, vpos);
        }
    `),i.uniforms.add(s),i.code.add(m`void main() {
gl_FragColor = waterColor;
}`),e;switch(t.output!==O.Color&&t.output!==O.Alpha||(e.include(io,t),e.include(ic,t),e.varyings.add("vuv","vec2"),e.varyings.add("vpos","vec3"),e.varyings.add("vnormal","vec3"),e.varyings.add("vtbnMatrix","mat3"),t.hasMultipassTerrain&&e.varyings.add("depth","float"),r.uniforms.add(s),r.code.add(m`
      void main(void) {
        if (waterColor.a < ${m.float(Ue)}) {
          // Discard this vertex
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
          return;
        }

        vuv = uv0;
        vpos = position;

        vnormal = getLocalUp(vpos, localOrigin);
        vtbnMatrix = getTBNMatrix(vnormal);

        ${t.hasMultipassTerrain?"depth = (view * vec4(vpos, 1.0)).z;":""}

        gl_Position = transformPosition(proj, view, vpos);
        ${t.output===O.Color?"forwardLinearDepth();":""}
      }
    `)),e.include(Gs,t),t.output){case O.Alpha:e.include(vt,t),i.uniforms.add(s),i.code.add(m`
        void main() {
          discardBySlice(vpos);
          ${t.hasMultipassTerrain?"terrainDepthTest(gl_FragCoord, depth);":""}

          gl_FragColor = vec4(waterColor.a);
        }
      `);break;case O.Color:e.include(sc,t),e.include(ac,{pbrMode:jo.Disabled,lightingSphericalHarmonicsOrder:2}),e.include(ro),e.include(vt,t),e.include(oc,t),e.include(jh,t),i.uniforms.add([s,new B("timeElapsed",a=>a.timeElapsed),r.uniforms.get("view"),r.uniforms.get("localOrigin")]),Vs(i,t),i.include(Ui),Fo(i),zo(i),i.code.add(m`
      void main() {
        discardBySlice(vpos);
        ${t.hasMultipassTerrain?"terrainDepthTest(gl_FragCoord, depth);":""}
        vec3 localUp = vnormal;
        // the created normal is in tangent space
        vec4 tangentNormalFoam = getSurfaceNormalAndFoam(vuv, timeElapsed);

        // we rotate the normal according to the tangent-bitangent-normal-Matrix
        vec3 n = normalize(vtbnMatrix * tangentNormalFoam.xyz);
        vec3 v = -normalize(vpos - cameraPosition);
        float shadow = ${t.receiveShadows?m`1.0 - readShadowMap(vpos, linearDepth)`:"1.0"};
        vec4 vPosView = view * vec4(vpos, 1.0);
        vec4 final = vec4(getSeaColor(n, v, mainLightDirection, waterColor.rgb, mainLightIntensity, localUp, shadow, tangentNormalFoam.w, vPosView.xyz, vpos + localOrigin), waterColor.w);

        // gamma correction
        gl_FragColor = delinearizeGamma(final);
        gl_FragColor = highlightSlice(gl_FragColor, vpos);
        ${t.transparencyPassType===ie.Color?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}
      }
    `);break;case O.Normal:e.include(io,t),e.include(ro,t),e.include(vt,t),e.varyings.add("vpos","vec3"),e.varyings.add("vuv","vec2"),r.uniforms.add(s),r.code.add(m`
        void main(void) {
          if (waterColor.a < ${m.float(Ue)}) {
            // Discard this vertex
            gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
            return;
          }

          vuv = uv0;
          vpos = position;

          gl_Position = transformPosition(proj, view, vpos);
        }
    `),i.uniforms.add(new B("timeElapsed",a=>a.timeElapsed)),i.code.add(m`void main() {
discardBySlice(vpos);
vec4 tangentNormalFoam = getSurfaceNormalAndFoam(vuv, timeElapsed);
tangentNormalFoam.xyz = normalize(tangentNormalFoam.xyz);
gl_FragColor = vec4((tangentNormalFoam.xyz + vec3(1.0)) * 0.5, tangentNormalFoam.w);
}`);break;case O.Highlight:e.include(Gi,t),e.varyings.add("vpos","vec3"),r.uniforms.add(s),r.code.add(m`
      void main(void) {
        if (waterColor.a < ${m.float(Ue)}) {
          // Discard this vertex
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
          return;
        }

        vpos = position;
        gl_Position = transformPosition(proj, view, vpos);
      }
    `),e.include(vt,t),i.code.add(m`void main() {
discardBySlice(vpos);
outputHighlight();
}`)}return e}const Vh=Object.freeze(Object.defineProperty({__proto__:null,build:Uh},Symbol.toStringTag,{value:"Module"}));class qi extends Rr{initializeConfiguration(e,r){r.hasWebGL2Context=e.rctx.type===ji.WEBGL2,r.spherical=e.viewingMode===Tt.Global,r.doublePrecisionRequiresObfuscation=e.rctx.driverTest.doublePrecisionRequiresObfuscation.result}initializeProgram(e){return new Er(e.rctx,qi.shader.get().build(this.configuration),Qr)}_setPipelineState(e){const r=this.configuration,i=e===ie.NONE,s=e===ie.FrontFace;return et({blending:r.output!==O.Normal&&r.output!==O.Highlight&&r.transparent?i?Ur:Wi(e):null,depthTest:{func:Js(e)},depthWrite:i?r.writeDepth?Sr:null:ko(e),colorWrite:lt,polygonOffset:i||s?null:qo(r.enableOffset)})}initializePipeline(){return this._setPipelineState(this.configuration.transparencyPassType)}}qi.shader=new Pr(Vh,()=>Cr(()=>import("./WaterSurface.glsl.dbb6e325.js"),["assets/WaterSurface.glsl.dbb6e325.js","assets/VertexColor.glsl.e3d82815.js","assets/index.3255d2a5.js","assets/index.e51050de.css","assets/requestImageUtils.828b299e.js","assets/OrderIndependentTransparency.43c6e481.js","assets/enums.3c1fa5b5.js","assets/basicInterfaces.f8f3b23b.js","assets/Texture.d66dc1cb.js","assets/VertexArrayObject.ad007c8f.js","assets/Util.3efb1a6b.js","assets/mat4f64.9070f685.js","assets/triangle.1c8f4155.js","assets/sphere.67ec4acb.js","assets/mat3f64.9180efcb.js","assets/quatf64.1dc83f1c.js","assets/lineSegment.1a0fd96e.js","assets/Indices.27b9c798.js","assets/VertexAttribute.34e3daf1.js","assets/doublePrecisionUtils.d6c628ce.js","assets/quat.eb7bbc3a.js","assets/vec3f32.4d8dc001.js","assets/BufferView.32a50625.js","assets/VertexElementDescriptor.5da9dfe9.js","assets/plane.a0a08b54.js","assets/Attribute.98e6fe67.js","assets/triangulationUtils.2ec0b7a6.js","assets/earcut.a219bf29.js","assets/deduplicate.97d7ef01.js","assets/hydratedFeatures.b4cbc12d.js","assets/InterleavedLayout.a42ad5fa.js","assets/types.bf551170.js","assets/NestedMap.2ac03b78.js","assets/Octree.449e609a.js","assets/floatRGBA.7b501bd7.js","assets/boundedPlane.91a64206.js","assets/glUtil.9de5d1d0.js"]));class ue extends Ar{constructor(){super(...arguments),this.output=O.Color,this.transparencyPassType=ie.NONE,this.spherical=!1,this.receiveShadows=!1,this.hasSlicePlane=!1,this.transparent=!1,this.enableOffset=!0,this.writeDepth=!1,this.hasScreenSpaceReflections=!1,this.doublePrecisionRequiresObfuscation=!1,this.hasCloudsReflections=!1,this.isDraped=!1,this.hasMultipassTerrain=!1,this.cullAboveGround=!1}}g([x({count:O.COUNT})],ue.prototype,"output",void 0),g([x({count:ie.COUNT})],ue.prototype,"transparencyPassType",void 0),g([x()],ue.prototype,"spherical",void 0),g([x()],ue.prototype,"receiveShadows",void 0),g([x()],ue.prototype,"hasSlicePlane",void 0),g([x()],ue.prototype,"transparent",void 0),g([x()],ue.prototype,"enableOffset",void 0),g([x()],ue.prototype,"writeDepth",void 0),g([x()],ue.prototype,"hasScreenSpaceReflections",void 0),g([x()],ue.prototype,"doublePrecisionRequiresObfuscation",void 0),g([x()],ue.prototype,"hasCloudsReflections",void 0),g([x()],ue.prototype,"isDraped",void 0),g([x()],ue.prototype,"hasMultipassTerrain",void 0),g([x()],ue.prototype,"cullAboveGround",void 0),g([x({constValue:jo.Water})],ue.prototype,"pbrMode",void 0),g([x({constValue:!0})],ue.prototype,"useCustomDTRExponentForWater",void 0),g([x({constValue:!0})],ue.prototype,"highStepCount",void 0),g([x({constValue:!1})],ue.prototype,"useFillLights",void 0);class Hh extends Hi{_updateShadowState(e){e.shadowMap.enabled!==this._material.parameters.receiveShadows&&this._material.setParameters({receiveShadows:e.shadowMap.enabled})}_updateSSRState(e){e.ssr.enabled!==this._material.parameters.hasScreenSpaceReflections&&this._material.setParameters({hasScreenSpaceReflections:e.ssr.enabled})}_updateCloudsReflectionState(e){const r=A(e.cloudsFade.data);r!==this._material.parameters.hasCloudsReflections&&this._material.setParameters({hasCloudsReflections:r})}ensureResources(e){return this._techniqueRepository.constructionContext.waterTextureRepository.ensureResources(e)}beginSlot(e){return this._output===O.Color&&(this._updateShadowState(e),this._updateSSRState(e),this._updateCloudsReflectionState(e)),this._material.setParameters(this._techniqueRepository.constructionContext.waterTextureRepository.passParameters),this.ensureTechnique(qi,e)}}class Gh extends xn{constructor(e){super(e,new Wh),this._configuration=new ue,this.animation=new _d}getConfiguration(e,r){return this._configuration.output=e,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.receiveShadows=this.parameters.receiveShadows,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.transparent=this.parameters.transparent,this._configuration.hasScreenSpaceReflections=this.parameters.hasScreenSpaceReflections,this._configuration.hasCloudsReflections=this.parameters.hasCloudsReflections,this._configuration.isDraped=this.parameters.isDraped,this._configuration.transparencyPassType=r.transparencyPassType,this._configuration.enableOffset=r.camera.relativeElevation<Xo,this._configuration.hasMultipassTerrain=r.multipassTerrain.enabled,this._configuration.cullAboveGround=r.multipassTerrain.cullAboveGround,this._configuration}update(e){const r=Math.min(e.camera.relativeElevation,e.camera.distance);this.animation.enabled=Math.sqrt(this.parameters.waveTextureRepeat/this.parameters.waveStrength)*r<Bh;const i=this.animation.advance(e);return this.setParameters({timeElapsed:el(this.animation.time)*this.parameters.animationSpeed},!1),this.animation.enabled&&i}requiresSlot(e,r){switch(r){case O.Normal:return e===W.DRAPED_WATER;case O.Color:if(this.parameters.isDraped)return e===W.DRAPED_MATERIAL;break;case O.Alpha:break;case O.Highlight:return e===W.OPAQUE_MATERIAL||e===W.DRAPED_MATERIAL;default:return!1}let i=W.OPAQUE_MATERIAL;return this.parameters.transparent&&(i=this.parameters.writeDepth?W.TRANSPARENT_MATERIAL:W.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL),e===i}createGLMaterial(e){return new Hh(e)}createBufferWriter(){return new qs(Ph)}}class Wh extends Xs{constructor(){super(...arguments),this.waveStrength=.06,this.waveTextureRepeat=32,this.waveDirection=Ns(1,0),this.waveVelocity=.05,this.flowStrength=.015,this.flowOffset=-.5,this.animationSpeed=.35,this.timeElapsed=0,this.color=_r(0,0,0,0),this.transparent=!0,this.writeDepth=!0,this.hasSlicePlane=!1,this.isDraped=!1,this.receiveShadows=!0,this.hasScreenSpaceReflections=!1,this.hasCloudsReflections=!1}}const Bh=35e3;class sa{constructor(e=0,r=0){this.from=e,this.to=r}get numElements(){return this.to-this.from}}function so(t){const e=new Map;t.forAll(i=>e.set(i.from,i));let r=!0;for(;r;)r=!1,t.forEach(i=>{const s=e.get(i.to);s&&(i.to=s.to,e.delete(s.from),t.removeUnordered(s),r=!0)})}class ao extends sa{constructor(e,r,i){super(r,i),this.geometry=e}get isVisible(){return this.geometry.visible}get hasHighlights(){return A(this.geometry.highlights)&&this.isVisible}get hasOccludees(){return A(this.geometry.occludees)}}class kh{constructor(){this.first=0,this.count=0}}class qh{constructor(){this._numElements=0,this._instances=new Map,this.holes=new rt({allocator:e=>e||new sa,deallocator:null}),this.hasHiddenInstances=!1,this.hasHighlights=!1,this.hasOccludees=!1,this.drawCommandsDirty=!0,this.drawCommandsDefault=oi(),this.drawCommandsHighlight=oi(),this.drawCommandsOccludees=oi(),this.drawCommandsShadowHighlightRest=oi()}get numElements(){return this._numElements}get instances(){return this._instances}addInstance(e,r){this.deleteInstance(e),this._instances.set(e,r),this._numElements+=r.numElements}deleteInstance(e){const r=this._instances.get(e);r&&(this._numElements-=r.numElements,this._instances.delete(e))}updateInstance(e,r,i){const s=this._instances.get(e);s&&(this._numElements-=s.numElements,s.from=r,s.to=i,this._numElements+=s.numElements)}updateDrawState(e){e.isVisible?(e.hasHighlights&&(this.hasHighlights=!0),e.hasOccludees&&(this.hasOccludees=!0)):this.hasHiddenInstances=!0}updateDrawCommands(e){if(this.drawCommandsDefault.clear(),this.drawCommandsHighlight.clear(),this.drawCommandsOccludees.clear(),this.drawCommandsShadowHighlightRest.clear(),this.drawCommandsDirty=!1,this._instances.size===0)return;if(!this.needsMultipleCommands()){const i=this.drawCommandsDefault.pushNew(),s=this.holes.front();return A(this.vao)&&this.holes.length===1&&s.to===Math.floor(this.vao.size/e)?(i.first=0,void(i.count=s.from)):(i.first=1/0,i.count=0,this._instances.forEach(a=>{i.first=Math.min(i.first,a.from),i.count=Math.max(i.count,a.to)}),void(i.count-=i.first))}const r=Array.from(this._instances.values()).sort((i,s)=>i.from===s.from?i.to-s.to:i.from-s.from);for(const i of r)i.isVisible&&(oo(i.hasOccludees?this.drawCommandsOccludees:this.drawCommandsDefault,i),oo(i.hasHighlights?this.drawCommandsHighlight:this.drawCommandsShadowHighlightRest,i))}needsMultipleCommands(){return this.hasOccludees||this.hasHighlights||this.hasHiddenInstances}}function Xh(t){return A(t.vao)}function oi(){return new rt({allocator:t=>t||new kh,deallocator:t=>t})}function oo(t,e){const r=t.back();if(r==null){const i=t.pushNew();return i.first=e.from,void(i.count=e.numElements)}if(Zh(r,e)){const i=e.from-r.first+e.numElements;r.count=i}else{const i=t.pushNew();i.first=e.from,i.count=e.numElements}}function Zh(t,e){return t.first+t.count>=e.from}class Yh{constructor(e){this.origin=e,this.buffers=new Array}dispose(){this.buffers.forEach(e=>e.vao.dispose()),this.buffers.length=0}findBuffer(e){return this.buffers.find(r=>r.instances.has(e))}}const Jh=rl+1;class Qh{constructor(e,r,i){this._rctx=e,this._locations=r,this._layout=i,this._cache=e.newCache(`VaoCache ${zs()}`,Kh)}dispose(){this._cache.destroy()}newVao(e){const r=e.toString(),i=this._cache.pop(r);if(A(i)){const a=i.pop();return i.length>0&&this._cache.put(r,i,e*i.length,Jh),a}const s=new nc(this._rctx,this._locations,{geometry:this._layout},{geometry:en.createVertex(this._rctx,Qo.STATIC_DRAW)});return s.vertexBuffers.geometry.setSize(e),s}deleteVao(e){if(N(e))return null;const r=e.size,i=r.toString(),s=this._cache.pop(i);return A(s)?(s.push(e),this._cache.put(i,s,r*s.length,-1)):this._cache.put(i,[e],r,-1),null}}function Kh(t,e){if(e===tl.ALL)return void t.forEach(s=>s.dispose());const r=t.pop(),i=t.length*r.size;return r.dispose(),i}class eu{constructor(e,r,i){this._rctx=e,this._materialRepository=r,this.material=i,this._dataByOrigin=new Map,this._appleAmdDriverHelper=null,this._hasHighlights=!1,this._hasOccludees=!1,this._glMaterials=new Ah(this.material,this._materialRepository),this._bufferWriter=i.createBufferWriter(),this._vaoCache=new Qh(e,i.vertexAttributeLocations,Kc(this._bufferWriter.vertexBufferLayout)),this._rctx.driverTest.drawArraysRequiresIndicesTypeReset.result&&(this._appleAmdDriverHelper=new bh(this._rctx))}dispose(){var e;this._glMaterials.destroy(),this._dataByOrigin.forEach(r=>r.dispose()),this._dataByOrigin.clear(),this._vaoCache.dispose(),(e=this._appleAmdDriverHelper)==null||e.dispose()}get isEmpty(){return this._dataByOrigin.size===0}get hasHighlights(){return this._hasHighlights}get hasOccludees(){return this._hasOccludees}get hasWater(){return!this.isEmpty&&this.material instanceof Gh}get rendersOccluded(){return!this.isEmpty&&this.material.renderOccluded!==xt.Occlude}get numGeometries(){let e=0;return this._dataByOrigin.forEach(r=>e+=r.buffers.reduce((i,s)=>i+s.instances.size,0)),e}forEachGeometry(e){this._dataByOrigin.forEach(r=>r.buffers.forEach(i=>i.instances.forEach(s=>e(s.geometry))))}modify(e){this._updateGeometries(e.updates),this._addAndRemoveGeometries(e.adds,e.removes),this._updateDrawCommands()}_updateGeometries(e){var s;const r=this._bufferWriter,i=r.vertexBufferLayout.stride/4;for(const a of e){const o=a.renderGeometry,n=(s=this._dataByOrigin.get(o.localOrigin.id))==null?void 0:s.findBuffer(o.id);if(N(n))return;const l=n.instances.get(o.id);if(a.updateType&(Ke.GEOMETRY|Ke.TRANSFORMATION)){const c=di(r.elementCount(l.geometry.geometry)*i),d=r.vertexBufferLayout.createView(c.buffer);this._writeGeometry(o,d,0),n.vao.vertexBuffers.geometry.setSubData(c,l.from*i,0,l.numElements*i)}a.updateType&(Ke.HIGHLIGHT|Ke.OCCLUDEE|Ke.VISIBILITY)&&(n.drawCommandsDirty=!0)}}_computeDeltas(e,r){var s;const i=new Ks;for(const a of e){const o=a.localOrigin;if(N(o))continue;let n=i.get(o.id,null);N(n)&&(n=new no(o.vec3),i.set(o.id,null,n)),n.changes.push(a)}for(const a of r){const o=a.localOrigin;if(N(o))continue;const n=(s=this._dataByOrigin.get(o.id))==null?void 0:s.findBuffer(a.id);if(N(n))continue;let l=i.get(o.id,n);N(l)&&(l=new no(o.vec3),i.set(o.id,n,l)),l.changes.push(a)}return i}_addAndRemoveGeometries(e,r){const{_bufferWriter:i,_dataByOrigin:s}=this,a=i.vertexBufferLayout.stride/4,o=this._computeDeltas(e,r);o.forEach((n,l)=>{const c=n.get(null),d=A(c)?c.changes:[];o.delete(l,null);let f=s.get(l);if(n.forEach((p,h)=>{if(o.delete(l,h),N(h))return void Oe(!1,"No VAO for removed geometries");if(h.instances.size===p.changes.length)return this._vaoCache.deleteVao(h.vao),fa(f.buffers,h),void(f.buffers.length===0&&d.length===0&&s.delete(l));const v=h.numElements,_=h.vao.size/4,S=d.reduce((R,C)=>R+i.elementCount(C.geometry),0),T=p.changes.reduce((R,C)=>R+i.elementCount(C.geometry),0),w=Math.min((v+S-T)*a,ci),y=w>_;w>Ii&&w<_/2?(p.changes.forEach(({id:R})=>h.deleteInstance(R)),h.instances.forEach(({geometry:R})=>d.push(R)),this._vaoCache.deleteVao(h.vao),fa(f.buffers,h)):y?this._applyAndRebuild(h,d,p):this._applyRemoves(h,p)}),d.length>0)for(N(f)&&(f=new Yh(c.origin),s.set(l,f)),f.buffers.forEach(p=>this._applyAdds(p,d));d.length>0;)f.buffers.push(this._applyAndRebuild(new qh,d,null))})}_updateDrawCommands(){this._hasHighlights=!1,this._hasOccludees=!1,this._dataByOrigin.forEach(e=>{e.buffers.forEach(r=>{r.drawCommandsDirty&&(r.hasHiddenInstances=!1,r.hasHighlights=!1,r.hasOccludees=!1,ot(r.instances,i=>(r.updateDrawState(i),r.hasHiddenInstances&&r.hasHighlights&&r.hasOccludees)),r.updateDrawCommands(this._bufferWriter.vertexBufferLayout.stride)),this._hasHighlights=this._hasHighlights||r.hasHighlights,this._hasOccludees=this._hasOccludees||r.hasOccludees})})}_applyAndRebuild(e,r,i){if(A(i))for(const v of i.changes)e.deleteInstance(v.id);const s=this._bufferWriter,a=s.vertexBufferLayout.stride,o=a/4,n=Math.floor(ci/o);let l=e.numElements;for(;r.length>0;){const v=r.pop(),_=s.elementCount(v.geometry);if(l+_>n&&l>0){r.push(v);break}l+=_;const S=new ao(v,0,0);Oe(e.instances.get(v.id)==null),e.addInstance(v.id,S)}const c=l*o,d=di(c),f=s.vertexBufferLayout.createView(d.buffer);let p=0;e.hasHiddenInstances=!1,e.hasHighlights=!1,e.hasOccludees=!1,e.instances.forEach((v,_)=>{this._writeGeometry(v.geometry,f,p);const S=p;p+=s.elementCount(v.geometry.geometry),e.updateInstance(_,S,p),e.updateDrawState(v)}),this._vaoCache.deleteVao(e.vao),e.vao=this._vaoCache.newVao(co(c)),e.vao.vertexBuffers.geometry.setSubData(d,0,0,p*o),e.holes.clear();const h=e.holes.pushNew();return h.from=p,h.to=Math.floor(e.vao.size/a),e.updateDrawCommands(a),e}_applyRemoves(e,r){if(r.changes.length===0)return;for(const n of r.changes){const l=n.id,c=e.instances.get(l);if(!c)continue;e.deleteInstance(l);const d=Ye.back();if(d){if(d.to===c.from){d.to=c.to;continue}if(d.from===c.to){d.from=c.from;continue}}const f=Ye.pushNew();f.from=c.from,f.to=c.to}so(Ye);const i=this._bufferWriter.vertexBufferLayout.stride/4,s=Ye.reduce((n,l)=>Math.max(n,l.numElements),0)*i,a=di(s);a.fill(0,0,s);const o=e.vao.vertexBuffers.geometry;Ye.forAll(n=>o.setSubData(a,n.from*i,0,n.numElements*i)),e.holes.pushArray(Ye.data,Ye.length),Ye.forAll((n,l)=>Ye.data[l]=null),Ye.clear(),e.drawCommandsDirty=!0}_applyAdds(e,r){if(r.length===0)return;if(!Xh(e))return void this._applyAndRebuild(e,r,null);const i=this._bufferWriter,s=i.vertexBufferLayout.stride/4,a=e.numElements,o=r.reduce((T,w)=>T+i.elementCount(w.geometry),0),n=Math.min((a+o)*s,ci),l=4*n;if(e.vao.size<co(ci-Ii)&&l>e.vao.size)return void this._applyAndRebuild(e,r,null);so(e.holes);const c=new Array;for(const T of r){const w=i.elementCount(T.geometry),y=tu(e.holes,w);c.push(y)}const d=e.vao.vertexBuffers.geometry;let f=0,p=0,h=0;const v=di(n),_=i.vertexBufferLayout.createView(v.buffer);r.forEach((T,w)=>{const y=c[w];if(N(y))return;if(h!==y){const b=h-p;b>0&&d.setSubData(v,p*s,0,b*s),p=y,f=0}const R=i.elementCount(T.geometry);this._writeGeometry(T,_,f),f+=R,h=y+R;const C=new ao(T,y,y+R);Oe(e.instances.get(T.id)==null),e.addInstance(T.id,C),e.drawCommandsDirty=!0});const S=h-p;S>0&&d.setSubData(v,p*s,0,S*s),il(r,(T,w)=>N(c[w]))}_writeGeometry(e,r,i){const s=e.localOrigin.vec3;$c(lo,-s[0],-s[1],-s[2]);const a=jt(ru,lo,e.transformation);dr(ni,a),Ao(ni,ni),this._bufferWriter.write(a,ni,e.geometry,r,i)}updateAnimation(e){return this.material.update(e)}requiresSlot(e,r){return this.material.requiresSlot(e,r)}render(e,r){var c;if(!this.requiresSlot(r.slot,e))return!1;const i=e===O.Highlight||e===O.ShadowHighlight;if(i&&!this._hasHighlights)return!1;const s=e===O.ShadowExcludeHighlight,a=!(i||s),o=this._rctx;let n;const l=()=>{if(A(n))return n;const d=this._glMaterials.load(o,r.slot,e);return N(d)?null:(n=d.beginSlot(r),N(n)?null:(o.bindTechnique(n,this.material.parameters,r),n))};(c=this._appleAmdDriverHelper)==null||c.resetIndicesType();for(const d of this._dataByOrigin.values())for(const f of d.buffers){if(i&&!f.hasHighlights)continue;const p=(i?f.drawCommandsHighlight:s&&f.needsMultipleCommands()?f.drawCommandsShadowHighlightRest:f.drawCommandsDefault)||null,h=a&&f.drawCommandsOccludees||null;if((p==null?void 0:p.length)||(h==null?void 0:h.length)){const v=l();if(N(v))return!1;v.program.bindDraw(new Rh(d.origin),r,this.material.parameters),v.ensureAttributeLocations(f.vao),o.bindVAO(f.vao),p!=null&&p.length&&(v.bindPipelineState(o,r.slot,!1),p.forAll(_=>o.drawArrays(v.primitiveType,_.first,_.count))),h!=null&&h.length&&(v.bindPipelineState(o,r.slot,!0),h.forAll(_=>o.drawArrays(v.primitiveType,_.first,_.count)))}}return A(n)}get test(){return{material:this.material,glMaterials:this._glMaterials,dataByOrigin:this._dataByOrigin}}}class no{constructor(e){this.origin=e,this.changes=new Array}}function tu(t,e){let r;if(!t.some(s=>!(s.numElements<e)&&(r=s,!0)))return null;const i=r.from;return r.from+=e,r.from>=r.to&&t.removeUnordered(r),i}const lo=Y(),ru=Y(),ni=Y(),Ye=new rt({allocator:t=>t||new sa,deallocator:null}),Ii=65536,li=4*Ii,On=16777216,ci=On/4;let fs=new Float32Array(Ii);function di(t){return fs.length<t&&(fs=new Float32Array(t)),fs}function co(t){const e=4*t;return e<li?li:Math.max(Math.min(Math.ceil(1.5*e/li)*li,On),e)}let ze=class extends Ls{constructor(t){super(t),this._pending=new iu,this._changes=new yh,this._materialRenderers=new Map,this._sortedMaterialRenderers=new rt,this._geometries=new Map,this._hasHighlights=!1,this._hasWater=!1}destroy(){this._changes.prune(),this._materialRenderers.forEach(t=>t.dispose()),this._materialRenderers.clear(),this._sortedMaterialRenderers.clear(),this._geometries.clear()}get updating(){return!this._pending.empty||this._changes.updates.length>0}get rctx(){return this.rendererContext.rctx}get _materialRepository(){return this.rendererContext.materialRepository}get _localOriginFactory(){return this.rendererContext.localOriginFactory}get hasHighlights(){return this._hasHighlights}get hasWater(){return this._hasWater}get rendersOccluded(){return ot(this._materialRenderers,t=>t.rendersOccluded)}get isEmpty(){return!this.updating&&this._materialRenderers.size===0&&this._geometries.size===0}commitChanges(){if(!this.updating)return!1;this._processAddsRemoves();const t=Ch(this._changes);let e=!1,r=!1,i=!1;return t.forEach((s,a)=>{let o=this._materialRenderers.get(a);if(!o&&s.adds.length>0&&(o=new eu(this.rctx,this._materialRepository,a),this._materialRenderers.set(a,o),e=!0,r=!0,i=!0),!o)return;const n=r||o.hasHighlights,l=i||o.hasWater;o.modify(s),r=r||n!==o.hasHighlights,i=i||l!==o.hasWater,o.isEmpty&&(this._materialRenderers.delete(a),o.dispose(),e=!0)}),this._changes.clear(),e&&this._updateSortedMaterialRenderers(),r&&(this._hasHighlights=ot(this._materialRenderers,s=>s.hasHighlights)),i&&(this._hasWater=ot(this._materialRenderers,s=>s.hasWater)),this.notifyChange("updating"),!0}addGeometries(t,e){if(t.length===0)return;const r=this._validateRenderGeometries(t);for(const s of r)this._geometries.set(s.id,s);const i=this._pending.empty;for(const s of r)this._pending.adds.add(s);i&&this.notifyChange("updating"),e===Ri.UPDATE&&this._notifyGraphicGeometryChanged(t)}removeGeometries(t,e){const r=this._pending.empty,i=this._pending.adds;for(const s of t)i.has(s)?(this._pending.removed.add(s),i.delete(s)):this._pending.removed.has(s)||this._pending.removes.add(s),this._geometries.delete(sl(s.id));r&&!this._pending.empty&&this.notifyChange("updating"),e===Ri.UPDATE&&this._notifyGraphicGeometryChanged(t)}modifyGeometries(t,e){const r=this._changes.updates.length===0;for(const i of t){const s=this._changes.updates.pushNew();s.renderGeometry=this._validateRenderGeometry(i),s.updateType=e}switch(r&&this._changes.updates.length>0&&this.notifyChange("updating"),e){case Ke.TRANSFORMATION:case Ke.GEOMETRY:return this._notifyGraphicGeometryChanged(t);case Ke.VISIBILITY:return this._notifyGraphicVisibilityChanged(t)}}updateAnimation(t){let e=!1;return this._sortedMaterialRenderers.forAll(r=>e=r.updateAnimation(t)||e),e}render(t){this._sortedMaterialRenderers.forAll(e=>{e.material.shouldRender(t)&&e.render(t.output,t.bindParameters)})}intersect(t,e,r,i,s){return this._geometries.forEach(a=>{if(i&&!i(a))return;this._intersectRenderGeometry(a,r,e,0,t,s);const o=this.rendererContext.longitudeCyclical;o&&(a.boundingSphere[0]-a.boundingSphere[3]<o.min&&this._intersectRenderGeometry(a,r,e,o.range,t,s),a.boundingSphere[0]+a.boundingSphere[3]>o.max&&this._intersectRenderGeometry(a,r,e,-o.range,t,s)),s++}),s}_updateSortedMaterialRenderers(){this._sortedMaterialRenderers.clear();let t=0;this._materialRenderers.forEach((e,r)=>{r.insertOrder=t++,this._sortedMaterialRenderers.push(e)}),this._sortedMaterialRenderers.sort((e,r)=>{const i=r.material.renderPriority-e.material.renderPriority;return i!==0?i:e.material.insertOrder-r.material.insertOrder})}_processAddsRemoves(){this._changes.adds.clear(),this._changes.removes.clear(),this._changes.adds.pushArray(Array.from(this._pending.adds)),this._changes.removes.pushArray(Array.from(this._pending.removes));for(let t=0;t<this._changes.updates.length;){const e=this._changes.updates.data[t];this._pending.has(e.renderGeometry)?this._changes.updates.removeUnorderedIndex(t):t++}this._pending.clear()}_intersectRenderGeometry(t,e,r,i,s,a){if(!t.visible)return;let o=0;i+=t.transformation[12],o=t.transformation[13],ms[0]=r[0]-i,ms[1]=r[1]-o,t.screenToWorldRatio=this.rendererContext.screenToWorldRatio,t.material.intersectDraped(t,null,s,ms,(n,l,c)=>{su(e,c,t.material.renderPriority,a,s,t.layerUid,t.graphicUid)},e)}_notifyGraphicGeometryChanged(t){if(N(this.drapeSource.notifyGraphicGeometryChanged))return;let e;for(const r of t){const i=r.graphicUid;A(i)&&i!==e&&(this.drapeSource.notifyGraphicGeometryChanged(i),e=i)}}_notifyGraphicVisibilityChanged(t){if(N(this.drapeSource.notifyGraphicVisibilityChanged))return;let e;for(const r of t){const i=r.graphicUid;A(i)&&i!==e&&(this.drapeSource.notifyGraphicVisibilityChanged(i),e=i)}}_validateRenderGeometries(t){for(const e of t)this._validateRenderGeometry(e);return t}_validateRenderGeometry(t){return N(t.localOrigin)&&(t.localOrigin=this._localOriginFactory.getOrigin(t.boundingSphere)),t}get test(){return{sortedMaterialRenderers:this._sortedMaterialRenderers}}};g([L()],ze.prototype,"drapeSource",void 0),g([L()],ze.prototype,"updating",null),g([L()],ze.prototype,"rctx",null),g([L()],ze.prototype,"rendererContext",void 0),g([L()],ze.prototype,"_materialRepository",null),g([L()],ze.prototype,"_localOriginFactory",null),g([L({readOnly:!0})],ze.prototype,"isEmpty",null),g([L()],ze.prototype,"_materialRenderers",void 0),g([L()],ze.prototype,"_geometries",void 0),ze=g([Fi("esri.views.3d.webgl-engine.lib.SortedRenderGeometryRenderer")],ze);class iu{constructor(){this.adds=new Set,this.removes=new Set,this.removed=new Set}get empty(){return this.adds.size===0&&this.removes.size===0&&this.removed.size===0}has(e){return this.adds.has(e)||this.removes.has(e)||this.removed.has(e)}clear(){this.adds.clear(),this.removes.clear(),this.removed.clear()}}function su(t,e,r,i,s,a,o){const n=new _h(a,o,e),l=c=>{c.set(Ct.OVERLAY,n,t.dist,t.normal,t.transformation,r,i)};if((s.results.min.drapedLayerOrder==null||r>=s.results.min.drapedLayerOrder)&&(s.results.min.dist==null||s.results.ground.dist<=s.results.min.dist)&&l(s.results.min),s.options.store!==Wt.MIN&&(s.results.max.drapedLayerOrder==null||r<s.results.max.drapedLayerOrder)&&(s.results.max.dist==null||s.results.ground.dist>s.results.max.dist)&&l(s.results.max),s.options.store===Wt.ALL){const c=Th(s.ray);l(c),s.results.all.push(c)}}const ms=K();class Xi extends Rr{initializeProgram(e){return new Er(e.rctx,Xi.shader.get().build(),Qr)}initializePipeline(){return this.configuration.hasAlpha?et({blending:Zo(tt.SRC_ALPHA,tt.ONE,tt.ONE_MINUS_SRC_ALPHA,tt.ONE_MINUS_SRC_ALPHA),colorWrite:lt}):et({colorWrite:lt})}}Xi.shader=new Pr(lc,()=>Cr(()=>import("./TextureOnly.glsl.a9c500e6.js"),["assets/TextureOnly.glsl.a9c500e6.js","assets/index.3255d2a5.js","assets/index.e51050de.css","assets/OrderIndependentTransparency.43c6e481.js","assets/enums.3c1fa5b5.js","assets/basicInterfaces.f8f3b23b.js","assets/VertexAttribute.34e3daf1.js","assets/VertexColor.glsl.e3d82815.js","assets/requestImageUtils.828b299e.js","assets/Texture.d66dc1cb.js","assets/VertexArrayObject.ad007c8f.js","assets/Util.3efb1a6b.js","assets/mat4f64.9070f685.js","assets/triangle.1c8f4155.js","assets/sphere.67ec4acb.js","assets/mat3f64.9180efcb.js","assets/quatf64.1dc83f1c.js","assets/lineSegment.1a0fd96e.js","assets/Indices.27b9c798.js","assets/doublePrecisionUtils.d6c628ce.js","assets/quat.eb7bbc3a.js","assets/vec3f32.4d8dc001.js","assets/BufferView.32a50625.js","assets/VertexElementDescriptor.5da9dfe9.js"]));class Tn extends Do{constructor(){super(...arguments),this.hasAlpha=!1}}g([x()],Tn.prototype,"hasAlpha",void 0);let Je=class extends Ls{get _bindParameters(){return this._renderContext.bindParameters}get rctx(){return this._rctx}get materialRepository(){return this._materialRepository}get screenToWorldRatio(){return this._screenToWorldRatio}get localOriginFactory(){return this._localOriginFactory}constructor(t){super(t),this._overlays=null,this._overlayRenderTarget=null,this._hasHighlights=!1,this._rendersOccluded=!1,this._hasWater=!1,this._handles=new Co,this._renderers=new Map,this._sortedDrapeSourceRenderersDirty=!1,this._sortedRenderers=new rt,this._passParameters=new cc,this._rctx=null,this._materialRepository=null,this._screenToWorldRatio=1,this._localOriginFactory=null,this._camera=new V,this.worldToPCSRatio=1,this.events=new To,this.longitudeCyclical=null}initialize(){const t=this.view._stage.renderView;this._rctx=t.renderingContext;const e=t.waterTextureRepository;this._stippleTextureRepository=new Sd(t.renderingContext),this._shaderTechniqueRepository=new ld({rctx:this._rctx,viewingMode:Tt.Local,stippleTextureRepository:this._stippleTextureRepository,waterTextureRepository:e}),this._renderContext=new ah(this._rctx,new oh(this._rctx,this.view.state.viewingMode),new dc(this.view,this._shaderTechniqueRepository,this._rctx,()=>{})),this._handles.add([Ki(()=>e.updating,()=>this.events.emit("content-changed"),ma),Ki(()=>this.spatialReference,r=>this._localOriginFactory=new Qd(r),ma),al(()=>this.view.allLayerViews,"after-changes",()=>this._sortedDrapeSourceRenderersDirty=!0)]),this._materialRepository=new md(t.textureRepository,this._shaderTechniqueRepository,r=>{(r.renderOccluded&ho)>0!==this._rendersOccluded&&this._updateRendersOccluded(),this.events.emit("content-changed"),this.notifyChange("updating"),this.notifyChange("isEmpty")},()=>this.events.emit("content-changed")),this._bindParameters.slot=W.DRAPED_MATERIAL,this._bindParameters.highlightDepthTexture=hc(this._rctx),this._camera.near=1,this._camera.far=1e4,this._camera.relativeElevation=null,this._bindParameters.camera=this._camera,this._bindParameters.transparencyPassType=ie.NONE,this._bindParameters.newLighting.noonFactor=0,this._bindParameters.newLighting.globalFactor=0,this._bindParameters.newLighting.set([new uc(Gr(1,1,1))]),this._handles.add(this.view.resourceController.scheduler.registerTask(ol.STAGE,this))}destroy(){this._handles.destroy(),this._renderers.forEach(t=>t.destroy()),this._renderers.clear(),this._debugTextureTechnique=nl(this._debugTextureTechnique),this._passParameters.texture=We(this._passParameters.texture),this._bindParameters.highlightDepthTexture=We(this._bindParameters.highlightDepthTexture),this._shaderTechniqueRepository=bo(this._shaderTechniqueRepository),this._temporaryFBO=We(this._temporaryFBO),this._quadVAO=We(this._quadVAO),this.disposeOverlays()}get updating(){return this._sortedDrapeSourceRenderersDirty||ot(this._renderers,t=>t.updating)}get hasOverlays(){return A(this._overlays)&&A(this._overlayRenderTarget)}get gpuMemoryUsage(){return A(this._overlayRenderTarget)?this._overlayRenderTarget.gpuMemoryUsage:0}createGeometryDrapeSourceRenderer(t){return this.createDrapeSourceRenderer(t,ze)}createDrapeSourceRenderer(t,e,r){const i=this._renderers.get(t);A(i)&&i.destroy();const s=new e({...r,rendererContext:this,drapeSource:t});return this._renderers.set(t,s),this._sortedDrapeSourceRenderersDirty=!0,"fullOpacity"in t&&this._handles.add(Ki(()=>t.fullOpacity,()=>this.events.emit("content-changed")),t),s}removeDrapeSourceRenderer(t){if(N(t))return;const e=this._renderers.get(t);N(e)||(this._sortedDrapeSourceRenderersDirty=!0,this._renderers.delete(t),this._handles.remove(t),e.destroy())}collectUnusedRenderTargetMemory(t){let e=!1;if(A(this._overlayRenderTarget))for(const r of this._overlayRenderTarget.renderTargets){const[i,s]=this.overlays,a=i.validTargets[r.type]||!s.validTargets[r.type];e=this._overlayRenderTarget.validateUsageForTarget(a,r,t)||e}return e}get overlays(){return ae(this._overlays,[])}ensureDrapeTargets(t){A(this._overlays)&&this._overlays.forEach(e=>e.hasTargetWithoutRasterImage=es(t,r=>r.drapeTargetType===Ps.WithoutRasterImage))}ensureDrapeSources(t){A(this._overlays)&&this._overlays.forEach(e=>{e.hasDrapedFeatureSource=es(t,r=>r.drapeSourceType===Hr.Features),e.hasDrapedRasterSource=es(t,r=>r.drapeSourceType===Hr.RasterImage)})}ensureOverlays(t,e){N(this._overlays)&&(this._overlayRenderTarget=new od(this._rctx),this._overlays=[new Fa(ur.INNER,this._overlayRenderTarget),new Fa(ur.OUTER,this._overlayRenderTarget)]),this.ensureDrapeTargets(t),this.ensureDrapeSources(e)}disposeOverlays(){this._overlays=null,this._overlayRenderTarget=We(this._overlayRenderTarget),this.events.emit("textures-disposed")}get running(){return this.updating}runTask(t){this._processDrapeSources(t,()=>!0)}_processDrapeSources(t,e){let r=!1;for(const[i,s]of this._renderers){if(t.done)break;(i.destroyed||e(i))&&s.commitChanges()&&(r=!0,t.madeProgress())}this._sortedDrapeSourceRenderersDirty&&(this._sortedDrapeSourceRenderersDirty=!1,r=!0,this._updateSortedDrapeSourceRenderers()),r&&(A(this._overlays)&&this._renderers.size===0&&this.disposeOverlays(),this.notifyChange("updating"),this.notifyChange("isEmpty"),this.events.emit("content-changed"),this._updateHasHighlights(),this._updateRendersOccluded(),this._updateHasWater())}processSyncDrapeSources(){this._processDrapeSources(ll,t=>t.updatePolicy===kr.SYNC)}get isEmpty(){return!As.OVERLAY_DRAW_DEBUG_TEXTURE&&!ot(this._renderers,t=>!t.isEmpty)}get hasHighlights(){return this._hasHighlights}get hasWater(){return this._hasWater}get rendersOccluded(){return this._rendersOccluded}updateAnimation(t){let e=!1;return this._renderers.forEach(r=>e=r.updateAnimation(t)||e),e}updateDrapeSourceOrder(){this._sortedDrapeSourceRenderersDirty=!0}drawTarget(t,e,r){const i=t.canvasGeometries;if(i.numViews===0)return!1;this._screenToWorldRatio=r*t.mapUnitsPerPixel;const s=e.output;if(this.isEmpty||s===O.Highlight&&!this.hasHighlights||s===O.Normal&&!this.hasWater||!t.hasSomeSizedView())return!1;const a=e.fbo;if(!a.isValid())return!1;const o=2*t.resolution,n=t.resolution;a.resize(o,n);const l=this._rctx;if(this._camera.pixelRatio=t.pixelRatio*r,this._renderContext.output=s,this._bindParameters.screenToWorldRatio=this._screenToWorldRatio,this._bindParameters.screenToPCSRatio=this._screenToWorldRatio*this.worldToPCSRatio,this._bindParameters.slot=s===O.Normal?W.DRAPED_WATER:W.DRAPED_MATERIAL,t.applyViewport(this._rctx),a.bind(l),t.index===ur.INNER&&(l.setClearColor(0,0,0,0),l.clearSafe(bi.COLOR_BUFFER_BIT)),e.type===ee.Occluded&&(this._renderContext.renderOccludedMask=ho),As.OVERLAY_DRAW_DEBUG_TEXTURE&&e.type!==ee.Occluded)for(let c=0;c<i.numViews;c++)this._setViewParameters(i.extents[c],t),this._drawDebugTexture(t.resolution,ou[t.index]);return this._renderers.size>0&&this._sortedRenderers.forAll(({drapeSource:c,renderer:d})=>{if(e.type===ee.ColorNoRasterImage&&c.drapeSourceType===Hr.RasterImage)return;const{fullOpacity:f}=c,p=A(f)&&f<1&&s===O.Color;p&&(this.bindTemporaryFramebuffer(this._rctx,o,n),l.clearSafe(bi.COLOR_BUFFER_BIT));for(let h=0;h<i.numViews;h++)this._setViewParameters(i.extents[h],t),d.render(this._renderContext);p&&A(this._temporaryFBO)&&(a.bind(l),this.view._stage.renderView.compositingHelper.compositeOverlay(this._renderContext.bindParameters,this._temporaryFBO.getTexture(),f,t.index))}),l.bindFramebuffer(null),a.generateMipMap(),this._renderContext.resetRenderOccludedMask(),!0}bindTemporaryFramebuffer(t,e,r){N(this._temporaryFBO)&&(this._temporaryFBO=new on(t,!1)),this._temporaryFBO.resize(e,r),this._temporaryFBO.bind(t)}async reloadShaders(){await this._shaderTechniqueRepository.reloadAll()}notifyContentChanged(){this.events.emit("content-changed")}intersect(t,e,r,i){var a,o;let s=0;for(const n of this._renderers.values())s=(o=(a=n.intersect)==null?void 0:a.call(n,t,e,r,i,s))!=null?o:s}_updateSortedDrapeSourceRenderers(){if(this._sortedRenderers.clear(),this._renderers.size===0)return;const t=this.view.map.allLayers;this._renderers.forEach((e,r)=>{var o;const i=t.indexOf(r.layer),s=i>=0,a=this._renderers.size*((o=r.renderGroup)!=null?o:s?Ai.MapLayer:Ai.ViewLayer)+(s?i:0);this._sortedRenderers.push(new au(r,e,a))}),this._sortedRenderers.sort((e,r)=>e.index-r.index)}_setViewParameters(t,e){const r=this._camera;r.viewport=[0,0,e.resolution,e.resolution],cl(r.projectionMatrix,0,t[2]-t[0],0,t[3]-t[1],r.near,r.far),dl(r.viewMatrix,[-t[0],-t[1],0])}_updateHasWater(){const t=ot(this._renderers,e=>e.hasWater);t!==this._hasWater&&(this._hasWater=t,this.events.emit("has-water",t))}_updateHasHighlights(){const t=ot(this._renderers,e=>e.hasHighlights);t!==this._hasHighlights&&(this._hasHighlights=t,this.events.emit("has-highlights",t))}_updateRendersOccluded(){const t=ot(this._renderers,e=>e.rendersOccluded);t!==this._rendersOccluded&&(this._rendersOccluded=t,this.events.emit("renders-occluded",t))}_drawDebugTexture(t,e){this._ensureDebugPatternResources(t,t,e);const r=this._rctx;r.bindTechnique(this._debugTextureTechnique,this._passParameters,null),r.bindVAO(this._quadVAO),r.drawArrays(Ht.TRIANGLE_STRIP,0,Xc(this._quadVAO,"geometry"))}_ensureDebugPatternResources(t,e,r){if(H(this._passParameters.color,r[0],r[1],r[2]),this._passParameters.texture)return;const i=new Uint8Array(t*e*4);let s=0;for(let o=0;o<e;o++)for(let n=0;n<t;n++){const l=Math.floor(n/10),c=Math.floor(o/10);l<2||c<2||10*l>t-20||10*c>e-20?(i[s++]=255,i[s++]=255,i[s++]=255,i[s++]=255):(i[s++]=255,i[s++]=255,i[s++]=255,i[s++]=1&l&&1&c?1&n^1&o?0:255:1&l^1&c?0:128)}this._passParameters.texture=new or(this._rctx,{target:Vr.TEXTURE_2D,pixelFormat:wr.RGBA,dataType:Br.UNSIGNED_BYTE,samplingMode:Ci.NEAREST,width:t,height:e},i);const a=new Tn;a.hasAlpha=!0,this._debugTextureTechnique=this._shaderTechniqueRepository.acquire(Xi,a),this._quadVAO=pc(this._rctx)}get test(){return{drapedRenderers:Array.from(this._renderers.values()),getDrapeSourceRenderer:t=>this._renderers.get(t)}}};g([L()],Je.prototype,"_sortedDrapeSourceRenderersDirty",void 0),g([L({autoDestroy:!0})],Je.prototype,"_shaderTechniqueRepository",void 0),g([L({autoDestroy:!0})],Je.prototype,"_stippleTextureRepository",void 0),g([L({constructOnly:!0})],Je.prototype,"view",void 0),g([L()],Je.prototype,"worldToPCSRatio",void 0),g([L()],Je.prototype,"spatialReference",void 0),g([L({type:Boolean,readOnly:!0})],Je.prototype,"updating",null),g([L()],Je.prototype,"isEmpty",null),Je=g([Fi("esri.views.3d.terrain.OverlayRenderer")],Je);class au{constructor(e,r,i){this.drapeSource=e,this.renderer=r,this.index=i}}const ou=[[1,.5,.5],[.5,.5,1]],nu=-2,ho=xt.OccludeAndTransparent;var Is;(function(t){function e(o,n){const l=o[n],c=o[n+1],d=o[n+2];return Math.sqrt(l*l+c*c+d*d)}function r(o,n){const l=o[n],c=o[n+1],d=o[n+2],f=1/Math.sqrt(l*l+c*c+d*d);o[n]*=f,o[n+1]*=f,o[n+2]*=f}function i(o,n,l){o[n]*=l,o[n+1]*=l,o[n+2]*=l}function s(o,n,l,c,d,f=n){(d=d||o)[f]=o[n]+l[c],d[f+1]=o[n+1]+l[c+1],d[f+2]=o[n+2]+l[c+2]}function a(o,n,l,c,d,f=n){(d=d||o)[f]=o[n]-l[c],d[f+1]=o[n+1]-l[c+1],d[f+2]=o[n+2]-l[c+2]}t.length=e,t.normalize=r,t.scale=i,t.add=s,t.subtract=a})(Is||(Is={}));function Ve(t,e=!1){return t<=Eo?e?new Array(t).fill(0):new Array(t):new Float32Array(t)}function uo(t){return length<=Eo?Array.from(t):new Float32Array(t)}function hf(t,e,r){return Array.isArray(t)?t.slice(e,e+r):t.subarray(e,e+r)}const Jt=Is,gs=[[-.5,-.5,.5],[.5,-.5,.5],[.5,.5,.5],[-.5,.5,.5],[-.5,-.5,-.5],[.5,-.5,-.5],[.5,.5,-.5],[-.5,.5,-.5]],lu=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],cu=[0,0,1,0,1,1,0,1],du=[0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5],Cn=new Array(36);for(let t=0;t<6;t++)for(let e=0;e<6;e++)Cn[6*t+e]=t;const Ft=new Array(36);for(let t=0;t<6;t++)Ft[6*t+0]=0,Ft[6*t+1]=1,Ft[6*t+2]=2,Ft[6*t+3]=2,Ft[6*t+4]=3,Ft[6*t+5]=0;function uf(t,e){Array.isArray(e)||(e=[e,e,e]);const r=new Array(24);for(let i=0;i<8;i++)r[3*i]=gs[i][0]*e[0],r[3*i+1]=gs[i][1]*e[1],r[3*i+2]=gs[i][2]*e[2];return new Ne(t,[[u.POSITION,new j(r,3,!0)],[u.NORMAL,new j(lu,3)],[u.UV0,new j(cu,2)]],[[u.POSITION,du],[u.NORMAL,Cn],[u.UV0,Ft]])}const vs=[[-.5,0,-.5],[.5,0,-.5],[.5,0,.5],[-.5,0,.5],[0,-.5,0],[0,.5,0]],hu=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],uu=[5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0],pu=[0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7];function pf(t,e){Array.isArray(e)||(e=[e,e,e]);const r=new Array(18);for(let i=0;i<6;i++)r[3*i]=vs[i][0]*e[0],r[3*i+1]=vs[i][1]*e[1],r[3*i+2]=vs[i][2]*e[2];return new Ne(t,[[u.POSITION,new j(r,3,!0)],[u.NORMAL,new j(hu,3)]],[[u.POSITION,uu],[u.NORMAL,pu]])}const mi=le(-.5,0,-.5),gi=le(.5,0,-.5),vi=le(0,0,.5),_i=le(0,.5,0),Qt=te(),Kt=te(),mr=te(),gr=te(),vr=te();ne(Qt,mi,_i),ne(Kt,mi,gi),it(mr,Qt,Kt),de(mr,mr),ne(Qt,gi,_i),ne(Kt,gi,vi),it(gr,Qt,Kt),de(gr,gr),ne(Qt,vi,_i),ne(Kt,vi,mi),it(vr,Qt,Kt),de(vr,vr);const _s=[mi,gi,vi,_i],fu=[0,-1,0,mr[0],mr[1],mr[2],gr[0],gr[1],gr[2],vr[0],vr[1],vr[2]],mu=[0,1,2,3,1,0,3,2,1,3,0,2],gu=[0,0,0,1,1,1,2,2,2,3,3,3];function ff(t,e){Array.isArray(e)||(e=[e,e,e]);const r=new Array(12);for(let i=0;i<4;i++)r[3*i]=_s[i][0]*e[0],r[3*i+1]=_s[i][1]*e[1],r[3*i+2]=_s[i][2]*e[2];return new Ne(t,[[u.POSITION,new j(r,3,!0)],[u.NORMAL,new j(fu,3)]],[[u.POSITION,mu],[u.NORMAL,gu]])}function mf(t,e,r,i,s={uv:!0}){const a=-Math.PI,o=2*Math.PI,n=-Math.PI/2,l=Math.PI,c=Math.max(3,Math.floor(r)),d=Math.max(2,Math.floor(i)),f=(c+1)*(d+1),p=Ve(3*f),h=Ve(3*f),v=Ve(2*f),_=[];let S=0;for(let R=0;R<=d;R++){const C=[],b=R/d,F=n+b*l,E=Math.cos(F);for(let U=0;U<=c;U++){const pe=U/c,D=a+pe*o,X=Math.cos(D)*E,me=Math.sin(F),qe=-Math.sin(D)*E;p[3*S]=X*e,p[3*S+1]=me*e,p[3*S+2]=qe*e,h[3*S]=X,h[3*S+1]=me,h[3*S+2]=qe,v[2*S]=pe,v[2*S+1]=b,C.push(S),++S}_.push(C)}const T=new Array;for(let R=0;R<d;R++)for(let C=0;C<c;C++){const b=_[R][C],F=_[R][C+1],E=_[R+1][C+1],U=_[R+1][C];R===0?(T.push(b),T.push(E),T.push(U)):R===d-1?(T.push(b),T.push(F),T.push(E)):(T.push(b),T.push(F),T.push(E),T.push(E),T.push(U),T.push(b))}const w=[[u.POSITION,T],[u.NORMAL,T]],y=[[u.POSITION,new j(p,3,!0)],[u.NORMAL,new j(h,3,!0)]];return s.uv&&(y.push([u.UV0,new j(v,2,!0)]),w.push([u.UV0,T])),s.offset&&(w[0][0]=u.OFFSET,y[0][0]=u.OFFSET,w.push([u.POSITION,new Array(T.length).fill(0)]),y.push([u.POSITION,new j(Float64Array.from(s.offset),3,!0)])),new Ne(t,y,w)}function gf(t,e,r,i){const{vertexAttributes:s,indices:a}=vu(e,r,i);return new Ne(t,s,a)}function vu(t,e,r){const i=t;let s,a;if(r)s=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],a=[0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1];else{const d=i*(1+Math.sqrt(5))/2;s=[-i,d,0,i,d,0,-i,-d,0,i,-d,0,0,-i,d,0,i,d,0,-i,-d,0,i,-d,d,0,-i,d,0,i,-d,0,-i,-d,0,i],a=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1]}for(let d=0;d<s.length;d+=3)Jt.scale(s,d,t/Jt.length(s,d));let o={};function n(d,f){d>f&&([d,f]=[f,d]);const p=d.toString()+"."+f.toString();if(o[p])return o[p];let h=s.length;return s.length+=3,Jt.add(s,3*d,s,3*f,s,h),Jt.scale(s,h,t/Jt.length(s,h)),h/=3,o[p]=h,h}for(let d=0;d<e;d++){const f=a.length,p=new Array(4*f);for(let h=0;h<f;h+=3){const v=a[h],_=a[h+1],S=a[h+2],T=n(v,_),w=n(_,S),y=n(S,v),R=4*h;p[R]=v,p[R+1]=T,p[R+2]=y,p[R+3]=_,p[R+4]=w,p[R+5]=T,p[R+6]=S,p[R+7]=y,p[R+8]=w,p[R+9]=T,p[R+10]=w,p[R+11]=y}a=p,o={}}const l=uo(s);for(let d=0;d<l.length;d+=3)Jt.normalize(l,d);const c=[[u.POSITION,a],[u.NORMAL,a]];return{vertexAttributes:[[u.POSITION,new j(uo(s),3,!0)],[u.NORMAL,new j(l,3,!0)]],indices:c}}function vf(t,e,r,i,s,a,o,n,l=null){const c=r?[r[0],r[1],r[2]]:[0,0,0],d=e?[e[0],e[1],e[2]]:[0,0,1];o=o||[0,0];const f=i?[255*i[0],255*i[1],255*i[2],i.length>3?255*i[3]:255]:[255,255,255,255],p=A(s)&&s.length===2?s:[1,1],h=[[u.POSITION,new j(c,3,!0)],[u.NORMAL,new j(d,3,!0)],[u.UV0,new j(o,o.length)],[u.COLOR,new j(f,4,!0)],[u.SIZE,new j(p,2)]];if(a!=null){const v=[a[0],a[1],a[2],a[3]];h.push([u.AUXPOS1,new j(v,4)])}if(n!=null){const v=[n[0],n[1],n[2],n[3]];h.push([u.AUXPOS2,new j(v,4)])}return new Ne(t,h,null,null,br.Point,l)}function _f(t,e,r,i,s,a=!0,o=!0){let n=0;const l=r,c=e;let d=le(0,n,0),f=le(0,n+c,0),p=le(0,-1,0),h=le(0,1,0);s&&(n=c,f=le(0,0,0),d=le(0,n,0),p=le(0,1,0),h=le(0,-1,0));const v=[f,d],_=[p,h],S=i+2,T=Math.sqrt(c*c+l*l);if(s)for(let E=i-1;E>=0;E--){const U=E*(2*Math.PI/i),pe=le(Math.cos(U)*l,n,Math.sin(U)*l);v.push(pe);const D=le(c*Math.cos(U)/T,-l/T,c*Math.sin(U)/T);_.push(D)}else for(let E=0;E<i;E++){const U=E*(2*Math.PI/i),pe=le(Math.cos(U)*l,n,Math.sin(U)*l);v.push(pe);const D=le(c*Math.cos(U)/T,l/T,c*Math.sin(U)/T);_.push(D)}const w=new Array,y=new Array;if(a){for(let E=3;E<v.length;E++)w.push(1),w.push(E-1),w.push(E),y.push(0),y.push(0),y.push(0);w.push(v.length-1),w.push(2),w.push(1),y.push(0),y.push(0),y.push(0)}if(o){for(let E=3;E<v.length;E++)w.push(E),w.push(E-1),w.push(0),y.push(E),y.push(E-1),y.push(1);w.push(0),w.push(2),w.push(v.length-1),y.push(1),y.push(2),y.push(_.length-1)}const R=Ve(3*S);for(let E=0;E<S;E++)R[3*E]=v[E][0],R[3*E+1]=v[E][1],R[3*E+2]=v[E][2];const C=Ve(3*S);for(let E=0;E<S;E++)C[3*E]=_[E][0],C[3*E+1]=_[E][1],C[3*E+2]=_[E][2];const b=[[u.POSITION,w],[u.NORMAL,y]],F=[[u.POSITION,new j(R,3,!0)],[u.NORMAL,new j(C,3,!0)]];return new Ne(t,F,b)}function yf(t,e,r,i,s,a,o){const n=s?va(s):le(1,0,0),l=a?va(a):le(0,0,0);o=o!=null?o:!0;const c=te();de(c,n);const d=te();Z(d,c,Math.abs(e));const f=te();Z(f,d,-.5),re(f,f,l);const p=le(0,1,0);Math.abs(1-ct(c,p))<.2&&H(p,0,0,1);const h=te();it(h,c,p),de(h,h),it(p,h,c);const v=2*i+(o?2:0),_=i+(o?2:0),S=Ve(3*v),T=Ve(3*_),w=Ve(2*v),y=new Array(3*i*(o?4:2)),R=new Array(3*i*(o?4:2));o&&(S[3*(v-2)+0]=f[0],S[3*(v-2)+1]=f[1],S[3*(v-2)+2]=f[2],w[2*(v-2)]=0,w[2*(v-2)+1]=0,S[3*(v-1)+0]=S[3*(v-2)+0]+d[0],S[3*(v-1)+1]=S[3*(v-2)+1]+d[1],S[3*(v-1)+2]=S[3*(v-2)+2]+d[2],w[2*(v-1)]=1,w[2*(v-1)+1]=1,T[3*(_-2)+0]=-c[0],T[3*(_-2)+1]=-c[1],T[3*(_-2)+2]=-c[2],T[3*(_-1)+0]=c[0],T[3*(_-1)+1]=c[1],T[3*(_-1)+2]=c[2]);const C=(D,X,me)=>{y[D]=X,R[D]=me};let b=0;const F=te(),E=te();for(let D=0;D<i;D++){const X=D*(2*Math.PI/i);Z(F,p,Math.sin(X)),Z(E,h,Math.cos(X)),re(F,F,E),T[3*D+0]=F[0],T[3*D+1]=F[1],T[3*D+2]=F[2],Z(F,F,r),re(F,F,f),S[3*D+0]=F[0],S[3*D+1]=F[1],S[3*D+2]=F[2],w[2*D+0]=D/i,w[2*D+1]=0,S[3*(D+i)+0]=S[3*D+0]+d[0],S[3*(D+i)+1]=S[3*D+1]+d[1],S[3*(D+i)+2]=S[3*D+2]+d[2],w[2*(D+i)+0]=D/i,w[2*D+1]=1;const me=(D+1)%i;C(b++,D,D),C(b++,D+i,D),C(b++,me,me),C(b++,me,me),C(b++,D+i,D),C(b++,me+i,me)}if(o){for(let D=0;D<i;D++){const X=(D+1)%i;C(b++,v-2,_-2),C(b++,D,_-2),C(b++,X,_-2)}for(let D=0;D<i;D++){const X=(D+1)%i;C(b++,D+i,_-1),C(b++,v-1,_-1),C(b++,X+i,_-1)}}const U=[[u.POSITION,y],[u.NORMAL,R],[u.UV0,y]],pe=[[u.POSITION,new j(S,3,!0)],[u.NORMAL,new j(T,3,!0)],[u.UV0,new j(w,2,!0)]];return new Ne(t,pe,U)}function Sf(t,e,r,i,s,a){i=i||10,s=s==null||s,Oe(e.length>1);const o=[[0,0,0]],n=[],l=[];for(let c=0;c<i;c++){n.push([0,-c-1,-(c+1)%i-1]);const d=c/i*2*Math.PI;l.push([Math.cos(d)*r,Math.sin(d)*r])}return _u(t,l,e,o,n,s,a)}function _u(t,e,r,i,s,a,o=le(0,0,0)){const n=e.length,l=Ve(r.length*n*3+(6*i.length||0)),c=Ve(r.length*n*3+(i?6:0)),d=new Array,f=new Array;let p=0,h=0;const v=te(),_=te(),S=te(),T=te(),w=te(),y=te(),R=te(),C=$(),b=te(),F=te(),E=te(),U=te(),pe=te(),D=dt();H(b,0,1,0),ne(_,r[1],r[0]),de(_,_),a?(re(C,r[0],o),de(S,C)):H(S,0,0,1),po(_,S,b,b,w,S,fo),k(T,S),k(U,w);for(let I=0;I<i.length;I++)Z(y,w,i[I][0]),Z(C,S,i[I][2]),re(y,y,C),re(y,y,r[0]),l[p++]=y[0],l[p++]=y[1],l[p++]=y[2];c[h++]=-_[0],c[h++]=-_[1],c[h++]=-_[2];for(let I=0;I<s.length;I++)d.push(s[I][0]>0?s[I][0]:-s[I][0]-1+i.length),d.push(s[I][1]>0?s[I][1]:-s[I][1]-1+i.length),d.push(s[I][2]>0?s[I][2]:-s[I][2]-1+i.length),f.push(0),f.push(0),f.push(0);let X=i.length;const me=i.length-1;for(let I=0;I<r.length;I++){let At=!1;I>0&&(k(v,_),I<r.length-1?(ne(_,r[I+1],r[I]),de(_,_)):At=!0,re(F,v,_),de(F,F),re(E,r[I-1],T),Ll(r[I],F,D),Nl(D,Vl(E,v),C)?(ne(C,C,r[I]),de(S,C),it(w,F,S),de(w,w)):po(F,T,U,b,w,S,fo),k(T,S),k(U,w)),a&&(re(C,r[I],o),de(pe,C));for(let Xe=0;Xe<n;Xe++)if(Z(y,w,e[Xe][0]),Z(C,S,e[Xe][1]),re(y,y,C),de(R,y),c[h++]=R[0],c[h++]=R[1],c[h++]=R[2],re(y,y,r[I]),l[p++]=y[0],l[p++]=y[1],l[p++]=y[2],!At){const Dr=(Xe+1)%n;d.push(X+Xe),d.push(X+n+Xe),d.push(X+Dr),d.push(X+Dr),d.push(X+n+Xe),d.push(X+n+Dr);for(let ht=0;ht<6;ht++){const Nn=d.length-6;f.push(d[Nn+ht]-me)}}X+=n}const qe=r[r.length-1];for(let I=0;I<i.length;I++)Z(y,w,i[I][0]),Z(C,S,i[I][1]),re(y,y,C),re(y,y,qe),l[p++]=y[0],l[p++]=y[1],l[p++]=y[2];const Bt=h/3;c[h++]=_[0],c[h++]=_[1],c[h++]=_[2];const J=X-n;for(let I=0;I<s.length;I++)d.push(s[I][0]>=0?X+s[I][0]:-s[I][0]-1+J),d.push(s[I][2]>=0?X+s[I][2]:-s[I][2]-1+J),d.push(s[I][1]>=0?X+s[I][1]:-s[I][1]-1+J),f.push(Bt),f.push(Bt),f.push(Bt);const Fe=[[u.POSITION,d],[u.NORMAL,f]],He=[[u.POSITION,new j(l,3,!0)],[u.NORMAL,new j(c,3,!0)]];return new Ne(t,He,Fe)}function wf(t,e,r,i){Oe(e.length>1,"createPolylineGeometry(): polyline needs at least 2 points"),Oe(e[0].length===3,"createPolylineGeometry(): malformed vertex"),Oe(r==null||r.length===e.length,"createPolylineGeometry: need same number of points and normals"),Oe(r==null||r[0].length===3,"createPolylineGeometry(): malformed normal");const s=Zs(3*e.length),a=new Array(2*(e.length-1));let o=0,n=0;for(let d=0;d<e.length;d++){for(let f=0;f<3;f++)s[o++]=e[d][f];d>0&&(a[n++]=d-1,a[n++]=d)}const l=[],c=[];if(l.push([u.POSITION,a]),c.push([u.POSITION,new j(s,3,!0)]),r){const d=Ve(3*r.length);let f=0;for(let p=0;p<e.length;p++)for(let h=0;h<3;h++)d[f++]=r[p][h];l.push([u.NORMAL,a]),c.push([u.NORMAL,new j(d,3,!0)])}return i&&(c.push([u.COLOR,new j(i,4)]),l.push([u.COLOR,Pc(i.length/4)])),new Ne(t,c,l,null,br.Line)}function xf(t,e,r,i,s,a=0){const o=new Array(18),n=[[-r,a,s/2],[i,a,s/2],[0,e+a,s/2],[-r,a,-s/2],[i,a,-s/2],[0,e+a,-s/2]],l=[0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5];for(let c=0;c<6;c++)o[3*c]=n[c][0],o[3*c+1]=n[c][1],o[3*c+2]=n[c][2];return new Ne(t,[[u.POSITION,new j(o,3,!0)]],[[u.POSITION,l]])}function Of(t,e){const r=t.getMutableAttribute(u.POSITION).data;for(let i=0;i<r.length;i+=3){const s=r[i],a=r[i+1],o=r[i+2];H(er,s,a,o),se(er,er,e),r[i]=er[0],r[i+1]=er[1],r[i+2]=er[2]}}function Tf(t,e=t){const r=t.vertexAttributes,i=r.get(u.POSITION).data,s=r.get(u.NORMAL).data;if(s){const a=e.getMutableAttribute(u.NORMAL).data;for(let o=0;o<s.length;o+=3){const n=s[o+1];a[o+1]=-s[o+2],a[o+2]=n}}if(i){const a=e.getMutableAttribute(u.POSITION).data;for(let o=0;o<i.length;o+=3){const n=i[o+1];a[o+1]=-i[o+2],a[o+2]=n}}}function ys(t,e,r,i,s){return!(Math.abs(ct(e,t))>s)&&(it(r,t,e),de(r,r),it(i,r,t),de(i,i),!0)}function po(t,e,r,i,s,a,o){return ys(t,e,s,a,o)||ys(t,r,s,a,o)||ys(t,i,s,a,o)}const fo=.99619469809,er=te();class Cf{constructor(e,r={}){this.geometry=e,this.boundingSphere=ke(),this.screenToWorldRatio=1,this._transformation=Y(),this._shaderTransformationDirty=!0,this.id=zs(),this.layerUid=r.layerUid,this.graphicUid=r.graphicUid,this.boundingInfo=r.boundingInfo,this.shaderTransformer=r.shaderTransformer,this.castShadow=!!r.castShadow&&r.castShadow}get transformation(){return this._transformation}updateTransformation(e){e(this._transformation),this._shaderTransformationDirty=!0,this.computeBoundingSphere(this._transformation,this.boundingSphere)}shaderTransformationChanged(){this._shaderTransformationDirty=!0}computeBoundingSphere(e,r,i=Rs(e)){N(this.boundingInfo)||(se(r,this.boundingInfo.center,e),r[3]=this.boundingInfo.radius*i)}get hasShaderTransformation(){return A(this.shaderTransformer)}get material(){return this.geometry.material}get type(){return this.geometry.type}get shaderTransformation(){return N(this.shaderTransformer)?this.transformation:(this._shaderTransformationDirty&&(this._shaderTransformation||(this._shaderTransformation=Y()),yt(this._shaderTransformation,this.shaderTransformer(this.transformation)),this._shaderTransformationDirty=!1),this._shaderTransformation)}get indices(){return this.geometry.indices}get vertexAttributes(){return this.geometry.vertexAttributes}get highlights(){return this.geometry.highlights}get occludees(){return this.geometry.occludees}get visible(){return this.geometry.visible}set visible(e){this.geometry.visible=e}}function bn(t){return t.type==="point"}function bf(t,e){if(t.type==="point")return pt(t,e,!1);if(Ic(t))switch(t.type){case"extent":return pt(t.center,e,!1);case"polygon":return pt(t.centroid,e,!1);case"polyline":return pt(mo(t),e,!0);case"mesh":return pt(t.origin,e,!1)}else switch(t.type){case"extent":return pt(yu(t),e,!0);case"polygon":return pt(Su(t),e,!0);case"polyline":return pt(mo(t),e,!0)}}function mo(t){const e=t.paths[0];if(!e||e.length===0)return null;const r=hl(e,ul(e)/2);return js(r[0],r[1],r[2],t.spatialReference)}function yu(t){return js(.5*(t.xmax+t.xmin),.5*(t.ymax+t.ymin),t.zmin!=null&&t.zmax!=null&&isFinite(t.zmin)&&isFinite(t.zmax)?.5*(t.zmax+t.zmin):void 0,t.spatialReference)}function Su(t){const e=t.rings[0];if(!e||e.length===0)return null;const r=pl(t.rings,!!t.hasZ);return js(r[0],r[1],r[2],t.spatialReference)}function pt(t,e,r){const i=r?t:Mc(t);return e&&t?fl(t,i,e)?i:null:i}function Af(t,e,r,i=0){if(t){e||(e=cr());const s=t;let a=.5*s.width*(r-1),o=.5*s.height*(r-1);return s.width<1e-7*s.height?a+=o/20:s.height<1e-7*s.width&&(o+=a/20),Wr(e,s.xmin-a-i,s.ymin-o-i,s.xmax+a+i,s.ymax+o+i),e}return null}function wu(t,e){for(let r=0;r<t.geometries.length;++r){const i=t.geometries[r].getMutableAttribute(u.AUXPOS1);i&&i.data[3]!==e&&(i.data[3]=e,t.geometryVertexAttrsUpdated(t.geometries[r]))}}function Rf(t,e){const r=ml(zi);return A(t)&&(r[0]=t[0],r[1]=t[1],r[2]=t[2]),A(e)?r[3]=e:A(t)&&t.length>3&&(r[3]=t[3]),r}function Ef(t=vl,e,r,i=1){const s=new Array(3);if(N(e)||N(r))s[0]=1,s[1]=1,s[2]=1;else{let a,o=0;for(let n=2;n>=0;n--){const l=t[n];let c;const d=l!=null,f=n===0&&!a&&!d,p=r[n];l==="symbol-value"||f?c=p!==0?e[n]/p:1:d&&l!=="proportional"&&isFinite(l)&&(c=p!==0?l/p:1),c!=null&&(s[n]=c,a=c,o=Math.max(o,Math.abs(c)))}for(let n=2;n>=0;n--)s[n]==null?s[n]=a:s[n]===0&&(s[n]=.001*o)}for(let a=2;a>=0;a--)s[a]/=i;return gl(s)}function xu(t){return t.isPrimitive!=null}function Pf(t){return An(xu(t)?[t.width,t.depth,t.height]:t)?null:"Symbol sizes may not be negative values"}function An(t){if(Array.isArray(t)){for(const e of t)if(!An(e))return!1;return!0}return t==null||t>=0}function Df(t,e,r,i=Y()){const s=t||0,a=e||0,o=r||0;return s!==0&&_l(i,i,-s/180*Math.PI),a!==0&&yl(i,i,a/180*Math.PI),o!==0&&Sl(i,i,o/180*Math.PI),i}function $f(t,e,r){if(r.minDemResolution!=null)return r.minDemResolution;const i=wl(e),s=xl(t)*i,a=Ol(t)*i,o=Tl(t)*(e.isGeographic?1:i);return s===0&&a===0&&o===0?r.minDemResolutionForPoints:.01*Math.max(s,a,o)}class If{constructor(e,r=null,i=0){this.array=e,this.spatialReference=r,this.offset=i}}function Rn(t){return"array"in t}function hi(t,e,r="ground"){if(bn(e))return t.getElevation(e.x,e.y,e.z||0,e.spatialReference,r);if(Rn(e)){let i=e.offset;return t.getElevation(e.array[i++],e.array[i++],e.array[i]||0,ae(e.spatialReference,t.spatialReference),r)}return t.getElevation(e[0],e[1],e[2]||0,t.spatialReference,r)}function Ou(t,e,r,i,s,a,o,n,l,c,d){const f=Pu[d.mode];let p,h,v=0;if(yi(t,e,r,i,l.spatialReference,s,n))return f.requiresAlignment(d)?(v=f.applyElevationAlignmentBuffer(i,s,a,o,n,l,c,d),p=a,h=o):(p=i,h=s),yi(p,l.spatialReference,h,a,c.spatialReference,o,n)?v:void 0}function En(t,e,r,i,s){const a=(bn(t)?t.z:Rn(t)?t.array[t.offset+2]:t[2])||0;switch(r.mode){case"on-the-ground":{const o=ae(hi(e,t,"ground"),0);return s.verticalDistanceToGround=0,s.sampledElevation=o,void(s.z=o)}case"relative-to-ground":{const o=ae(hi(e,t,"ground"),0),n=r.geometryZWithOffset(a,i);return s.verticalDistanceToGround=n,s.sampledElevation=o,void(s.z=n+o)}case"relative-to-scene":{const o=ae(hi(e,t,"scene"),0),n=r.geometryZWithOffset(a,i);return s.verticalDistanceToGround=n,s.sampledElevation=o,void(s.z=n+o)}case"absolute-height":{const o=r.geometryZWithOffset(a,i),n=ae(hi(e,t,"ground"),0);return s.verticalDistanceToGround=o-n,s.sampledElevation=n,void(s.z=o)}default:return void(s.z=0)}}function Mf(t,e,r,i){return En(t,e,r,i,lr),lr.z}function Lf(t,e,r){return e==null||r==null?t.definedChanged:e==="on-the-ground"&&r==="on-the-ground"?t.staysOnTheGround:e===r||e!=="on-the-ground"&&r!=="on-the-ground"?Ms.UPDATE:t.onTheGroundChanged}function Nf(t){return t==="relative-to-ground"||t==="relative-to-scene"}function Ff(t){return t!=="absolute-height"}function zf(t,e,r,i,s){En(e,r,s,i,lr),wu(t,lr.verticalDistanceToGround);const a=lr.sampledElevation,o=yt(Du,t.transformation);return ui[0]=e.x,ui[1]=e.y,ui[2]=lr.z,Cl(e.spatialReference,ui,o,i.spatialReference)?t.transformation=o:console.warn("Could not locate symbol object properly, it might be misplaced"),a}function Tu(t,e,r,i,s,a){let o=0;const n=a.spatialReference;e*=3,i*=3;for(let l=0;l<s;++l){const c=t[e+0],d=t[e+1],f=t[e+2],p=ae(a.getElevation(c,d,f,n,"ground"),0);o+=p,r[i+0]=c,r[i+1]=d,r[i+2]=p,e+=3,i+=3}return o/s}function Cu(t,e,r,i,s,a,o,n){let l=0;const c=n.calculateOffsetRenderUnits(o),d=n.featureExpressionInfoContext,f=a.spatialReference;e*=3,i*=3;for(let p=0;p<s;++p){const h=t[e+0],v=t[e+1],_=t[e+2],S=ae(a.getElevation(h,v,_,f,"ground"),0);l+=S,r[i+0]=h,r[i+1]=v,r[i+2]=d==null?_+S+c:S+c,e+=3,i+=3}return l/s}function bu(t,e,r,i,s,a,o,n){let l=0;const c=n.calculateOffsetRenderUnits(o),d=n.featureExpressionInfoContext,f=a.spatialReference;e*=3,i*=3;for(let p=0;p<s;++p){const h=t[e+0],v=t[e+1],_=t[e+2],S=ae(a.getElevation(h,v,_,f,"scene"),0);l+=S,r[i+0]=h,r[i+1]=v,r[i+2]=d==null?_+S+c:S+c,e+=3,i+=3}return l/s}function Au(t){const e=t.meterUnitOffset,r=t.featureExpressionInfoContext;return e!==0||r!=null}function Ru(t,e,r,i,s,a,o,n){const l=n.calculateOffsetRenderUnits(o),c=n.featureExpressionInfoContext;e*=3,i*=3;for(let d=0;d<s;++d){const f=t[e+0],p=t[e+1],h=t[e+2];r[i+0]=f,r[i+1]=p,r[i+2]=c==null?h+l:l,e+=3,i+=3}return 0}class Eu{constructor(){this.verticalDistanceToGround=0,this.sampledElevation=0,this.z=0}}var Ms;(function(t){t[t.NONE=0]="NONE",t[t.UPDATE=1]="UPDATE",t[t.RECREATE=2]="RECREATE"})(Ms||(Ms={}));const Pu={"absolute-height":{applyElevationAlignmentBuffer:Ru,requiresAlignment:Au},"on-the-ground":{applyElevationAlignmentBuffer:Tu,requiresAlignment:()=>!0},"relative-to-ground":{applyElevationAlignmentBuffer:Cu,requiresAlignment:()=>!0},"relative-to-scene":{applyElevationAlignmentBuffer:bu,requiresAlignment:()=>!0}},Du=Y(),lr=new Eu,ui=$(),$u=Zr.getLogger("esri.views.3d.layers.graphics.featureExpressionInfoUtils");function Iu(t){return{cachedResult:t.cachedResult,arcade:t.arcade?{func:t.arcade.func,context:t.arcade.modules.arcadeUtils.createExecContext(null,{sr:t.arcade.context.spatialReference}),modules:t.arcade.modules}:null}}async function jf(t,e,r,i){const s=t&&t.expression;if(typeof s!="string")return null;const a=Fu(s);if(a!=null)return{cachedResult:a};const o=await bl();Al(r);const n=o.arcadeUtils,l=n.createSyntaxTree(s);return n.dependsOnView(l)?(i!=null&&i.error("Expressions containing '$view' are not supported on ElevationInfo"),{cachedResult:0}):{arcade:{func:n.createFunction(l),context:n.createExecContext(null,{sr:e}),modules:o}}}function Mu(t,e,r){return t.arcadeUtils.createFeature(e.attributes,e.geometry,r)}function Lu(t,e){if(t!=null&&!Pn(t)){if(!e||!t.arcade)return void $u.errorOncePerTick("Arcade support required but not provided");const r=e;r._geometry&&(r._geometry=Lc(r._geometry)),t.arcade.modules.arcadeUtils.updateExecContext(t.arcade.context,e)}}function Nu(t){if(t!=null){if(Pn(t))return t.cachedResult;const e=t.arcade;let r=e==null?void 0:e.modules.arcadeUtils.executeFunction(e.func,e.context);return typeof r!="number"&&(t.cachedResult=0,r=0),r}return 0}function Uf(t,e=!1){let r=t&&t.featureExpressionInfo;const i=r&&r.expression;return e||i==="0"||(r=null),r!=null?r:null}const Vf={cachedResult:0};function Pn(t){return t.cachedResult!=null}function Fu(t){return t==="0"?0:null}class Dn{constructor(){this._meterUnitOffset=0,this._renderUnitOffset=0,this._unit="meters",this._metersPerElevationInfoUnit=1,this._featureExpressionInfoContext=null,this.centerPointInElevationSR=null,this.mode=null}get featureExpressionInfoContext(){return this._featureExpressionInfoContext}get meterUnitOffset(){return this._meterUnitOffset}get unit(){return this._unit}set unit(e){this._unit=e,this._metersPerElevationInfoUnit=Rl(e)}get requiresSampledElevationInfo(){return this.mode!=="absolute-height"}reset(){this.mode=null,this._meterUnitOffset=0,this._renderUnitOffset=0,this._featureExpressionInfoContext=null,this.unit="meters"}set offsetMeters(e){this._meterUnitOffset=e,this._renderUnitOffset=0}set offsetElevationInfoUnits(e){this._meterUnitOffset=e*this._metersPerElevationInfoUnit,this._renderUnitOffset=0}addOffsetRenderUnits(e){this._renderUnitOffset+=e}geometryZWithOffset(e,r){const i=this.calculateOffsetRenderUnits(r);return this.featureExpressionInfoContext!=null?i:e+i}calculateOffsetRenderUnits(e){let r=this._meterUnitOffset;const i=this.featureExpressionInfoContext;return i!=null&&(r+=Nu(i)*this._metersPerElevationInfoUnit),r/e.unitInMeters+this._renderUnitOffset}setFromElevationInfo(e){this.mode=e.mode,this.unit=El(e.unit)?e.unit:"meters",this.offsetElevationInfoUnits=ae(e.offset,0)}updateFeatureExpressionInfoContext(e,r,i){if(N(e))return void(this._featureExpressionInfoContext=null);const s=e&&e.arcade;s&&A(r)&&A(i)?(this._featureExpressionInfoContext=Iu(e),Lu(this._featureExpressionInfoContext,Mu(s.modules,r,i))):this._featureExpressionInfoContext=e}static fromElevationInfo(e){const r=new Dn;return A(e)&&r.setFromElevationInfo(e),r}}function zu(t){return t instanceof Float32Array&&t.length>=16}function ju(t){return Array.isArray(t)&&t.length>=16}function Uu(t){return zu(t)||ju(t)}var Mi;(function(t){t[t.Occluded=0]="Occluded",t[t.NotOccluded=1]="NotOccluded",t[t.Both=2]="Both",t[t.COUNT=3]="COUNT"})(Mi||(Mi={}));var Be;function Vu(t,e){t.include(Uo),t.attributes.add(u.POSITION,"vec3"),t.attributes.add(u.NORMAL,"vec3"),t.attributes.add(u.AUXPOS1,"vec4");const r=t.vertex;Jr(r,e),Vs(r,e),r.uniforms.add([new Pe("viewport",(i,s)=>s.camera.fullViewport),new B("polygonOffset",i=>i.shaderPolygonOffset),new B("cameraGroundRelative",(i,s)=>s.camera.aboveGround?1:-1),new B("renderTransparentlyOccludedHUD",(i,s)=>s.renderTransparentlyOccludedHUD===Mi.Occluded?1:s.renderTransparentlyOccludedHUD===Mi.NotOccluded?0:.75),new Vt("hudVisibilityTexture",(i,s)=>s.hudVisibilityTexture)]),e.hasVerticalOffset&&fc(r),r.constants.add("smallOffsetAngle","float",.984807753012208),r.code.add(m`struct ProjectHUDAux {
vec3 posModel;
vec3 posView;
vec3 vnormal;
float distanceToCamera;
float absCosAngle;
};`),r.code.add(m`float applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {
float pointGroundSign = sign(pointGroundDistance);
if (pointGroundSign == 0.0) {
pointGroundSign = cameraGroundRelative;
}
float groundRelative = cameraGroundRelative * pointGroundSign;
if (polygonOffset > .0) {
float cosAlpha = clamp(absCosAngle, 0.01, 1.0);
float tanAlpha = sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;
float factor = (1.0 - tanAlpha / viewport[2]);
if (groundRelative > 0.0) {
posView *= factor;
}
else {
posView /= factor;
}
}
return groundRelative;
}`),e.isDraped&&!e.hasVerticalOffset||mc(r),e.isDraped||(r.uniforms.add(new B("perDistancePixelRatio",(i,s)=>Math.tan(s.camera.fovY/2)/(s.camera.fullViewport[2]/2))),r.code.add(m`void applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {
float distanceToCamera = length(posView);
float pixelOffset = distanceToCamera * perDistancePixelRatio * 0.5;
vec3 modelOffset = normalModel * cameraGroundRelative * pixelOffset;
vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;
posModel += modelOffset;
posView += viewOffset;
}`)),e.screenCenterOffsetUnitsEnabled===Be.Screen&&r.uniforms.add(new B("pixelRatio",(i,s)=>s.camera.pixelRatio)),e.hasScreenSizePerspective&&Vo(r),r.code.add(m`
    vec4 projectPositionHUD(out ProjectHUDAux aux) {
      // centerOffset is in view space and is used to implement world size offsetting
      // of labels with respect to objects. It also pulls the label towards the viewer
      // so that the label is visible in front of the object.
      vec3 centerOffset = auxpos1.xyz;

      // The pointGroundDistance is the distance of the geometry to the ground and is
      // negative if the point is below the ground, or positive if the point is above
      // ground.
      float pointGroundDistance = auxpos1.w;

      aux.posModel = position;
      aux.posView = (view * vec4(aux.posModel, 1.0)).xyz;
      aux.vnormal = normal;
      ${e.isDraped?"":"applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);"}

      // Screen sized offset in world space, used for example for line callouts
      // Note: keep this implementation in sync with the CPU implementation, see
      //   - MaterialUtil.verticalOffsetAtDistance
      //   - HUDMaterial.applyVerticalOffsetTransformation

      aux.distanceToCamera = length(aux.posView);

      vec3 viewDirObjSpace = normalize(cameraPosition - aux.posModel);
      float cosAngle = dot(aux.vnormal, viewDirObjSpace);

      aux.absCosAngle = abs(cosAngle);

      ${e.hasScreenSizePerspective&&(e.hasVerticalOffset||e.screenCenterOffsetUnitsEnabled===Be.Screen)?"vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);":""}

      ${e.hasVerticalOffset?e.hasScreenSizePerspective?"float verticalOffsetScreenHeight = applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);":"float verticalOffsetScreenHeight = verticalOffset.x;":""}

      ${e.hasVerticalOffset?m`
            float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);
            vec3 modelOffset = aux.vnormal * worldOffset;
            aux.posModel += modelOffset;
            vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;
            aux.posView += viewOffset;
            // Since we elevate the object, we need to take that into account
            // in the distance to ground
            pointGroundDistance += worldOffset;`:""}

      float groundRelative = applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);

      ${e.screenCenterOffsetUnitsEnabled!==Be.Screen?m`
            // Apply x/y in view space, but z in screen space (i.e. along posView direction)
            aux.posView += vec3(centerOffset.x, centerOffset.y, 0.0);

            // Same material all have same z != 0.0 condition so should not lead to
            // branch fragmentation and will save a normalization if it's not needed
            if (centerOffset.z != 0.0) {
              aux.posView -= normalize(aux.posView) * centerOffset.z;
            }
          `:""}

      vec4 posProj = proj * vec4(aux.posView, 1.0);

      ${e.screenCenterOffsetUnitsEnabled===Be.Screen?e.hasScreenSizePerspective?"float centerOffsetY = applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);":"float centerOffsetY = centerOffset.y;":""}

      ${e.screenCenterOffsetUnitsEnabled===Be.Screen?"posProj.xy += vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;":""}

      // constant part of polygon offset emulation
      posProj.z -= groundRelative * polygonOffset * posProj.w;
      return posProj;
    }
  `),r.code.add(m`bool testVisibilityHUD(vec4 posProj) {
vec4 posProjCenter = alignToPixelCenter(posProj, viewport.zw);
vec4 occlusionPixel = texture2D(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w);
if (renderTransparentlyOccludedHUD > 0.5) {
return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g * renderTransparentlyOccludedHUD < 1.0;
}
return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g == 1.0;
}`)}(function(t){t[t.World=0]="World",t[t.Screen=1]="Screen",t[t.COUNT=2]="COUNT"})(Be||(Be={}));class Hu{constructor(){this.factor=new go,this.factorAlignment=new go}}class go{constructor(){this.scale=0,this.factor=0,this.minPixelSize=0,this.paddingPixels=0}}function Gu(t){const e=m`vec4 alignToPixelCenter(vec4 clipCoord, vec2 widthHeight) {
vec2 xy = vec2(0.500123) + 0.5 * clipCoord.xy / clipCoord.w;
vec2 pixelSz = vec2(1.0) / widthHeight;
vec2 ij = (floor(xy * widthHeight) + vec2(0.5)) * pixelSz;
vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;
return vec4(result, clipCoord.zw);
}`,r=m`vec4 alignToPixelOrigin(vec4 clipCoord, vec2 widthHeight) {
vec2 xy = vec2(0.5) + 0.5 * clipCoord.xy / clipCoord.w;
vec2 pixelSz = vec2(1.0) / widthHeight;
vec2 ij = floor((xy + 0.5 * pixelSz) * widthHeight) * pixelSz;
vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;
return vec4(result, clipCoord.zw);
}`;t.vertex.code.add(e),t.vertex.code.add(r),t.fragment.code.add(e),t.fragment.code.add(r)}function Wu(t,e){const{vertex:r,fragment:i}=t;e.hasMultipassGeometry&&r.include(eh),e.hasMultipassTerrain&&t.varyings.add("depth","float"),r.code.add(m`
  void main(void) {
    vec4 posProjCenter;
    if (dot(position, position) > 0.0) {
      // Render single point to center of the pixel to avoid subpixel
      // filtering to affect the marker color
      ProjectHUDAux projectAux;
      vec4 posProj = projectPositionHUD(projectAux);
      posProjCenter = alignToPixelCenter(posProj, viewport.zw);

      ${e.hasMultipassGeometry?m`
        // Don't draw vertices behind geometry
        if(geometryDepthTest(.5 + .5 * posProjCenter.xy / posProjCenter.w, projectAux.posView.z)){
          posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
        }`:""}

      ${e.hasMultipassTerrain?"depth = projectAux.posView.z;":""}
      vec3 vpos = projectAux.posModel;
      if (rejectBySlice(vpos)) {
        // Project out of clip space
        posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
      }

    } else {
      // Project out of clip space
      posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
    }

    gl_Position = posProjCenter;
    gl_PointSize = 1.0;
  }
  `),e.hasMultipassTerrain&&i.include(Bs),e.hasMultipassTerrain&&i.uniforms.add([...Io("terrainDepthTexture",(s,a)=>a.multipassTerrain.linearDepthTexture,e.hasWebGL2Context?wi.None:wi.InvSize),new wt("nearFar",(s,a)=>a.camera.nearFar)]),i.include(Us),i.code.add(m`
  void main() {
    gl_FragColor = vec4(1, 1, 1, 1);
    ${e.hasMultipassTerrain?m`
          vec2 uv = gl_FragCoord.xy;

          // Read the rgba data from the texture linear depth
          vec4 terrainDepthData = ${gc(e,"terrainDepthTexture","uv")};

          float terrainDepth = linearDepthFromFloat(rgba2float(terrainDepthData), nearFar);

          // If HUD vertex is behind terrain and the terrain depth is not the initialize value (e.g. we are not looking at the sky)
          // Mark the HUD vertex as occluded by transparent terrain
          if(depth < terrainDepth && terrainDepthData != vec4(0,0,0,1)){
            gl_FragColor.g = 0.5;
          }`:""}
  }
  `)}function Bu(t){const e=new Yr,r=t.signedDistanceFieldEnabled;if(e.include(Gu),e.include(Vu,t),e.include(vt,t),t.occlusionPass)return e.include(Wu,t),e;const{vertex:i,fragment:s}=e;e.include(Uo),s.include(Us),s.include(Ui),e.include(vc,t),e.include(Hs,t),e.varyings.add("vcolor","vec4"),e.varyings.add("vtc","vec2"),e.varyings.add("vsize","vec2"),t.binaryHighlightOcclusionEnabled&&e.varyings.add("voccluded","float"),i.uniforms.add([new Pe("viewport",(c,d)=>d.camera.fullViewport),new wt("screenOffset",(c,d)=>Ut($n,2*c.screenOffset[0]*d.camera.pixelRatio,2*c.screenOffset[1]*d.camera.pixelRatio)),new wt("anchorPosition",c=>Li(c)),new Pe("materialColor",c=>c.color),new B("pixelRatio",(c,d)=>d.camera.pixelRatio)]),r&&(i.uniforms.add(new Pe("outlineColor",c=>c.outlineColor)),s.uniforms.add([new Pe("outlineColor",c=>vo(c)?c.outlineColor:Fs),new B("outlineSize",c=>vo(c)?c.outlineSize:0)])),t.hasScreenSizePerspective&&(_c(i),Vo(i)),(t.debugDrawLabelBorder||t.binaryHighlightOcclusionEnabled)&&e.varyings.add("debugBorderCoords","vec4"),e.attributes.add(u.UV0,"vec2"),e.attributes.add(u.COLOR,"vec4"),e.attributes.add(u.SIZE,"vec2"),e.attributes.add(u.AUXPOS2,"vec4"),i.code.add(m`
    void main(void) {
      ProjectHUDAux projectAux;
      vec4 posProj = projectPositionHUD(projectAux);
      forwardObjectAndLayerIdColor();

      if (rejectBySlice(projectAux.posModel)) {
        // Project outside of clip plane
        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
        return;
      }
      vec2 inputSize;
      ${t.hasScreenSizePerspective?m`
      inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);
      vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);
         `:m`
      inputSize = size;
      vec2 screenOffsetScaled = screenOffset;`}

      ${t.vvSize?"inputSize *= vvScale(auxpos2).xx;":""}

      vec2 combinedSize = inputSize * pixelRatio;
      vec4 quadOffset = vec4(0.0);

      ${t.occlusionTestEnabled||t.binaryHighlightOcclusionEnabled?"bool visible = testVisibilityHUD(posProj);":""}

      ${t.binaryHighlightOcclusionEnabled?"voccluded = visible ? 0.0 : 1.0;":""}
    `);const a=m`vec2 uv01 = floor(uv0);
vec2 uv = uv0 - uv01;
quadOffset.xy = ((uv01 - anchorPosition) * 2.0 * combinedSize + screenOffsetScaled) / viewport.zw * posProj.w;`,o=t.pixelSnappingEnabled?r?m`posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;`:m`posProj += quadOffset;
if (inputSize.x == size.x) {
posProj = alignToPixelOrigin(posProj, viewport.zw);
}`:m`posProj += quadOffset;`;t.vvColor&&i.uniforms.add([new $o("vvColorColors",c=>c.vvColorColors,jr),new pi("vvColorValues",c=>c.vvColorValues,jr)]),i.uniforms.add(new wt("textureCoordinateScaleFactor",c=>A(c.texture)&&A(c.texture.descriptor.textureCoordinateScaleFactor)?c.texture.descriptor.textureCoordinateScaleFactor:Pl)),i.code.add(m`
    ${t.occlusionTestEnabled?"if (visible) {":""}
    ${a}
    ${t.vvColor?"vcolor = vvGetColor(auxpos2, vvColorValues, vvColorColors) * materialColor;":"vcolor = color / 255.0 * materialColor;"}

    ${t.output===O.ObjectAndLayerIdColor?m`vcolor.a = 1.0;`:""}

    bool alphaDiscard = vcolor.a < ${m.float(Ue)};
    ${r?`alphaDiscard = alphaDiscard && outlineColor.a < ${m.float(Ue)};`:""}
    if (alphaDiscard) {
      // "early discard" if both symbol color (= fill) and outline color (if applicable) are transparent
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
      return;
    } else {
      ${o}
      gl_Position = posProj;
    }

    vtc = uv * textureCoordinateScaleFactor;

    ${t.debugDrawLabelBorder?"debugBorderCoords = vec4(uv01, 1.5 / combinedSize);":""}
    vsize = inputSize;
    ${t.occlusionTestEnabled?m`} else { vtc = vec2(0.0);
      ${t.debugDrawLabelBorder?"debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);}":"}"}`:""}
  }
  `),s.uniforms.add(new Vt("tex",c=>c.texture));const n=t.debugDrawLabelBorder?m`(isBorder > 0.0 ? 0.0 : ${m.float(Oa)})`:m.float(Oa),l=m`
    ${t.debugDrawLabelBorder?m`
      float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));`:""}

    ${r?m`
      vec4 fillPixelColor = vcolor;

      // Attempt to sample texel centers to avoid that thin cross outlines
      // disappear with large symbol sizes.
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603041
      const float txSize = ${m.float(ra)};
      const float texelSize = 1.0 / txSize;
      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel
      vec2 scaleFactor = (vsize - txSize) * texelSize;
      vec2 samplePos = vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;

      // Get distance and map it into [-0.5, 0.5]
      float d = rgba2float(texture2D(tex, samplePos)) - 0.5;

      // Distance in output units (i.e. pixels)
      float dist = d * vsize.x;

      // Create smooth transition from the icon into its outline
      float fillAlphaFactor = clamp(0.5 - dist, 0.0, 1.0);
      fillPixelColor.a *= fillAlphaFactor;

      if (outlineSize > 0.25) {
        vec4 outlinePixelColor = outlineColor;
        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);

        // Create smooth transition around outline
        float outlineAlphaFactor = clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);
        outlinePixelColor.a *= outlineAlphaFactor;

        if (
          outlineAlphaFactor + fillAlphaFactor < ${n} ||
          fillPixelColor.a + outlinePixelColor.a < ${m.float(Ue)}
        ) {
          discard;
        }

        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)
        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);
        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +
          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);

        gl_FragColor = vec4(compositeColor, compositeAlpha);
      } else {
        if (fillAlphaFactor < ${n}) {
          discard;
        }

        gl_FragColor = premultiplyAlpha(fillPixelColor);
      }

      // visualize SDF:
      // gl_FragColor = vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);
      `:m`
          vec4 texColor = texture2D(tex, vtc, -0.5);
          if (texColor.a < ${n}) {
            discard;
          }
          gl_FragColor = texColor * premultiplyAlpha(vcolor);
          `}

    // Draw debug border with transparency, so that original texels along border are still partially visible
    ${t.debugDrawLabelBorder?m`gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder * 0.5);`:""}
  `;return t.output===O.Alpha&&s.code.add(m`
      void main() {
        ${l}
        gl_FragColor = vec4(gl_FragColor.a);
      }
      `),t.output===O.ObjectAndLayerIdColor&&s.code.add(m`
      void main() {
        ${l}
        outputObjectAndLayerIdColor();
      }
      `),t.output===O.Color&&s.code.add(m`
    void main() {
      ${l}
      ${t.transparencyPassType===ie.FrontFace?"gl_FragColor.rgb /= gl_FragColor.a;":""}
    }
    `),t.output===O.Highlight&&(e.include(Gi,t),s.code.add(m`
    void main() {
      ${l}
      ${t.binaryHighlightOcclusionEnabled?m`
          if (voccluded == 1.0) {
            gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);
          } else {
            gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
          }`:"outputHighlight();"}
    }
    `)),e}function vo(t){return t.outlineColor[3]>0&&t.outlineSize>0}function Li(t,e=$n){return t.textureIsSignedDistanceField?ku(t.anchorPosition,t.distanceFieldBoundingBox,e):Tr(e,t.anchorPosition),e}function ku(t,e,r){A(e)?Ut(r,t[0]*(e[2]-e[0])+e[0],t[1]*(e[3]-e[1])+e[1]):Ut(r,0,0)}const $n=K(),qu=Object.freeze(Object.defineProperty({__proto__:null,build:Bu,calculateAnchorPosForRendering:Li},Symbol.toStringTag,{value:"Module"}));class Zi extends Rr{initializeConfiguration(e,r){r.hasWebGL2Context=e.rctx.type===ji.WEBGL2,r.spherical=e.viewingMode===Tt.Global}initializeProgram(e){return new Er(e.rctx,Zi.shader.get().build(this.configuration),Qr)}_setPipelineState(e){const r=this.configuration,i=e===ie.NONE,s=e===ie.FrontFace,a=this.configuration.hasPolygonOffset?Xu:null,o=(i||s)&&r.output!==O.Highlight&&(r.depthEnabled||r.occlusionPass)?Sr:null;return et({blending:r.output===O.Color||r.output===O.Alpha||r.output===O.Highlight?i?Zu:Wi(e):null,depthTest:{func:Bc.LEQUAL},depthWrite:o,colorWrite:lt,polygonOffset:a})}initializePipeline(){return this._setPipelineState(this.configuration.transparencyPassType)}get primitiveType(){return this.configuration.occlusionPass?Ht.POINTS:Ht.TRIANGLES}}Zi.shader=new Pr(qu,()=>Cr(()=>import("./HUDMaterial.glsl.c9a499d2.js"),["assets/HUDMaterial.glsl.c9a499d2.js","assets/index.3255d2a5.js","assets/index.e51050de.css","assets/floatRGBA.7b501bd7.js","assets/VertexColor.glsl.e3d82815.js","assets/requestImageUtils.828b299e.js","assets/OrderIndependentTransparency.43c6e481.js","assets/enums.3c1fa5b5.js","assets/basicInterfaces.f8f3b23b.js","assets/Texture.d66dc1cb.js","assets/VertexArrayObject.ad007c8f.js","assets/Util.3efb1a6b.js","assets/mat4f64.9070f685.js","assets/triangle.1c8f4155.js","assets/sphere.67ec4acb.js","assets/mat3f64.9180efcb.js","assets/quatf64.1dc83f1c.js","assets/lineSegment.1a0fd96e.js","assets/Indices.27b9c798.js","assets/VertexAttribute.34e3daf1.js","assets/doublePrecisionUtils.d6c628ce.js","assets/quat.eb7bbc3a.js","assets/vec3f32.4d8dc001.js","assets/BufferView.32a50625.js","assets/VertexElementDescriptor.5da9dfe9.js","assets/plane.a0a08b54.js","assets/Attribute.98e6fe67.js","assets/triangulationUtils.2ec0b7a6.js","assets/earcut.a219bf29.js","assets/deduplicate.97d7ef01.js","assets/hydratedFeatures.b4cbc12d.js","assets/InterleavedLayout.a42ad5fa.js","assets/types.bf551170.js","assets/NestedMap.2ac03b78.js","assets/Octree.449e609a.js","assets/boundedPlane.91a64206.js","assets/glUtil.9de5d1d0.js"]));const Xu={factor:0,units:-4},Zu=Vc(tt.ONE,tt.ONE_MINUS_SRC_ALPHA);class Q extends Ar{constructor(){super(...arguments),this.output=O.Color,this.screenCenterOffsetUnitsEnabled=Be.World,this.transparencyPassType=ie.NONE,this.spherical=!1,this.occlusionTestEnabled=!0,this.signedDistanceFieldEnabled=!1,this.vvSize=!1,this.vvColor=!1,this.hasVerticalOffset=!1,this.hasScreenSizePerspective=!1,this.debugDrawLabelBorder=!1,this.binaryHighlightOcclusionEnabled=!0,this.hasSlicePlane=!1,this.hasPolygonOffset=!1,this.depthEnabled=!0,this.pixelSnappingEnabled=!0,this.isDraped=!1,this.hasMultipassGeometry=!1,this.hasMultipassTerrain=!1,this.cullAboveGround=!1,this.occlusionPass=!1,this.objectAndLayerIdColorInstanced=!1}}g([x({count:O.COUNT})],Q.prototype,"output",void 0),g([x({count:Be.COUNT})],Q.prototype,"screenCenterOffsetUnitsEnabled",void 0),g([x({count:ie.COUNT})],Q.prototype,"transparencyPassType",void 0),g([x()],Q.prototype,"spherical",void 0),g([x()],Q.prototype,"occlusionTestEnabled",void 0),g([x()],Q.prototype,"signedDistanceFieldEnabled",void 0),g([x()],Q.prototype,"vvSize",void 0),g([x()],Q.prototype,"vvColor",void 0),g([x()],Q.prototype,"hasVerticalOffset",void 0),g([x()],Q.prototype,"hasScreenSizePerspective",void 0),g([x()],Q.prototype,"debugDrawLabelBorder",void 0),g([x()],Q.prototype,"binaryHighlightOcclusionEnabled",void 0),g([x()],Q.prototype,"hasSlicePlane",void 0),g([x()],Q.prototype,"hasPolygonOffset",void 0),g([x()],Q.prototype,"depthEnabled",void 0),g([x()],Q.prototype,"pixelSnappingEnabled",void 0),g([x()],Q.prototype,"isDraped",void 0),g([x()],Q.prototype,"hasMultipassGeometry",void 0),g([x()],Q.prototype,"hasMultipassTerrain",void 0),g([x()],Q.prototype,"cullAboveGround",void 0),g([x()],Q.prototype,"occlusionPass",void 0),g([x()],Q.prototype,"objectAndLayerIdColorInstanced",void 0),g([x({constValue:!0})],Q.prototype,"hasSliceInVertexProgram",void 0),g([x({constValue:!1})],Q.prototype,"hasVvInstancing",void 0);class Hf extends Vi{constructor(e){super(e,new ap),this._configuration=new Q}getConfiguration(e,r){return this._configuration.output=e,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled=this.parameters.centerOffsetUnits==="screen"?Be.Screen:Be.World,this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.isDraped=this.parameters.isDraped,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.vvSize=!!this.parameters.vvSizeEnabled,this._configuration.vvColor=!!this.parameters.vvColorEnabled,this._configuration.occlusionPass=r.slot===W.OCCLUSION_PIXELS&&this.parameters.occlusionTest&&(e===O.Color||e===O.Alpha),e===O.Color&&(this._configuration.debugDrawLabelBorder=!!As.LABELS_SHOW_BORDER),e===O.Highlight&&(this._configuration.binaryHighlightOcclusionEnabled=this.parameters.binaryHighlightOcclusion),this._configuration.depthEnabled=this.parameters.depthEnabled,this._configuration.transparencyPassType=r.transparencyPassType,this._configuration.hasMultipassGeometry=r.multipassGeometry.enabled,this._configuration.hasMultipassTerrain=r.multipassTerrain.enabled,this._configuration.cullAboveGround=r.multipassTerrain.cullAboveGround,this._configuration}intersect(e,r,i,s,a,o){if(!i.options.selectionMode||!i.options.hud||!e.visible)return;const n=this.parameters;let l=1,c=1;if(ga(ws,r),A(e.shaderTransformer)){const w=e.shaderTransformer(So);l=w[0],c=w[5],Qu(ws)}const d=e.vertexAttributes.get(u.POSITION),f=e.vertexAttributes.get(u.SIZE),p=e.vertexAttributes.get(u.NORMAL),h=e.vertexAttributes.get(u.AUXPOS1);Oe(d.size>=3);const v=i.point,_=i.camera,S=Li(n);l*=_.pixelRatio,c*=_.pixelRatio;const T=this.parameters.centerOffsetUnits==="screen";for(let w=0;w<d.data.length/d.size;w++){const y=w*d.size;H(ve,d.data[y],d.data[y+1],d.data[y+2]),se(ve,ve,r);const R=w*f.size;ft[0]=f.data[R]*l,ft[1]=f.data[R+1]*c,se(ve,ve,_.viewMatrix);const C=w*h.size;if(H(Ie,h.data[C+0],h.data[C+1],h.data[C+2]),!T&&(ve[0]+=Ie[0],ve[1]+=Ie[1],Ie[2]!==0)){const F=Ie[2];de(Ie,ve),ne(ve,ve,Z(Ie,Ie,F))}const b=w*p.size;if(H(Nr,p.data[b],p.data[b+1],p.data[b+2]),this._normalAndViewAngle(Nr,ws,_,xs),this._applyVerticalOffsetTransformationView(ve,xs,_,Ss),_.applyProjection(ve,Se),Se[0]>-1){Se[0]=Math.floor(Se[0]),Se[1]=Math.floor(Se[1]),T&&(Ie[0]||Ie[1])&&(Se[0]+=Ie[0],Ie[1]!==0&&(Se[1]+=yc(Ie[1],Ss.factorAlignment)),_.unapplyProjection(Se,ve)),Se[0]+=this.parameters.screenOffset[0],Se[1]+=this.parameters.screenOffset[1],Sc(ft,Ss.factor,ft);const F=rp*_.pixelRatio;let E=0;if(n.textureIsSignedDistanceField&&(E=n.outlineSize*_.pixelRatio/2),v&&_o(v,Se[0],Se[1],ft,F,E,n,S)){const U=i.ray;if(se(yo,ve,dr(tp,_.viewMatrix)),Se[0]=v[0],Se[1]=v[1],_.unprojectFromRenderScreen(Se,ve)){const pe=$();k(pe,U.direction);const D=1/nt(pe);Z(pe,pe,D),o(Ot(U.origin,ve)*D,pe,-1,!0,1,yo)}}}}}intersectDraped(e,r,i,s,a,o){const n=e.vertexAttributes.get(u.POSITION),l=e.vertexAttributes.get(u.SIZE),c=this.parameters,d=Li(c);let f=1,p=1;if(A(e.shaderTransformer)){const v=e.shaderTransformer(So);f=v[0],p=v[5]}f*=e.screenToWorldRatio,p*=e.screenToWorldRatio;const h=ip*e.screenToWorldRatio;for(let v=0;v<n.data.length/n.size;v++){const _=v*n.size,S=n.data[_],T=n.data[_+1],w=v*l.size;ft[0]=l.data[w]*f,ft[1]=l.data[w+1]*p;let y=0;c.textureIsSignedDistanceField&&(y=c.outlineSize*e.screenToWorldRatio/2),_o(s,S,T,ft,h,y,c,d)&&a(o.dist,o.normal,-1,!1)}}createBufferWriter(){return new np(this)}_normalAndViewAngle(e,r,i,s){return Uu(r)&&(r=ga(ep,r)),Dl(s.normal,e,r),se(s.normal,s.normal,i.viewInverseTransposeMatrix),s.cosAngle=ct(In,sp),s}_updateScaleInfo(e,r,i){const s=this.parameters;A(s.screenSizePerspective)?Ta(i,r,s.screenSizePerspective,e.factor):(e.factor.scale=1,e.factor.factor=0,e.factor.minPixelSize=0,e.factor.paddingPixels=0),A(s.screenSizePerspectiveAlignment)?Ta(i,r,s.screenSizePerspectiveAlignment,e.factorAlignment):(e.factorAlignment.factor=e.factor.factor,e.factorAlignment.scale=e.factor.scale,e.factorAlignment.minPixelSize=e.factor.minPixelSize,e.factorAlignment.paddingPixels=e.factor.paddingPixels)}applyShaderOffsetsView(e,r,i,s,a,o,n){const l=this._normalAndViewAngle(r,i,a,xs);return this._applyVerticalGroundOffsetView(e,l,a,n),this._applyVerticalOffsetTransformationView(n,l,a,o),this._applyPolygonOffsetView(n,l,s[3],a,n),this._applyCenterOffsetView(n,s,n),n}applyShaderOffsetsNDC(e,r,i,s,a){return this._applyCenterOffsetNDC(e,r,i,s),A(a)&&k(a,s),this._applyPolygonOffsetNDC(s,r,i,s),s}_applyPolygonOffsetView(e,r,i,s,a){const o=s.aboveGround?1:-1;let n=Math.sign(i);n===0&&(n=o);const l=o*n;if(this.parameters.shaderPolygonOffset<=0)return k(a,e);const c=zt(Math.abs(r.cosAngle),.01,1),d=1-Math.sqrt(1-c*c)/c/s.viewport[2];return Z(a,e,l>0?d:1/d),a}_applyVerticalGroundOffsetView(e,r,i,s){const a=nt(e),o=i.aboveGround?1:-1,n=.5*i.computeRenderPixelSizeAtDist(a),l=Z(ve,r.normal,o*n);return re(s,e,l),s}_applyVerticalOffsetTransformationView(e,r,i,s){const a=this.parameters;if(!a.verticalOffset||!a.verticalOffset.screenLength){if(a.screenSizePerspective||a.screenSizePerspectiveAlignment){const c=nt(e);this._updateScaleInfo(s,c,r.cosAngle)}else s.factor.scale=1,s.factorAlignment.scale=1;return e}const o=nt(e),n=ae(a.screenSizePerspectiveAlignment,a.screenSizePerspective),l=wc(i,o,a.verticalOffset,r.cosAngle,n);return this._updateScaleInfo(s,o,r.cosAngle),Z(r.normal,r.normal,l),re(e,e,r.normal)}_applyCenterOffsetView(e,r,i){const s=this.parameters.centerOffsetUnits!=="screen";return i!==e&&k(i,e),s&&(i[0]+=r[0],i[1]+=r[1],r[2]&&(de(Nr,i),re(i,i,Z(Nr,Nr,r[2])))),i}_applyCenterOffsetNDC(e,r,i,s){const a=this.parameters.centerOffsetUnits!=="screen";return s!==e&&k(s,e),a||(s[0]+=r[0]/i.fullWidth*2,s[1]+=r[1]/i.fullHeight*2),s}_applyPolygonOffsetNDC(e,r,i,s){const a=this.parameters.shaderPolygonOffset;if(e!==s&&k(s,e),a){const o=i.aboveGround?1:-1,n=o*Math.sign(r[3]);s[2]-=(n||o)*a}return s}requiresSlot(e,r){if(r===O.Color||r===O.Alpha||r===O.Highlight||r===O.ObjectAndLayerIdColor){if(e===W.DRAPED_MATERIAL)return!0;const{drawInSecondSlot:i,occlusionTest:s}=this.parameters;return e===(i?W.LABEL_MATERIAL:W.HUD_MATERIAL)||s&&e===W.OCCLUSION_PIXELS}return!1}createGLMaterial(e){return new Yu(e)}calculateRelativeScreenBounds(e,r,i=cr()){return Ju(this.parameters,e,r,i),i[2]=i[0]+e[0],i[3]=i[1]+e[1],i}}class Yu extends xc{constructor(e){super({...e,...e.material.parameters})}selectProgram(e){return this.ensureTechnique(Zi,e)}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.selectProgram(e)}}function Ju(t,e,r,i=Ku){return Tr(i,t.anchorPosition),i[0]*=-e[0],i[1]*=-e[1],i[0]+=t.screenOffset[0]*r,i[1]+=t.screenOffset[1]*r,i}function Qu(t){const e=t[0],r=t[1],i=t[2],s=t[3],a=t[4],o=t[5],n=t[6],l=t[7],c=t[8],d=1/Math.sqrt(e*e+r*r+i*i),f=1/Math.sqrt(s*s+a*a+o*o),p=1/Math.sqrt(n*n+l*l+c*c);return t[0]=e*d,t[1]=r*d,t[2]=i*d,t[3]=s*f,t[4]=a*f,t[5]=o*f,t[6]=n*p,t[7]=l*p,t[8]=c*p,t}function _o(t,e,r,i,s,a,o,n){let l=e-s-(n[0]>0?i[0]*n[0]:0),c=l+i[0]+2*s,d=r-s-(n[1]>0?i[1]*n[1]:0),f=d+i[1]+2*s;const p=o.distanceFieldBoundingBox;return o.textureIsSignedDistanceField&&A(p)&&(l+=i[0]*p[0],d+=i[1]*p[1],c-=i[0]*(1-p[2]),f-=i[1]*(1-p[3]),l-=a,c+=a,d-=a,f+=a),t[0]>l&&t[0]<c&&t[1]>d&&t[1]<f}const Ss=new Hu,Ku=K(),ve=$(),Nr=$(),Se=ke(),In=$(),yo=$(),ws=Ys(),ep=Ys(),tp=Y(),Ie=$(),xs={normal:In,cosAngle:0},So=Y(),rp=1,ip=2,ft=[0,0],sp=Gr(0,0,1);class ap extends Oc{constructor(){super(...arguments),this.renderOccluded=xt.Occlude,this.color=_r(1,1,1,1),this.texCoordScale=[1,1],this.polygonOffset=!1,this.anchorPosition=Ns(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.outlineColor=_r(1,1,1,1),this.outlineSize=0,this.vvSizeEnabled=!1,this.vvSizeMinSize=[1,1,1],this.vvSizeMaxSize=[100,100,100],this.vvSizeOffset=[0,0,0],this.vvSizeFactor=[1,1,1],this.vvColorEnabled=!1,this.vvColorValues=[0,0,0,0,0,0,0,0],this.vvColorColors=[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.binaryHighlightOcclusion=!0,this.centerOffsetUnits="world",this.drawInSecondSlot=!1,this.depthEnabled=!0,this.isDraped=!1}}const Mn=bt().vec3f(u.POSITION).vec3f(u.NORMAL).vec2f(u.UV0).vec4u8(u.COLOR).vec2f(u.SIZE).vec4f(u.AUXPOS1).vec4f(u.AUXPOS2),op=Mn.clone().vec4u8(u.OBJECTANDLAYERIDCOLOR);class np{constructor(e){this._material=e,this.vertexBufferLayout=St("enable-feature:objectAndLayerId-rendering")?op:Mn}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return 6*e.indices.get(u.POSITION).length}write(e,r,i,s,a){Tc(i.indices.get(u.POSITION),i.vertexAttributes.get(u.POSITION).data,e,s.position,a,6),Cc(i.indices.get(u.NORMAL),i.vertexAttributes.get(u.NORMAL).data,r,s.normal,a,6);const o=i.vertexAttributes.get(u.UV0).data;let n,l,c,d;if(o==null||o.length<4){const T=this._material.parameters;n=0,l=0,c=T.texCoordScale[0],d=T.texCoordScale[1]}else n=o[0],l=o[1],c=o[2],d=o[3];c=Math.min(1.99999,c+1),d=Math.min(1.99999,d+1);let f=i.indices.get(u.POSITION).length,p=a;const h=s.uv0;for(let T=0;T<f;++T)h.set(p,0,n),h.set(p,1,l),p+=1,h.set(p,0,c),h.set(p,1,l),p+=1,h.set(p,0,c),h.set(p,1,d),p+=1,h.set(p,0,c),h.set(p,1,d),p+=1,h.set(p,0,n),h.set(p,1,d),p+=1,h.set(p,0,n),h.set(p,1,l),p+=1;bc(i.indices.get(u.COLOR),i.vertexAttributes.get(u.COLOR).data,4,s.color,a,6);const v=i.indices.get(u.SIZE),_=i.vertexAttributes.get(u.SIZE).data;f=v.length;const S=s.size;p=a;for(let T=0;T<f;++T){const w=_[2*v[T]],y=_[2*v[T]+1];for(let R=0;R<6;++R)S.set(p,0,w),S.set(p,1,y),p+=1}if(i.indices.get(u.AUXPOS1)&&i.vertexAttributes.get(u.AUXPOS1)?Ca(i.indices.get(u.AUXPOS1),i.vertexAttributes.get(u.AUXPOS1).data,s.auxpos1,a,6):ba(s.auxpos1,a,6*f),i.indices.get(u.AUXPOS2)&&i.vertexAttributes.get(u.AUXPOS2)?Ca(i.indices.get(u.AUXPOS2),i.vertexAttributes.get(u.AUXPOS2).data,s.auxpos2,a,6):ba(s.auxpos2,a,6*f),A(i.objectAndLayerIdColor)&&i.indices.get(u.POSITION)){const T=i.indices.get(u.POSITION).length,w=s.getField(u.OBJECTANDLAYERIDCOLOR,Nc);Ac(i.objectAndLayerIdColor,w,T,a,6)}}}function lp(t){const e=new Yr,{vertex:r,fragment:i}=e,s=t.output===O.Depth,a=t.hasMultipassTerrain&&(t.output===O.Color||t.output===O.Alpha);return Jr(r,t),e.include(ks,t),e.include(Ho,t),e.include(Hs,t),e.attributes.add(u.POSITION,"vec3"),e.varyings.add("vpos","vec3"),a&&e.varyings.add("depth","float"),s&&(e.include(Mo,t),Rc(e),Lo(e)),r.code.add(m`
    void main(void) {
      vpos = position;
      forwardNormalizedVertexColor();
      forwardObjectAndLayerIdColor();
      ${a?"depth = (view * vec4(vpos, 1.0)).z;":""}
      gl_Position = ${s?m`transformPositionWithDepth(proj, view, vpos, nearFar, linearDepth);`:m`transformPosition(proj, view, vpos);`}
    }
  `),e.include(vt,t),a&&e.include(Gs,t),i.include(Ui),i.uniforms.add(new Pe("eColor",o=>o.color)),t.output===O.Highlight&&e.include(Gi,t),i.code.add(m`
  void main() {
    discardBySlice(vpos);
    ${a?"terrainDepthTest(gl_FragCoord, depth);":""}
    vec4 fColor = ${t.hasVertexColors?"vColor * eColor;":"eColor;"}

    ${t.output===O.ObjectAndLayerIdColor?m`fColor.a = 1.0;`:""}

    if (fColor.a < ${m.float(Ue)}) {
      discard;
    }

    ${t.output===O.Alpha?m`gl_FragColor = vec4(fColor.a);`:""}

    ${t.output===O.Color?m`gl_FragColor = highlightSlice(fColor, vpos); ${t.transparencyPassType===ie.Color?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}`:""}
    ${t.output===O.Highlight?m`outputHighlight();`:""};
    ${t.output===O.Depth?m`outputDepth(linearDepth);`:""};
    ${t.output===O.ObjectAndLayerIdColor?m`outputObjectAndLayerIdColor();`:""}
  }
  `),e}const cp=Object.freeze(Object.defineProperty({__proto__:null,build:lp},Symbol.toStringTag,{value:"Module"}));class Yi extends Rr{initializeConfiguration(e,r){r.hasWebGL2Context=e.rctx.type===ji.WEBGL2}initializeProgram(e){return new Er(e.rctx,Yi.shader.get().build(this.configuration),Qr)}_createPipeline(e,r){const i=this.configuration,s=e===ie.NONE,a=e===ie.FrontFace;return et({blending:i.output!==O.Color&&i.output!==O.Alpha||!i.transparent?null:s?Ur:Wi(e),culling:Hc(i.cullFace),depthTest:{func:Js(e)},depthWrite:(s||a)&&i.writeDepth?Sr:null,colorWrite:lt,stencilWrite:i.hasOccludees?xi:null,stencilTest:i.hasOccludees?r?Oi:Ws:null,polygonOffset:s||a?i.polygonOffset?dp:null:qo(i.enableOffset)})}initializePipeline(){return this._occludeePipelineState=this._createPipeline(this.configuration.transparencyPassType,!0),this._createPipeline(this.configuration.transparencyPassType,!1)}getPipelineState(e,r){return r?this._occludeePipelineState:super.getPipelineState(e,r)}}Yi.shader=new Pr(cp,()=>Cr(()=>import("./ColorMaterial.glsl.cbd973c6.js"),["assets/ColorMaterial.glsl.cbd973c6.js","assets/VertexColor.glsl.e3d82815.js","assets/index.3255d2a5.js","assets/index.e51050de.css","assets/requestImageUtils.828b299e.js","assets/OrderIndependentTransparency.43c6e481.js","assets/enums.3c1fa5b5.js","assets/basicInterfaces.f8f3b23b.js","assets/Texture.d66dc1cb.js","assets/VertexArrayObject.ad007c8f.js","assets/Util.3efb1a6b.js","assets/mat4f64.9070f685.js","assets/triangle.1c8f4155.js","assets/sphere.67ec4acb.js","assets/mat3f64.9180efcb.js","assets/quatf64.1dc83f1c.js","assets/lineSegment.1a0fd96e.js","assets/Indices.27b9c798.js","assets/VertexAttribute.34e3daf1.js","assets/doublePrecisionUtils.d6c628ce.js","assets/quat.eb7bbc3a.js","assets/vec3f32.4d8dc001.js","assets/BufferView.32a50625.js","assets/VertexElementDescriptor.5da9dfe9.js","assets/plane.a0a08b54.js","assets/Attribute.98e6fe67.js","assets/triangulationUtils.2ec0b7a6.js","assets/earcut.a219bf29.js","assets/deduplicate.97d7ef01.js","assets/hydratedFeatures.b4cbc12d.js","assets/InterleavedLayout.a42ad5fa.js","assets/types.bf551170.js","assets/NestedMap.2ac03b78.js","assets/Octree.449e609a.js","assets/floatRGBA.7b501bd7.js","assets/boundedPlane.91a64206.js","assets/glUtil.9de5d1d0.js"]));const dp={factor:1,units:1};class Re extends Ar{constructor(){super(...arguments),this.output=O.Color,this.cullFace=Qs.None,this.hasSlicePlane=!1,this.hasVertexColors=!1,this.transparent=!1,this.polygonOffset=!1,this.enableOffset=!0,this.writeDepth=!0,this.hasOccludees=!1,this.transparencyPassType=ie.NONE,this.hasMultipassTerrain=!1,this.cullAboveGround=!1,this.objectAndLayerIdColorInstanced=!1}}g([x({count:O.COUNT})],Re.prototype,"output",void 0),g([x({count:Qs.COUNT})],Re.prototype,"cullFace",void 0),g([x()],Re.prototype,"hasSlicePlane",void 0),g([x()],Re.prototype,"hasVertexColors",void 0),g([x()],Re.prototype,"transparent",void 0),g([x()],Re.prototype,"polygonOffset",void 0),g([x()],Re.prototype,"enableOffset",void 0),g([x()],Re.prototype,"writeDepth",void 0),g([x()],Re.prototype,"hasOccludees",void 0),g([x({count:ie.COUNT})],Re.prototype,"transparencyPassType",void 0),g([x()],Re.prototype,"hasMultipassTerrain",void 0),g([x()],Re.prototype,"cullAboveGround",void 0),g([x()],Re.prototype,"objectAndLayerIdColorInstanced",void 0);class Gf extends xn{constructor(e){super(e,new up),this.supportsEdges=!0,this._configuration=new Re}getConfiguration(e,r){return this._configuration.output=e,this._configuration.cullFace=this.parameters.cullFace,this._configuration.hasVertexColors=this.parameters.hasVertexColors,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.transparent=this.parameters.transparent,this._configuration.polygonOffset=this.parameters.polygonOffset,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration.transparencyPassType=r.transparencyPassType,this._configuration.enableOffset=r.camera.relativeElevation<Xo,this._configuration.hasMultipassTerrain=r.multipassTerrain.enabled,this._configuration.cullAboveGround=r.multipassTerrain.cullAboveGround,this._configuration}requiresSlot(e,r){return r===O.Color||r===O.Alpha||r===O.Highlight||r===O.Depth&&this.parameters.writeLinearDepth||r===O.ObjectAndLayerIdColor?e===W.DRAPED_MATERIAL?!0:r===O.Highlight?e===W.OPAQUE_MATERIAL:e===(this.parameters.transparent?this.parameters.writeDepth?W.TRANSPARENT_MATERIAL:W.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL:W.OPAQUE_MATERIAL):!1}createGLMaterial(e){return new hp(e)}createBufferWriter(){return new qs(St("enable-feature:objectAndLayerId-rendering")?Dh:wn)}}class hp extends Hi{_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:e.hasOccludees})}beginSlot(e){return this._output!==O.Color&&this._output!==O.Alpha||this._updateOccludeeState(e),this.ensureTechnique(Yi,e)}}class up extends Xs{constructor(){super(...arguments),this.color=Fs,this.transparent=!1,this.writeDepth=!0,this.writeLinearDepth=!1,this.hasVertexColors=!1,this.polygonOffset=!1,this.hasSlicePlane=!1,this.cullFace=Qs.None,this.hasOccludees=!1}}const _e={dash:[4,3],dot:[1,3],"long-dash":[8,3],"short-dash":[4,1],"short-dot":[1,1]},pp={dash:_e.dash,"dash-dot":[..._e.dash,..._e.dot],dot:_e.dot,"long-dash":_e["long-dash"],"long-dash-dot":[..._e["long-dash"],..._e.dot],"long-dash-dot-dot":[..._e["long-dash"],..._e.dot,..._e.dot],none:null,"short-dash":_e["short-dash"],"short-dash-dot":[..._e["short-dash"],..._e["short-dot"]],"short-dash-dot-dot":[..._e["short-dash"],..._e["short-dot"],..._e["short-dot"]],"short-dot":_e["short-dot"],solid:null},fp=8;function mp(t,e=2){return N(t)?t:{pattern:t.slice(),pixelRatio:e}}function Wf(t,e=2){return{pattern:[t,t],pixelRatio:e}}function Bf(t){return A(t)&&t.type==="style"?gp(t.style):null}function gp(t){return A(t)?mp(pp[t],fp):null}function kf(t,e,r=null){const i=[],s=[],a=e.mapPositions;vp(e,s,i);const o=s[0][1].data,n=i[0][1].length,l=new Array(n).fill(0);return _p(e,s,i,l),wp(e,s,i,l),yp(e,s,i,l),Sp(e,s,i,l),xp(e,s,i,l),Op(e,s,i,l),Tp(e,s,i,o),new Ne(t,s,i,a,br.Line,r)}function vp(t,e,r){const{attributeData:{position:i},removeDuplicateStartEnd:s}=t,a=Cp(i)&&s,o=i.length/3-(a?1:0),n=new Array(2*(o-1)),l=a?i.slice(0,i.length-3):i;let c=0;for(let d=0;d<o-1;d++)n[c++]=d,n[c++]=d+1;e.push([u.POSITION,new j(l,3,a)]),r.push([u.POSITION,n])}function _p(t,e,r,i){if(A(t.attributeData.colorFeature))return;const s=t.attributeData.color;e.push([u.COLOR,new j(ae(s,zi),4)]),r.push([u.COLOR,i])}function yp(t,e,r,i){if(!A(t.attributeData.normal))return;const s=t.attributeData.normal;e.push([u.NORMAL,new j(s,3)]),r.push([u.NORMAL,i])}function Sp(t,e,r,i){const s=t.attributeData.colorFeature;N(s)||(e.push([u.COLORFEATUREATTRIBUTE,new j([s],1,!0)]),r.push([u.COLOR,i]))}function wp(t,e,r,i){if(A(t.attributeData.sizeFeature))return;const s=t.attributeData.size;e.push([u.SIZE,new j([ae(s,1)],1,!0)]),r.push([u.SIZE,i])}function xp(t,e,r,i){const s=t.attributeData.sizeFeature;N(s)||(e.push([u.SIZEFEATUREATTRIBUTE,new j([s],1,!0)]),r.push([u.SIZEFEATUREATTRIBUTE,i]))}function Op(t,e,r,i){const s=t.attributeData.opacityFeature;N(s)||(e.push([u.OPACITYFEATUREATTRIBUTE,new j([s],1,!0)]),r.push([u.OPACITYFEATUREATTRIBUTE,i]))}function Tp(t,e,r,i){if(N(t.overlayInfo)||t.overlayInfo.renderCoordsHelper.viewingMode!==Tt.Global||!t.overlayInfo.spatialReference.isGeographic)return;const s=Zs(i.length),a=$l(t.overlayInfo.spatialReference);for(let p=0;p<s.length;p+=3)Il(i,p,s,p,a);const o=i.length/3,n=Ve(o+1);let l=bp,c=Ap,d=0,f=0;H(l,s[f++],s[f++],s[f++]),n[0]=0;for(let p=1;p<o+1;++p)p===o&&(f=0),H(c,s[f++],s[f++],s[f++]),d+=Ml(l,c),n[p]=d,[l,c]=[c,l];e.push([u.DISTANCETOSTART,new j(n,1,!0)]),r.push([u.DISTANCETOSTART,r[0][1]])}function Cp(t){const e=t.length;return t[0]===t[e-3]&&t[1]===t[e-2]&&t[2]===t[e-1]}const bp=$(),Ap=$();function qf(t,e,r,i){const s=t.type==="polygon"?Ti.CCW_IS_HOLE:Ti.NONE,a=t.type==="polygon"?t.rings:t.paths,{position:o,outlines:n}=Go(a,!!t.hasZ,s),l=Zs(o.length),c=Ou(o,t.spatialReference,0,l,0,o,0,o.length/3,e,r,i),d=c!=null;return{lines:d?Ln(n,o,l):[],projectionSuccess:d,sampledElevation:c}}function Xf(t,e){const r=t.type==="polygon"?Ti.CCW_IS_HOLE:Ti.NONE,i=t.type==="polygon"?t.rings:t.paths,{position:s,outlines:a}=Go(i,!1,r),o=yi(s,t.spatialReference,0,s,e,0,s.length/3);for(let n=2;n<s.length;n+=3)s[n]=nu;return{lines:o?Ln(a,s):[],projectionSuccess:o}}function Ln(t,e,r=null){const i=new Array;for(const{index:s,count:a}of t){if(a<=1)continue;const o=3*s,n=3*a;i.push({position:Aa(e,3*s,3*a),mapPositions:A(r)?Aa(r,o,n):void 0})}return i}function Rp(t){const e=new Yr,{vertex:r,fragment:i}=e;return e.include(ks,t),e.include(Ho,t),e.include(dn,t),Jr(r,t),t.stippleEnabled&&(e.attributes.add(u.UV0,"vec2"),e.attributes.add(u.AUXPOS1,"vec3"),r.uniforms.add(new Pe("viewport",(s,a)=>a.camera.fullViewport))),e.attributes.add(u.POSITION,"vec3"),e.varyings.add("vpos","vec3"),r.code.add(m`void main(void) {
vpos = position;
forwardNormalizedVertexColor();
gl_Position = transformPosition(proj, view, vpos);`),t.stippleEnabled&&(r.code.add(m`vec4 vpos2 = transformPosition(proj, view, auxpos1);
vec2 ndcToPixel = viewport.zw * 0.5;
float lineSegmentPixelSize = length((vpos2.xy / vpos2.w - gl_Position.xy / gl_Position.w) * ndcToPixel);`),t.draped?r.uniforms.add(new B("worldToScreenRatio",(s,a)=>1/a.screenToPCSRatio)):r.code.add(m`vec3 segmentCenter = (position + auxpos1) * 0.5;
float worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`),r.code.add(m`float discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);`),t.draped?r.code.add(m`float startPseudoScreen = uv0.y * discreteWorldToScreenRatio - mix(0.0, lineSegmentPixelSize, uv0.x);
float segmentLengthPseudoScreen = lineSegmentPixelSize;`):r.code.add(m`float segmentLengthRender = length(position - auxpos1);
float startPseudoScreen = mix(uv0.y, uv0.y - segmentLengthRender, uv0.x) * discreteWorldToScreenRatio;
float segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`),r.uniforms.add(new B("stipplePatternPixelSize",s=>ta(s))),r.code.add(m`vec2 stippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, lineSegmentPixelSize, stipplePatternPixelSize);
vStippleDistance = mix(stippleDistanceLimits.x, stippleDistanceLimits.y, uv0.x);
vStippleDistance *= gl_Position.w;`)),r.code.add(m`}`),t.output===O.Highlight&&e.include(Gi,t),e.include(vt,t),i.uniforms.add(new B("alphaCoverage",(s,a)=>Math.min(1,s.width*a.camera.pixelRatio))),t.hasVertexColors||i.uniforms.add(new Pe("constantColor",s=>s.color)),i.code.add(m`
  void main() {
    discardBySlice(vpos);

    vec4 color = ${t.hasVertexColors?"vColor":"constantColor"};

    float stippleAlpha = getStippleAlpha();
    discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);

    vec4 finalColor = blendStipple(vec4(color.rgb, color.a * alphaCoverage), stippleAlpha);

    ${t.output===O.ObjectAndLayerIdColor?m`finalColor.a = 1.0;`:""}

    if (finalColor.a < ${m.float(Ue)}) {
      discard;
    }

    ${t.output===O.Color?m`gl_FragColor = highlightSlice(finalColor, vpos);`:""}
    ${t.output===O.Highlight?m`outputHighlight();`:""}
  }
  `),e}const Ep=Object.freeze(Object.defineProperty({__proto__:null,build:Rp},Symbol.toStringTag,{value:"Module"}));class Ji extends Rr{get _stippleEnabled(){return this.configuration.stippleEnabled&&this.configuration.output!==O.Highlight}initializeConfiguration(e,r){r.hasWebGL2Context=e.rctx.type===ji.WEBGL2}initializeProgram(e){return new Er(e.rctx,Ji.shader.get().build(this.configuration),Qr)}initializePipeline(){const e=this.configuration,r=Zo(tt.SRC_ALPHA,tt.ONE,tt.ONE_MINUS_SRC_ALPHA,tt.ONE_MINUS_SRC_ALPHA),i=(s,a=null,o=null)=>et({blending:a,depthTest:No,depthWrite:o,colorWrite:lt,stencilWrite:e.hasOccludees?xi:null,stencilTest:e.hasOccludees?s?Oi:Ws:null});return e.output===O.Color?(this._occludeePipelineState=i(!0,e.transparent||this._stippleEnabled?r:null,Sr),i(!1,e.transparent||this._stippleEnabled?r:null,Sr)):i(!1)}get primitiveType(){return Ht.LINES}getPipelineState(e,r){return r?this._occludeePipelineState:super.getPipelineState(e,r)}}Ji.shader=new Pr(Ep,()=>Cr(()=>import("./NativeLine.glsl.07960200.js"),["assets/NativeLine.glsl.07960200.js","assets/VertexColor.glsl.e3d82815.js","assets/index.3255d2a5.js","assets/index.e51050de.css","assets/requestImageUtils.828b299e.js","assets/OrderIndependentTransparency.43c6e481.js","assets/enums.3c1fa5b5.js","assets/basicInterfaces.f8f3b23b.js","assets/Texture.d66dc1cb.js","assets/VertexArrayObject.ad007c8f.js","assets/Util.3efb1a6b.js","assets/mat4f64.9070f685.js","assets/triangle.1c8f4155.js","assets/sphere.67ec4acb.js","assets/mat3f64.9180efcb.js","assets/quatf64.1dc83f1c.js","assets/lineSegment.1a0fd96e.js","assets/Indices.27b9c798.js","assets/VertexAttribute.34e3daf1.js","assets/doublePrecisionUtils.d6c628ce.js","assets/quat.eb7bbc3a.js","assets/vec3f32.4d8dc001.js","assets/BufferView.32a50625.js","assets/VertexElementDescriptor.5da9dfe9.js","assets/plane.a0a08b54.js","assets/Attribute.98e6fe67.js","assets/triangulationUtils.2ec0b7a6.js","assets/earcut.a219bf29.js","assets/deduplicate.97d7ef01.js","assets/hydratedFeatures.b4cbc12d.js","assets/InterleavedLayout.a42ad5fa.js","assets/types.bf551170.js","assets/NestedMap.2ac03b78.js","assets/Octree.449e609a.js","assets/floatRGBA.7b501bd7.js","assets/boundedPlane.91a64206.js","assets/glUtil.9de5d1d0.js"]));class Me extends Ar{constructor(){super(...arguments),this.output=O.Color,this.hasSlicePlane=!1,this.hasVertexColors=!1,this.transparent=!1,this.draped=!1,this.stippleEnabled=!1,this.stippleOffColorEnabled=!1,this.stipplePreferContinuous=!0,this.hasOccludees=!1}}g([x({count:O.COUNT})],Me.prototype,"output",void 0),g([x()],Me.prototype,"hasSlicePlane",void 0),g([x()],Me.prototype,"hasVertexColors",void 0),g([x()],Me.prototype,"transparent",void 0),g([x()],Me.prototype,"draped",void 0),g([x()],Me.prototype,"stippleEnabled",void 0),g([x()],Me.prototype,"stippleOffColorEnabled",void 0),g([x()],Me.prototype,"stipplePreferContinuous",void 0),g([x()],Me.prototype,"hasOccludees",void 0),g([x({constValue:!1})],Me.prototype,"stippleRequiresClamp",void 0),g([x({constValue:!1})],Me.prototype,"stippleScaleWithLineWidth",void 0),g([x({constValue:!1})],Me.prototype,"stippleRequiresStretchMeasure",void 0);var Ni;(function(t){t[t.START=0]="START",t[t.END=1]="END"})(Ni||(Ni={}));class Zf extends Vi{constructor(e){super(e,new $p),this._configuration=new Me}getConfiguration(e,r){this._configuration.output=e,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVertexColors=this.parameters.hasVertexColors,this._configuration.transparent=this.parameters.color[3]<1||this.parameters.width<1,this._configuration.draped=r.slot===W.DRAPED_MATERIAL;const i=A(this.parameters.stipplePattern);return this._configuration.stippleEnabled=i,this._configuration.stippleOffColorEnabled=i&&A(this.parameters.stippleOffColor),this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration.stipplePreferContinuous=this.parameters.stipplePreferContinuous,this._configuration}intersect(e,r,i,s,a,o){if(!i.options.selectionMode||!e.visible)return;if(!Wo(r))return void Zr.getLogger("esri.views.3d.webgl-engine.materials.NativeLineMaterial").error("intersection assumes a translation-only matrix");const n=e.vertexAttributes.get(u.POSITION).data,l=i.camera,c=Mp;Tr(c,i.point);const d=2;H(Fr[0],c[0]-d,c[1]+d,0),H(Fr[1],c[0]+d,c[1]+d,0),H(Fr[2],c[0]+d,c[1]-d,0),H(Fr[3],c[0]-d,c[1]-d,0);for(let _=0;_<4;_++)if(!l.unprojectFromRenderScreen(Fr[_],at[_]))return;gt(l.eye,at[0],at[1],Os),gt(l.eye,at[1],at[2],Ts),gt(l.eye,at[2],at[3],Cs),gt(l.eye,at[3],at[0],bs);let f=Number.MAX_VALUE,p=0;for(let _=0;_<n.length-5;_+=3){if(we[0]=n[_]+r[12],we[1]=n[_+1]+r[13],we[2]=n[_+2]+r[14],xe[0]=n[_+3]+r[12],xe[1]=n[_+4]+r[13],xe[2]=n[_+5]+r[14],ce(Os,we)<0&&ce(Os,xe)<0||ce(Ts,we)<0&&ce(Ts,xe)<0||ce(Cs,we)<0&&ce(Cs,xe)<0||ce(bs,we)<0&&ce(bs,xe)<0)continue;if(l.projectToRenderScreen(we,Mt),l.projectToRenderScreen(xe,Lt),Mt[2]<0&&Lt[2]>0){ne(Qe,we,xe);const T=l.frustum,w=-ce(T[_t.NEAR],we)/ct(Qe,Si(T[_t.NEAR]));Z(Qe,Qe,w),re(we,we,Qe),l.projectToRenderScreen(we,Mt)}else if(Mt[2]>0&&Lt[2]<0){ne(Qe,xe,we);const T=l.frustum,w=-ce(T[_t.NEAR],xe)/ct(Qe,Si(T[_t.NEAR]));Z(Qe,Qe,w),re(xe,xe,Qe),l.projectToRenderScreen(xe,Lt)}else if(Mt[2]<0&&Lt[2]<0)continue;Mt[2]=0,Lt[2]=0;const S=tn(hr(Mt,Lt,Oo),c);S<f&&(f=S,k(wo,we),k(xo,xe),p=_/3)}const h=i.rayBegin,v=i.rayEnd;if(f<d*d){let _=Number.MAX_VALUE;if(rn(hr(wo,xo,Oo),hr(h,v,Ip),It)){ne(It,It,h);const S=nt(It);Z(It,It,1/S),_=S/Ot(h,v)}o(_,It,p,!1)}}intersectDraped(e,r,i,s,a,o){if(!i.options.selectionMode)return;const n=e.vertexAttributes.get(u.POSITION).data,l=e.vertexAttributes.get(u.SIZE),c=l?l.data[0]:0,d=s[0],f=s[1],p=((c+1)/2+4)*e.screenToWorldRatio;let h=Number.MAX_VALUE,v=0;for(let _=0;_<n.length-5;_+=3){const S=n[_],T=n[_+1],w=d-S,y=f-T,R=n[_+3]-S,C=n[_+4]-T,b=zt((R*w+C*y)/(R*R+C*C),0,1),F=R*b-w,E=C*b-y,U=F*F+E*E;U<h&&(h=U,v=_/3)}h<p*p&&a(o.dist,o.normal,v,!1)}requiresSlot(e,r){return!(r!==O.Color&&r!==O.Highlight&&r!==O.ObjectAndLayerIdColor||e!==W.OPAQUE_MATERIAL&&e!==W.DRAPED_MATERIAL)}createGLMaterial(e){return new Pp(e)}createBufferWriter(){const e=this.parameters.hasVertexColors?wn:Eh;return N(this.parameters.stipplePattern)?new qs(e):new Dp(e.clone().vec3f(u.AUXPOS1).vec2f(u.UV0))}}class Pp extends Hi{constructor(){super(...arguments),this._stipplePattern=null}dispose(){super.dispose(),this._stippleTextureRepository.release(this._stipplePattern),this._stipplePattern=null}_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:e.hasOccludees})}beginSlot(e){this._output===O.Color&&this._updateOccludeeState(e);const r=this._material.parameters.stipplePattern;return this._stipplePattern!==r&&(this._material.setParameters(this._stippleTextureRepository.swap(this._stipplePattern,r)),this._stipplePattern=r),this.ensureTechnique(Ji,e)}}class Dp{constructor(e){this.vertexBufferLayout=e}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return e.indices.get(u.POSITION).length}write(e,r,i,s,a){Ec(i,this.vertexBufferLayout,e,r,s,a),this._writeAuxpos1(e,i,s,a),this._writeUV0(e,i,s,a)}_writeAuxpos1(e,r,i,s){const a=i.getField(u.AUXPOS1,Fc),o=r.indices.get(u.POSITION),n=r.vertexAttributes.get(u.POSITION).data,l=e,c=a.typedBufferStride,d=a.typedBuffer;s*=c;for(let f=0;f<o.length-1;f+=2)for(const p of[1,0]){const h=3*o[f+p],v=n[h],_=n[h+1],S=n[h+2],T=l[0]*v+l[4]*_+l[8]*S+l[12],w=l[1]*v+l[5]*_+l[9]*S+l[13],y=l[2]*v+l[6]*_+l[10]*S+l[14];d[s]=T,d[s+1]=w,d[s+2]=y,s+=c}}_writeUV0(e,r,i,s){var y;const a=i.getField(u.UV0,zc),o=r.indices.get(u.POSITION),n=r.vertexAttributes.get(u.POSITION).data,l=(y=r.vertexAttributes.get(u.DISTANCETOSTART))==null?void 0:y.data,c=a.typedBufferStride,d=a.typedBuffer;let f=0;d[s*=c]=Ni.START,d[s+1]=f,s+=c;const p=3*o[0],h=H(we,n[p],n[p+1],n[p+2]);e&&se(h,h,e);const v=xe,_=o.length-1;let S=1;const T=l?(R,C,b)=>f=l[b]:(R,C,b)=>f+=Ot(R,C);for(let R=1;R<_;R+=2){const C=3*o[R];H(v,n[C],n[C+1],n[C+2]),e&&se(v,v,e),T(h,v,S++);for(let b=0;b<2;++b)d[s]=1-b,d[s+1]=f,s+=c;k(h,v)}const w=3*o[_];H(v,n[w],n[w+1],n[w+2]),e&&se(v,v,e),T(h,v,S),d[s]=Ni.END,d[s+1]=f}}class $p extends Xs{constructor(){super(...arguments),this.color=zi,this.hasVertexColors=!1,this.hasSlicePlane=!1,this.width=1,this.stipplePreferContinuous=!0,this.hasOccludees=!1,this.stippleTexture=null}}const we=$(),xe=$(),Qe=$(),It=$(),Mt=Le(),Lt=Le(),wo=$(),xo=$(),Oo=Bi(),Ip=Bi(),Mp=$(),Fr=[Le(),Le(),Le(),Le()],at=[$(),$(),$(),$()],Os=dt(),Ts=dt(),Cs=dt(),bs=dt();export{Hf as $,bf as A,yf as B,kr as C,Sf as D,Ri as E,_f as F,_u as G,Uf as H,jf as I,En as J,If as K,Lu as L,Tf as M,pf as N,Of as O,ff as P,uf as Q,gf as R,Vf as S,Eu as T,wu as U,Rf as V,Ms as W,$f as X,zf as Y,Gu as Z,Vu as _,Ai as a,eh as a0,Be as a1,Lf as a2,Nf as a3,Mu as a4,Pf as a5,Ff as a6,Ke as a7,ra as a8,Gt as a9,Af as aA,Ei as aB,Ud as aC,lp as aD,Rp as aE,Bu as aF,Li as aG,Uh as aH,Or as aa,yd as ab,jd as ac,qr as ad,ia as ae,gn as af,lf as ag,fe as ah,cf as ai,Bf as aj,Ve as ak,gh as al,Ah as am,Ct as an,Wt as ao,Th as ap,Ef as aq,Df as ar,po as as,io as at,An as au,hf as av,Wh as aw,Gh as ax,df as ay,Qd as az,Dn as b,nu as c,Mf as d,Hr as e,wf as f,vf as g,Cf as h,hn as i,Gf as j,Xf as k,id as l,kf as m,Ou as n,Ed as o,qf as p,mf as q,Wf as r,V as s,hi as t,xn as u,Ph as v,Zf as w,ed as x,xf as y,Hd as z};
