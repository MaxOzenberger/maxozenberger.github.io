import{kN as I,at as E,kO as L,hR as j,a as z,z as k,a5 as v,a8 as A,kP as F,i0 as Q,a0 as B,t as R,J as K,e_ as W,kQ as $,kR as O,kS as q,kT as tt,f4 as et,d$ as it,kU as nt,h4 as st,a6 as _,a7 as ot,n as at,ah as lt}from"./index.3255d2a5.js";function G(t,n,i,e){var u,r;if(e==null||t.hasZ||(e=void 0),t.type==="point")return t.x+=n,t.y+=i,t.hasZ&&e!=null&&(t.z+=e),t;if(t.type==="multipoint"){const o=t.points;for(let a=0;a<o.length;a++)o[a]=N(o[a],n,i,e);return t}if(t.type==="extent")return t.xmin+=n,t.xmax+=n,t.ymin+=i,t.ymax+=i,e!=null&&((u=t.zmin)!=null||(t.zmin=0),t.zmin+=e,(r=t.zmax)!=null||(t.zmax=0),t.zmax+=e),t;const l=I(t),s=t.type==="polyline"?t.paths:t.rings;for(let o=0;o<l.length;o++){const a=l[o];for(let h=0;h<a.length;h++)a[h]=N(a[h],n,i,e)}return"paths"in t?t.paths=s:t.rings=s,t}function ct(t,n,i,e,l){const s=t.clone(),u=e.resolution;if(s.type==="point"){if(l)G(s,n*u,-i*u);else{const r=e.state.transform,o=e.state.inverseTransform,a=r[0]*s.x+r[2]*s.y+r[4],h=r[1]*s.x+r[3]*s.y+r[5];s.x=o[0]*(a+n)+o[2]*(h+i)+o[4],s.y=o[1]*(a+n)+o[3]*(h+i)+o[5]}return s}if(s.type==="multipoint"){if(l)G(s,n*u,-i*u);else{const r=s.points,o=e.state.transform,a=e.state.inverseTransform;for(let h=0;h<r.length;h++){const p=r[h],y=o[0]*p[0]+o[2]*p[1]+o[4],d=o[1]*p[0]+o[3]*p[1]+o[5],m=a[0]*(y+n)+a[2]*(d+i)+a[4],g=a[1]*(y+n)+a[3]*(d+i)+a[5];r[h]=w(p,m,g,void 0)}}return s}if(s.type==="extent"){if(l)G(s,n*u,-i*u);else{const r=e.state.transform,o=e.state.inverseTransform,a=r[0]*s.xmin+r[2]*s.ymin+r[4],h=r[1]*s.xmin+r[3]*s.ymin+r[5],p=r[0]*s.xmax+r[2]*s.ymax+r[4],y=r[1]*s.xmax+r[3]*s.ymax+r[5];s.xmin=o[0]*(a+n)+o[2]*(h+i)+o[4],s.ymin=o[1]*(a+n)+o[3]*(h+i)+o[5],s.xmax=o[0]*(p+n)+o[2]*(y+i)+o[4],s.ymax=o[1]*(p+n)+o[3]*(y+i)+o[5]}return s}if(l)G(s,n*u,-i*u);else{const r=I(s),o=s.type==="polyline"?s.paths:s.rings,a=e.state.transform,h=e.state.inverseTransform;for(let p=0;p<r.length;p++){const y=r[p];for(let d=0;d<y.length;d++){const m=y[d],g=a[0]*m[0]+a[2]*m[1]+a[4],f=a[1]*m[0]+a[3]*m[1]+a[5],S=h[0]*(g+n)+h[2]*(f+i)+h[4],x=h[1]*(g+n)+h[3]*(f+i)+h[5];y[d]=w(m,S,x,void 0)}}"paths"in s?s.paths=o:s.rings=o}return s}function yt(t,n,i,e){if(t.type==="point"){const{x:m,y:g}=t,f=e?e[0]:m,S=e?e[1]:g,x=t.clone(),C=(m-f)*n+f,c=(g-S)*i+S;return x.x=C,x.y=c,x}if(t.type==="multipoint"){const m=I(t),g=E(),[f,S,x,C]=L(g,[m]),c=e?e[0]:(f+x)/2,M=e?e[1]:(C+S)/2,P=t.clone(),H=P.points;for(let D=0;D<H.length;D++){const T=H[D],[J,U]=T,V=(J-c)*n+c,Z=(U-M)*i+M;H[D]=w(T,V,Z,void 0)}return P}if(t.type==="extent"){const{xmin:m,xmax:g,ymin:f,ymax:S}=t,x=e?e[0]:(m+g)/2,C=e?e[1]:(S+f)/2,c=t.clone();if(c.xmin=(m-x)*n+x,c.ymax=(S-C)*i+C,c.xmax=(g-x)*n+x,c.ymin=(f-C)*i+C,c.xmin>c.xmax){const M=c.xmin,P=c.xmax;c.xmin=P,c.xmax=M}if(c.ymin>c.ymax){const M=c.ymin,P=c.ymax;c.ymin=P,c.ymax=M}return c}const l=I(t),s=E(),[u,r,o,a]=L(s,l),h=e?e[0]:(u+o)/2,p=e?e[1]:(a+r)/2,y=t.clone(),d=y.type==="polyline"?y.paths:y.rings;for(let m=0;m<l.length;m++){const g=l[m];for(let f=0;f<g.length;f++){const S=g[f],[x,C]=S,c=(x-h)*n+h,M=(C-p)*i+p;d[m][f]=w(S,c,M,void 0)}}return"paths"in y?y.paths=d:y.rings=d,y}function mt(t,n,i,e,l,s){const u=Math.sqrt((i-t)*(i-t)+(e-n)*(e-n));return Math.sqrt((l-t)*(l-t)+(s-n)*(s-n))/u}function pt(t,n,i,e=!1){const l=Math.atan2(n.y-i.y,n.x-i.x)-Math.atan2(t.y-i.y,t.x-i.x),s=Math.atan2(Math.sin(l),Math.cos(l));return e?s:j(s)}function N(t,n,i,e){return w(t,t[0]+n,t[1]+i,t[2]!=null&&e!=null?t[2]+e:void 0)}function w(t,n,i,e){const l=[n,i];return t.length>2&&l.push(e!=null?e:t[2]),t.length>3&&l.push(t[3]),l}function rt(t){let n=0,i=0,e=0;return t?(t.type==="cim"&&t.data.symbol&&"symbolLayers"in t.data.symbol&&t.data.symbol.symbolLayers&&t.data.symbol.symbolLayers.map(l=>{l.type==="CIMVectorMarker"&&l.anchorPoint&&(Math.abs(l.anchorPoint.x)>n&&(n=l.anchorPoint.x),Math.abs(l.anchorPoint.y)>i&&(i=l.anchorPoint.y),z(l.size)&&l.size>e&&(e=l.size))}),n=k(n),i=k(i),e=k(e),{offsetX:n,offsetY:i,size:e}):{offsetX:n,offsetY:i,size:e}}let b=class extends A{set graphic(t){this._circleCollisionCache=null,this._originalSymbol=t.symbol,this._set("graphic",t),this.attachSymbolChanged()}get elevationInfo(){const{layer:t}=this.graphic,n=t&&"elevationInfo"in t?t.elevationInfo:null,i=F(this.graphic),e=n?n.offset:0;return new Q({mode:i,offset:e})}set focusedSymbol(t){t!==this._get("focusedSymbol")&&(this._set("focusedSymbol",t),this._updateGraphicSymbol(),this._circleCollisionCache=null)}grabbableForEvent(){return!0}set grabbing(t){t!==this._get("grabbing")&&(this._set("grabbing",t),this._updateGraphicSymbol())}set hovering(t){t!==this._get("hovering")&&(this._set("hovering",t),this._updateGraphicSymbol())}set selected(t){t!==this._get("selected")&&(this._set("selected",t),this._updateGraphicSymbol(),this.events.emit("select-changed",{action:t?"select":"deselect"}))}get _focused(){return this._get("hovering")||this._get("grabbing")}constructor(t){super(t),this.layer=null,this.interactive=!0,this.selectable=!1,this.grabbable=!0,this.dragging=!1,this.cursor=null,this.events=new B.EventEmitter,this._circleCollisionCache=null,this._graphicSymbolChangedHandle=null,this._originalSymbol=null}destroy(){this.detachSymbolChanged(),this._resetGraphicSymbol(),this._set("view",null)}intersectionDistance(t){const n=this.graphic;if(n.visible===!1)return null;const i=n.geometry;if(R(i))return null;const e=this._get("focusedSymbol"),l=z(e)?e:n.symbol;return this.view.type==="2d"?this._intersectDistance2D(this.view,t,i,l):this._intersectDistance3D(this.view,t,n)}attach(){this.attachSymbolChanged(),z(this.layer)&&this.layer.add(this.graphic)}detach(){this.detachSymbolChanged(),this._resetGraphicSymbol(),z(this.layer)&&this.layer.remove(this.graphic)}attachSymbolChanged(){this.detachSymbolChanged(),this._graphicSymbolChangedHandle=K(()=>{var t;return(t=this.graphic)==null?void 0:t.symbol},t=>{z(t)&&t!==this.focusedSymbol&&t!==this._originalSymbol&&(this._originalSymbol=t,this._focused&&z(this.focusedSymbol)&&(this.graphic.symbol=this.focusedSymbol))},W)}detachSymbolChanged(){z(this._graphicSymbolChangedHandle)&&(this._graphicSymbolChangedHandle.remove(),this._graphicSymbolChangedHandle=null)}onElevationChange(){}onViewChange(){}_updateGraphicSymbol(){this.graphic.symbol=this._focused&&z(this.focusedSymbol)?this.focusedSymbol:this._originalSymbol}_resetGraphicSymbol(){this.graphic.symbol=this._originalSymbol}_intersectDistance2D(t,n,i,e){var u,r;if(e=e||$(i),R(e))return null;const l=1;let s=this._circleCollisionCache;if(i.type==="point"&&e.type==="cim"&&((u=e.data.symbol)==null?void 0:u.type)==="CIMPointSymbol"&&e.data.symbol.symbolLayers){const{offsetX:o,offsetY:a,size:h}=rt(e),p=O(n,Y),y=h/2,d=t.toScreen(i),m=d.x+o,g=d.y+a;return q(p,[m,g])<y*y?l:null}if(i.type!=="point"||e.type!=="simple-marker")return tt(n,i,t)?l:null;if(R(s)||!s.originalPoint.equals(i)){const o=i,a=t.spatialReference;if(et(o.spatialReference,a)){const h=it(o,a);s={originalPoint:o.clone(),mapPoint:h,radiusPx:k(e.size)},this._circleCollisionCache=s}}if(z(s)){const o=O(n,Y),a=(r=t.toScreen)==null?void 0:r.call(t,s.mapPoint);if(!a)return null;const h=s.radiusPx,p=a.x+k(e.xoffset),y=a.y-k(e.yoffset);return q(o,[p,y])<h*h?l:null}return null}_intersectDistance3D(t,n,i){const e=t.toMap(n,{include:[i]});return e&&nt(e,X,t.renderSpatialReference)?st(X,t.state.camera.eye):null}};v([_({constructOnly:!0,nonNullable:!0})],b.prototype,"graphic",null),v([_()],b.prototype,"elevationInfo",null),v([_({constructOnly:!0,nonNullable:!0})],b.prototype,"view",void 0),v([_({value:null})],b.prototype,"focusedSymbol",null),v([_({constructOnly:!0})],b.prototype,"layer",void 0),v([_()],b.prototype,"interactive",void 0),v([_()],b.prototype,"selectable",void 0),v([_()],b.prototype,"grabbable",void 0),v([_({value:!1})],b.prototype,"grabbing",null),v([_()],b.prototype,"dragging",void 0),v([_()],b.prototype,"hovering",null),v([_({value:!1})],b.prototype,"selected",null),v([_()],b.prototype,"cursor",void 0),b=v([ot("esri.views.interactive.GraphicManipulator")],b);const X=at(),Y=lt();export{pt as a,G as i,b as j,mt as m,ct as r,yt as s,rt as t};
